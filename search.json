[{"title":"ABC248 E 题解","url":"/2022/04/16/ABC248-E-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"ABC248-E-题解\"><a href=\"#ABC248-E-题解\" class=\"headerlink\" title=\"ABC248 E 题解\"></a>ABC248 E 题解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>计算几何用向量，把初中的知识扔到垃圾桶里面！</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"赛时错解\"><a href=\"#赛时错解\" class=\"headerlink\" title=\"赛时错解\"></a>赛时错解</h3><p>赛时的时候大概想的是把任意两点之间的直线方程写出来，之后计算有多少个相同的直线方程就可以了。</p>\n<p>这样看上去是不是很对？而且复杂度也是恰到好处的$O(n^3\\log n)$。</p>\n<span id=\"more\"></span>\n<p>随便造一组数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">3 2</span><br><span class=\"line\">-1000000000 -1000000000</span><br><span class=\"line\">1000000000 -999999999</span><br><span class=\"line\">1000000000 -999999998</span><br></pre></td></tr></table></figure>\n<p>可以发现在这样的精度下，结果精确到了小数点后第10位，这时，如果坐标比较随机，这样我们拿一个点的$(x,y)$通过$x\\cdot k+b-y=0$来判断是否在一条直线上，精度误差会非常大，就可能得到不在这条直线上的结论。</p>\n<p>什么意思呢？看这组数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">3 2</span><br><span class=\"line\">526541302 530345686</span><br><span class=\"line\">658662535 384363763</span><br><span class=\"line\">362264287 332982928</span><br></pre></td></tr></table></figure>\n<p>这个斜率我们是拿除法算出来的，但是当我们再乘回去时，就损失了非常大的精度（至少9位，如果除法非常准确的话），这就导致一个点的$x\\cdot k+b-y=0.000000000058208$，比我设定的精度$1e-12$大，所以得到了错误的结果（赛时我还一直在想如何增加精度，但是这样只是增加了小数点的位数，除法损失的精度依然不能弥补）。</p>\n<p>所以，我们最好在答案要求保留几位小数或值域不大时使用初中的方法。</p>\n<p>但是，这道题值域为$[-1e9,1e9]$，明摆着不放long double过，我们需要使用更高级的方法判断共线——向量。</p>\n<h3 id=\"向量正解\"><a href=\"#向量正解\" class=\"headerlink\" title=\"向量正解\"></a>向量正解</h3><p>还记得这个公式吗：若$\\overrightarrow {AB} = k\\cdot\\overrightarrow{AC}$，则$A,B,C$三点共线。</p>\n<p>于是，设$A = (x_1,y_1),B = (x_2,y_2),C = (x_3,y_3)$，则$(x_1-x_2)\\cdot(y_1-y_3) = (x_1-x_3)\\cdot (y_1-y_2)$。</p>\n<p>我们可以用乘法判断三点是否共线，只要枚举两点，再看和它们共线的点有多少个就行了。</p>\n<p>至于重复，由于这个$n$很小，可以直接用$vis[i][j]$表示是否访问过第$i$个点和第$j$个点组成的直线。</p>\n<p>总时间复杂度$O(n^3)$。</p>\n<p>（这貌似是我第一次用向量解决OI问题）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e3</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,vis[N][N],ans;</span><br><span class=\"line\">__int128 x[N],y[N];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">read</span><span class=\"params\">(__int128 &amp;x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp;</span><br><span class=\"line\">\tcin&gt;&gt;tmp;</span><br><span class=\"line\">\tx = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Infinity&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">read</span>(x[i]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">read</span>(y[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">push_back</span>(j);</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> cnt = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">1</span>;p&lt;=n;p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (p == i || p == j || vis[p][i] || vis[p][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((x[i]-x[j])*(y[i]-y[p]) == (y[i]-y[j])*(x[i]-x[p]))&#123;</span><br><span class=\"line\">\t\t\t\t\tcnt++;</span><br><span class=\"line\">\t\t\t\t\ta.<span class=\"built_in\">push_back</span>(p);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x:a)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> y:a)&#123;</span><br><span class=\"line\">\t\t\t\t\tvis[x][y] = vis[y][x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tans+=(cnt&gt;=k);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","数学","计算几何"]},{"title":"Blog is open now!","url":"/2022/01/24/Blog-is-open-now/","content":"<h2 id=\"博客迁移已完成，之后的东西大概都在这里写了\"><a href=\"#博客迁移已完成，之后的东西大概都在这里写了\" class=\"headerlink\" title=\"博客迁移已完成，之后的东西大概都在这里写了\"></a>博客迁移已完成，之后的东西大概都在这里写了</h2><p>由于多重原因，洛谷博客据说要没了，昨晚考虑把博客迁移到这里来，经过一中午和一下午的努力，博客迁移工作终于完成了，之后的东西就都在这里写吧。</p>\n<p><a href=\"https://imgtu.com/i/7TSqln\"><img src=\"https://s4.ax1x.com/2022/01/24/7TSqln.png\" alt=\"截图\"></a></p>\n","tags":["Life"]},{"title":"P2261 余数求和 题解","url":"/2022/04/01/P2261-%E4%BD%99%E6%95%B0%E6%B1%82%E5%92%8C-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"P2261-余数求和-题解\"><a href=\"#P2261-余数求和-题解\" class=\"headerlink\" title=\"P2261 余数求和 题解\"></a>P2261 余数求和 题解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>好像每次看到这个题都挺懵的，思路不太好想。</p>\n<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给定$n$和$k$，求出$k \\ mod \\ 1+k \\ mod \\ 2+ \\cdot \\cdot \\cdot k \\ mod \\ n$。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>这个东西看上去就不太能直接求。</p>\n<p>我们既然不能一眼看出怎么求，那就多看几眼。</p>\n<p>$k \\ mod \\ i = k-\\lfloor k/i \\rfloor \\cdot i$</p>\n<p>这样，我们要求的东西就变成了：$k \\cdot n - \\sum_{i=1}^{n} \\lfloor k/i \\rfloor \\cdot i$</p>\n<p>这个$\\lfloor k/i \\rfloor$显然在$i$更大时变化的几率会越来越小，我们想一想怎么把它变化的规律找出来。</p>\n<p>（事实上，这个好像是数论分块里的内容，只能说：见多识广啊）</p>\n<p>我们凭空捏造一个函数$g(x) = \\lfloor k/\\lfloor k/x \\rfloor \\rfloor$。</p>\n<p>$f(x) = k/x$是单调递减的，所以$g(x)\\geq\\lfloor k/(k/x) \\rfloor = x$，所以$\\lfloor k/g(x) \\rfloor \\leq \\lfloor k/x \\rfloor$。</p>\n<p>又因为$\\lfloor k/g(x) \\rfloor \\geq \\lfloor k/(k/\\lfloor k/x \\rfloor) \\rfloor = \\lfloor k/x \\rfloor$，所以$\\lfloor k/g(x) \\rfloor = \\lfloor k/x \\rfloor$。</p>\n<p>所以，对于任意$i \\in [x,\\lfloor k/ \\lfloor k/x \\rfloor \\rfloor]$，$\\lfloor k/i \\rfloor$都相等。</p>\n<p>而且，每个数都必然属于所有区间中的一个，所以我们可以枚举左右端点，里面的$\\lfloor k/i \\rfloor \\cdot i$就是等差数列求和。</p>\n<p>由于在$\\sqrt{k}$以内的$i$，最多有$\\sqrt{k}$个$\\lfloor k/i \\rfloor$，所以这个式子的取值最多有$\\sqrt{k}$种，而在$\\sqrt{k}$以外的$i$，$k/i\\leq \\sqrt{k}$，所以这个式子最多也有$\\sqrt{k}$种取值，那么对于所有的$i$，最多只有$2\\sqrt{k}$种取值，所以整个算法的时间复杂度为$O(\\sqrt{k})$。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">int</span> n,k;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r,ans = n*k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=n;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (k/l == <span class=\"number\">0</span>) r = n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = <span class=\"built_in\">min</span>(k/(k/l),n);</span><br><span class=\"line\">\t\tans-=(r-l+<span class=\"number\">1</span>)*(k/l*l+k/l*r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","数学"]},{"title":"NOIP2021 Journal","url":"/2021/11/20/NOIP2021-Journal/","content":"<p>人生中第一场NOIP，就这样落幕了</p>\n<h1 id=\"Day-1\"><a href=\"#Day-1\" class=\"headerlink\" title=\"Day -1\"></a>Day -1</h1><p>随便打了几个板子，发现没有什么需要复习的，因为所学实在太少，心态也十分放松，大概是知道自己状态不好，在短时间内也无法挽救，不会的知识实在太多，而能熟练运用的又太少，感觉再做什么也无济于事了。</p>\n<p><del>于是看了Person Of Interest Season 4，突然很想写一个能和我对话、保护我、洞悉世事的程序</del></p>\n<p>是的，考试的前一天就这样平凡地过去了  </p>\n<span id=\"more\"></span>\n<h1 id=\"Day-1-1\"><a href=\"#Day-1-1\" class=\"headerlink\" title=\"Day 1\"></a>Day 1</h1><p>大概7：50就进了考场，找到自己的座位，却发现电脑没开。于是自行打开，却发现有两个Windows10？等了一会，老师说用第二个，于是不那么顺利地进入了系统。</p>\n<p>先把缺省源打了，之后打了个对拍器，发现没关同步，于是加了两行代码到缺省源里，设置了编译选项，准备工作完成。</p>\n<p>大概在打完后不就，发现试卷的密码在大屏幕上，好像是IronHeart之类的（<del>钢铁雄心？？？</del>），难道出题人是Paradox玩家？但是没时间想那么多了，解压完成后就立刻打开了试题。</p>\n<p>照例先开第一题，发现题目说的东西很奇怪，而且数据范围也并非线性：$1e7$，这$O(nlogn)$都有点悬，不会要$O(n)$吧，但是这样也小了个七八倍，反正就很奇怪。</p>\n<p>之后仔细看了下题，发现只要把每一个符合条件的数的倍数都标记一遍就行了？（好像这便是著名的$O(nlogn)$算法）</p>\n<p>但是我觉得题目肯定不会这么简单，这样写肯定是要被卡的，于是研究了很久的性质，发现只要标记一个符合条件的数的质数倍就行了，因为合数肯定可以表示为若干个质数的乘积。</p>\n<p>但是即使这样写，也可能有TLE的风险，因为这样筛并不是绝对线性的，例如<strong>宇宙所有问题的终极答案$42$</strong>，它既可以表示成$14\\times3 = 7\\times2\\times3$，也可以表示成$21\\times2 = 7\\times3\\times2$，这样数$42$就被标记了两次，显然还有更多这样的数，所以这样做就不是线性的</p>\n<p>如何让每个数只被标记一次呢？其实也很显然：只要一个数的倍数被分解为的质因数中最小的数小于等于要乘的质数，就行了，因为满足倍数被分解为若干个不降的质数的情况只有一种。很好，这样就是完全线性的了！</p>\n<p>但是我没想到的是，由于还要用一遍$Euler$筛筛出所有的质数，所以复杂度是两个$O(n)$的，实测跑的比广为流传的$O(nlogn)$算法还要慢。。。</p>\n<p>由于各种意想不到的$bug$，过了$1.5h$才打完T1且开拍了</p>\n<p>算了，反正T1写完了，按理说要看T2了，于是我就看了。</p>\n<p>第一眼是一个以$m+1$为指数的暴力，开心地在$30min$左右写完了，发现样例2要跑$11s$？感觉再优化也没什么希望了，就暂时放下了，开T3</p>\n<p>T3一看，就想到了ZROI上的一道题，然而看了好久，发现其本质不是一个东西，拿前缀和推也没啥性质，而且这个序列可能可以无限操作下去，很难有重复的情况，推了一堆没有用的东西，发现只剩下$1.5h$左右了，以我的水平顶多打几个暴力走人，于是看了眼T4，发现没啥希望，跟斗地主一样恶心，就回去看T2了</p>\n<p>突然发现这样搜索搜到了很多重复的情况，很明显是不优的，如果改成枚举每一位选了多少个，就可以用排列乘出所有的情况，复杂度有了小小的改善，于是开写</p>\n<p>写完之后，发现乘那个权值时<strong>int128爆了，于是开始写高精，发现不会$log$的取模，于是把写了$45min$的高精代码删了，又改成</strong>int128，感觉没啥希望了，于是写T3的暴力</p>\n<p>T3由于不知道要操作多少次，就找了一个有可能过$n&lt;=10$的点且不超时的$9$次放进去了，发现第二个样例都过不了，此时离考试结束只有$30min$不到了，于是把考生须知填了，之后开始打坐。</p>\n<p>所有程序的文件名检查完之后，又看了一眼题面，试图找到一点思路，突然发现T2说的是小于等于$k$，草！</p>\n<p>于是疯狂改，再边乘边取模，最后竟然过了样例2？很满意</p>\n<p>打铃，收卷，结束。</p>\n<p>是的，我的第一场NOIP就这样结束了，内心毫无波澜的提交了文件夹，看见人均200+，虽有失望，可是并没有为此懊恼，因为有那么多没学的，有那么多不会的$trick$，这也很公平。</p>\n<p>停课结束后，又要投入到紧张的$whk$学习中，虽然有那么多不会的，那又如何呢，总是要补的。</p>\n<p>其实，生活中许多不如意，是你欠你自己的，付出与回报不会成正比，但是要回报，必须付出些什么，而最不必的便是为这些付出懊恼，你欠的，总是要还回来的嘛。</p>\n<blockquote>\n<p>This is my final fit</p>\n<p>My final bellyache with</p>\n<p>No alarms and no surprises</p>\n<p>No alarms and no surprises please</p>\n</blockquote>\n","tags":["Life"]},{"title":"P3959 宝藏 题解","url":"/2022/03/28/P3959-%E5%AE%9D%E8%97%8F-%E9%A2%98%E8%A7%A3/","content":"<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给出一个$n$个节点，$m$条边的图，你可以选定一个节点，从这个节点开始遍历整个图，其中每走到一条新的边，就要花费$l*k$的代价，其中$l$是这条边的边权，$k$是从你选定的点到这条边的起点经过的宝藏屋的数量。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"一些初步的想法\"><a href=\"#一些初步的想法\" class=\"headerlink\" title=\"一些初步的想法\"></a>一些初步的想法</h3><p>没有啥思路就直接暴搜。</p>\n<p>首先要枚举选择的起点，还要枚举选择的边，形式化的说，给每个边都定一个访问顺序，如果不访问就设为$0$，每个点都有$n+1$种选择，复杂度大概是$O(m^n)$的，啥都过不了。</p>\n<p>于是考虑优化。</p>\n<p>选定的边组成的必然是一棵树，这样才能使代价最小，而对于同一棵树而言，节点的选择顺序不会对答案有影响，所以我们可以枚举树，计算每个树的答案。枚举的过程是从$m$条边中选择$n-1$条，复杂度是$m\\cdot(m-1)\\cdot (m-2) \\cdot \\cdot \\cdot (m-n+1)$，计算每个树的答案可以直接换根dp解决，复杂度是$O(n)$的，这时，复杂度已经有了明显的改善。</p>\n<p>还有没有优化空间呢？有。</p>\n<p>因为我们是随便找出的$n-1$条边，它们不一定能构成树，而且题目里面有重边，显然我们只用选一个长度最小的就行了，这样边最多是$66$条，复杂度明显降低了。</p>\n<p>但是这里的$n$和$m$依旧不是一个量级的，我们能不能用$n$作为复杂度呢？</p>\n<p>我们直接搜索，重复状态很多，同一张图，选择不同的根，就会有$n$种状态，而我们用这个图转移到下一个图，只用从其中最小的状态转移，这样就减少了很多重复计算。</p>\n<p>既然状态有很多重复的，但是状态空间并不大，我们可以考虑使用<strong>状压DP</strong>优化。</p>\n<h3 id=\"一种错误的解法\"><a href=\"#一种错误的解法\" class=\"headerlink\" title=\"一种错误的解法\"></a>一种错误的解法</h3><p>设点$i$被选择为$1$，不被选择为$0$，这样我们可以表示在每个阶段中的状态。</p>\n<p>设$f[i]$表示压缩后的点的选择情况，我们枚举每个没有被选择，且能从已经被选择的其中一个点到达的点，选择一条路径到达那个点，这样就可以计算出要转移到的状态和最小值，如果存在一个更优解，就从这个状态继续转移。</p>\n<p>但是，一定是在有更优解的时候才会转移吗？</p>\n<p>如果一个点的深度比较小，但是这个点连向下一个点的边权比较大，我们可能会因为它转移到下一个状态时不是最优解而不再转移，但是如果让它继续转移下去，下面的点之间的边权较小，就有可能因为它的深度获益，这样可能会达到一个更优的解。</p>\n<p>所以，我认为这样做是错误的。</p>\n<p>据cyh大佬说，这是因为在同一个状态$s$中可能有一个点的深度不同，那么就不知道用哪个深度转移是最优的。</p>\n<h3 id=\"正确解法\"><a href=\"#正确解法\" class=\"headerlink\" title=\"正确解法\"></a>正确解法</h3><p>上面算法的错误在于没有限定深度，导致不同深度的时候转移不完全，我们其实可以限定一个当前的最大深度，之后把所有位于最大深度的点转移。</p>\n<p>设$f[i][j]$表示在最大深度为$i$，选择状态为$j$时的最小花费，那么$f[i][j] = max(f[i][j],f[i-1][k]+(i-1)\\cdot cost(j,k))$。</p>\n<p>我们先判断上一个状态的合法性：</p>\n<p>首先，这个状态要被转移过，否则转移它也没啥用，所以$f[i-1][k]$不等于初始值。</p>\n<p>其次，这个状态要满足从$k$能转移到$j$，这时就要考虑两个限制：</p>\n<ol>\n<li>$k$是$j$的一个子集，因为状态转移，选择的点只增不减。</li>\n<li>$j$是$expand(k)$的一个子集，$expand(k)$表示从$k$中已经选择的所有点往深度为$i$的点扩展，能够扩展到的所有点，则$j$必然在能够扩展到的点集内。</li>\n</ol>\n<p>我们再考虑如何计算扩展所需的花费$cost(j,k)$。</p>\n<p>先要找到所有被扩展的点，这个可以通过$j \\oplus k$计算出来。</p>\n<p>还要知道每个点被扩展所需的最小花费，由于每个$k$中的点深度都为$i-1$，所以到要扩展的点的经过的宝藏屋的数量是一样的，我们只用考虑路径长度就行了，而路径长度可以通过之前的$expand(k)$计算，即将所有能连向要扩展的点的路径长度取min。</p>\n<p>这样我们就完成了最重要的一步<strong>状态转移</strong>。</p>\n<p>之后就是初始化了，对于所有$x \\in [1,n]$，$f[1][(1&lt;&lt;x)] = 0$，因为是赞助商免费打通的，不需要费用，其他的都没有被转移，为了避免转移不合法的状态，其他的都设为$+ \\infty$。</p>\n<p>但是这样做，复杂度还不是最优的，因为$expand$和$cost$函数都会被重复计算很多次，我们可以预处理出来。</p>\n<p>时间复杂度：$O(n3^n+m2^n)$。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">25</span>,M = (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,edge[N][N],f[N][M],valid[M][M],cost[M][M],road[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">expand</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span>&#123; <span class=\"comment\">//复杂度为O(n^2) </span></span><br><span class=\"line\">\t<span class=\"type\">int</span> exp = i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;n;p++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;p)&amp;i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> q=<span class=\"number\">0</span>;q&lt;n;q++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (((<span class=\"number\">1</span>&lt;&lt;q)&amp;i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[p][q]&lt;=<span class=\"number\">10000000</span>)&#123;</span><br><span class=\"line\">\t\t\t\troad[q] = <span class=\"built_in\">min</span>(road[q],edge[p][q]);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;q)&amp;exp)) exp+=(<span class=\"number\">1</span>&lt;&lt;q);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> exp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//这里枚举顺序换一下会有优化效果，但是我喜欢在里面算exp，所以就不改了 </span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123; <span class=\"comment\">//之前的集合</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(road,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(road));</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> exp = <span class=\"built_in\">expand</span>(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;n);j++)&#123; <span class=\"comment\">//转移的集合</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((i&amp;j) == i &amp;&amp; (exp&amp;j) == j)&#123; <span class=\"comment\">//合法</span></span><br><span class=\"line\">\t\t\t\tvalid[i][j] = <span class=\"number\">1</span>; </span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;n;p++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ((j&amp;(<span class=\"number\">1</span>&lt;&lt;p)) &amp;&amp; !(i&amp;(<span class=\"number\">1</span>&lt;&lt;p))) cost[i][j]+=road[p];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(edge,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(edge));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\tx--;</span><br><span class=\"line\">\t\ty--;</span><br><span class=\"line\">\t\tedge[x][y] = <span class=\"built_in\">min</span>(edge[x][y],z);</span><br><span class=\"line\">\t\tedge[y][x] = <span class=\"built_in\">min</span>(edge[y][x],z);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) f[<span class=\"number\">1</span>][<span class=\"number\">1</span>&lt;&lt;i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123; <span class=\"comment\">//枚举深度 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;n);j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;(<span class=\"number\">1</span>&lt;&lt;n);p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (valid[j][p] &amp;&amp; f[i<span class=\"number\">-1</span>][j]&lt;=<span class=\"number\">100000000</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tf[i][p] = <span class=\"built_in\">min</span>(f[i][p],f[i<span class=\"number\">-1</span>][j]+(i<span class=\"number\">-1</span>)*cost[j][p]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> Min = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) Min = <span class=\"built_in\">min</span>(Min,f[i][(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\tcout&lt;&lt;Min&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","DP"]},{"title":"Counting Swaps 题解","url":"/2022/04/11/Counting-Swaps-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Counting-Swaps-题解\"><a href=\"#Counting-Swaps-题解\" class=\"headerlink\" title=\"Counting Swaps 题解\"></a>Counting Swaps 题解</h1><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我们得到的序列是$p_1,p_2\\cdots p_n$，如果从每个$i$向$p_j=i$的$j$连一条边，那么我们的目标就是使这个图中存在$n$个自环。</p>\n<h3 id=\"观察题目，得到猜想\"><a href=\"#观察题目，得到猜想\" class=\"headerlink\" title=\"观察题目，得到猜想\"></a>观察题目，得到猜想</h3><span id=\"more\"></span>\n<p><strong>结论1：这个图必然由若干个环构成。</strong></p>\n<p>由于点$i$连向$p_j=i$的$j$和$p_i$，所以每个点必然连接着两条边。如果图中有不是环的东西，那么必然存在一个点，其只有一条出边，这与每个点都连接两条边矛盾，所以原命题成立。</p>\n<p><strong>思考1：交换$p_i$和$p_j$会对原图产生什么影响？</strong></p>\n<p>之前连向$p_i$的是$p_q=i$的$q$和编号为$p_i$的点。</p>\n<p>显然，根据连边的规则，从编号为$p_i$的点连向$j$的边不会改变，但是另一条边变成了从$p_{q’}=j$连向$p_i$的边。</p>\n<p>另一个点连接的两个点分别是编号为$p_j$和$p_{q’’}=i$。</p>\n<p>其实手动模拟一下可能会更清晰。</p>\n<p>这样，这两个点就交换了各自的一条边，形成了两个环。</p>\n<p>形式化的说，如果原来的环是$v_1\\rightarrow v_2\\cdots v_n\\to v_1$，交换$i,j$（令$i&lt;j$）之后的环就变成了$v_i\\to v_{i+1}\\cdots v_j\\to v_i$和$v_1\\to v_2\\cdots v_i\\to v_{j+1}\\cdots v_n\\to v_1$。</p>\n<p>得到结论：在一个长度为$n$的环内交换$i,j$，会变成两个长度为$j-i$和$n-j+i$的环。</p>\n<p><strong>结论2：将一个包含$m$个点的环拆成$m$个自环，最少需要$m-1$次操作。</strong></p>\n<p>用数学归纳法证明。</p>\n<p>在$m=1$时，自己本身就是自环了，不用拆，需要$1-1 = 0$次操作。</p>\n<p>假设对于任意$i\\in [1,m-1]$，都只需要$m-1$次操作，那么对于一个长度为$m$的环，我们可以</p>\n<p>任取两个点$i,j$，交换它们，根据思考1，环将变成$j-i$和$m-j+i$两个环。</p>\n<p>而将这两个环拆成自环需要$j-i-1+m-j+i-1 = m-2$次操作，加上交换$i,j$这一次操作，总共需要$m-1$次操作。</p>\n<p>于是，原命题成立。</p>\n<h3 id=\"进一步思考\"><a href=\"#进一步思考\" class=\"headerlink\" title=\"进一步思考\"></a>进一步思考</h3><p>现在，我们已经知道了最小的次数是$n-$环的个数，要求总共有多少种交换的方法能够达到这个次数。</p>\n<p>设$F_n$表示用最少的次数将一个长度为$n$的环变为$n$个自环的方案数，根据思考1和结论2，我们可以把这个环拆成大小为$x$和$y$的两个环，设$T_(x,y)$表示有多少种方法拆成大小为$x$和$y$的两个环：</p>\n<p>当$x=y$时，$T(x,y) = n/2$，从$i$和$i+x$切没有区别。</p>\n<p>当$x\\neq y$时，$T(x,y) = n$，在任意一个点$i$切都是不同的方案。</p>\n<p>于是，$F_n = \\sum T(x,y)\\cdot F_x\\cdot F_y\\cdot \\frac{(n-2)!}{(x-1)!\\cdot (y-1)!}$。</p>\n<p>最后乘的那个东西可以看作有$x$个0和$y$个1的排列数，直接用多重集的排列数计算即可。</p>\n<p>至于为啥$x$个0都是相同的，因为区分操作的情况在计算$F_x$的时候就已经计算过了，所以这里可以把它们当成相同的。</p>\n<p>因为每个自环计算方案是独立的，所以我们要把所有的方案数乘起来，再像上面一样乘一个多重集的排列数：</p>\n<p>$ans = F_{l_1}\\cdot F_{l_2}\\cdots F_{l_k}\\cdot \\frac{(n-k)!}{(l_1-1)!\\cdot (l_2-1)! \\cdots (l_k-1)!}$。</p>\n<p>这样，我们可以$O(n^2)$推出所有我们需要的$F_i$值，之后乘起来，加个乘法逆元，总复杂度为$O(n^2\\log n)$。</p>\n<p>之后好像就没法优化了，除非你把$F_i$的前几项放到OEIS上去。。。</p>\n<p>于是，我们借助网络得到$F_i$的通向公式：$F_i = i^{i-2}$，这样复杂度就变成了$O(n\\log n)$。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总之，这是一道非常不错（毒瘤）的组合入门题（至少<a href=\"https://www.luogu.com.cn/discuss/53018\">小粉兔是这么说的</a>），考察了对加法原理和乘法原理的理解、数学归纳法的使用、多重集的排列数的了解，需要一定的猜测和证明能力，组合数学的基础才能完全理解。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code$\"></a>$Code$</h2><p>要在处理所有询问之前把$F_i$和阶乘预处理出来，这样复杂度才是对的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,p = <span class=\"number\">1e9</span>+<span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,a[N],head[N],tot,l[N],cnt,vis[N],jie[N],f[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> p)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ans = ans*bas%p;</span><br><span class=\"line\">\t\tbas = bas*bas%p;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tf[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=<span class=\"number\">100000</span>;i++) f[i] = <span class=\"built_in\">ksm</span>(i,i<span class=\"number\">-2</span>,p);</span><br><span class=\"line\">\tjie[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">100000</span>;i++) jie[i] = jie[i<span class=\"number\">-1</span>]*i%p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\tvis[x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tl[cnt]++;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[v]) <span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">long</span> <span class=\"type\">long</span>)*(n+<span class=\"number\">100</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(l,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">long</span> <span class=\"type\">long</span>)*(n+<span class=\"number\">100</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">long</span> <span class=\"type\">long</span>)*(n+<span class=\"number\">100</span>));</span><br><span class=\"line\">\t\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(a[i],i);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(i,a[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\t\tcnt++;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">dfs</span>(i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">1</span>,num = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class=\"line\">\t\t\tans*=f[l[i]];</span><br><span class=\"line\">\t\t\tans%=p;</span><br><span class=\"line\">\t\t\tnum*=jie[l[i]<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t\tnum%=p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans*=jie[n-cnt]*<span class=\"built_in\">ksm</span>(num,p<span class=\"number\">-2</span>,p)%p;</span><br><span class=\"line\">\t\tans%=p;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","数学","组合数学"]},{"title":"P4662黑手党题解","url":"/2022/03/19/P4662%E9%BB%91%E6%89%8B%E5%85%9A%E9%A2%98%E8%A7%A3/","content":"<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给一个有 $n$ 个点和 $m$ 条边的图，现在给定一个源点 $a$ ，一个汇点 $b$ 和去掉每个点所需的费用，求出需要去掉哪些点，使 $a$ 和 $b$ 不再连通的费用最小。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我们发现，只要把点变成边，边权设为去掉这个点的费用，就变成了求一个网络的最小割，即最大流，于是考虑通过Dinic算法求出最大流。</p>\n<p>我们用拆点解决将点变成边的问题。首先，原来图中就有的边，是不允许去掉的，所以我们要保证它不会被割掉，将其边权设为正无穷。对于图中的点，我们可以把一个点拆成两个，一个称作入点，即有流量进入的点，一个称作出点，即流量流向别的地方的点，我们从入点向出点连边，边权设为费用，这样我们就将点转化为了边。而原来图中连的边，可以看作从一个点的出点连向另一个点的入点。</p>\n<p>之后，我们可以跑一遍Dinic求出最大流，这样我们就找到了最小割。<strong>需要注意的是，题目中说明源点 $a$ 和汇点 $b$ 也是可以去掉的，所以我们要从源点 $a$ 的入边到汇点 $b$ 的出边跑最大流，这样才能让源点 $a$ 和汇点 $b$ 都能被去掉</strong>。</p>\n<p>这一部分是比较常见的套路。</p>\n<p><strong>不太寻常的是题目中的输出，求的是构成最小割的一个方案。</strong></p>\n<p>我们再来思考最小割的意义：</p>\n<p>最小割，即去掉某些边后，网络的源点和汇点不再连通，且边权之和最小。</p>\n<p>显然，在求出最大流后的残量网络中，从源点一定无法到达汇点。</p>\n<p>也就是说，我们只要从源点 $a$ 开始走，走所能到达的点，一定会存在某一时刻走不动了，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/image-20220319170146094.png\" alt=\"\"></p>\n<p>此图中，从源点 $a$ 开始，一直走，直到走到了 $x$，发现后面再走 $y$ 和 $z$ 的边权都为 $0$ ，不能继续走了，就说明如果将 $y$ 和 $z$ 割掉，源点途径 $x$ 的路径就永远无法到达汇点，也就是说，所有满足这样，这条边指向的点（如 $x$ ）被访问，但是出发点（如 $y$ 和 $z$ ）没有被访问的点，都是需要被去除的点，这样才能构成一个割。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e2</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,dis[N],now[N],in[N],out[N],vis[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; an;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[M*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">    edge[++tot].to = y;</span><br><span class=\"line\">    edge[tot].next = head[x];</span><br><span class=\"line\">    edge[tot].w = w;</span><br><span class=\"line\">    head[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">    dis[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    now[s] = head[s];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">            y = edge[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !dis[y])&#123;</span><br><span class=\"line\">                dis[y] = dis[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                now[y] = head[y];</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> flow)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">    <span class=\"type\">int</span> v,res = flow,use;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=now[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">        v = edge[i].to;</span><br><span class=\"line\">        now[u] = i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; dis[v] == dis[u]+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            use = <span class=\"built_in\">dfs</span>(v,<span class=\"built_in\">min</span>(edge[i].w,res));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!use) dis[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            edge[i].w-=use;</span><br><span class=\"line\">            edge[i^<span class=\"number\">1</span>].w+=use;</span><br><span class=\"line\">            res-=use;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!res) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> flow-res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> v;</span><br><span class=\"line\">    vis[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">        v = edge[i].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !vis[v]) <span class=\"built_in\">dfs2</span>(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"comment\">//算出入点和出点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        in[i] = i*<span class=\"number\">2</span><span class=\"number\">-1</span>;</span><br><span class=\"line\">        out[i] = i*<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = in[s];</span><br><span class=\"line\">    t = out[t];</span><br><span class=\"line\">    <span class=\"comment\">//读入与建图</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[i],out[i],x);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[i],in[i],<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[x],in[y],inf);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[y],out[x],<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[y],in[x],inf);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[x],out[y],<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//Dinic求出最小割</span></span><br><span class=\"line\">    <span class=\"type\">int</span> flow,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (flow = <span class=\"built_in\">dfs</span>(s,inf)) ans+=flow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//求出一个方案使源点和汇点不连通</span></span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=tot;i+=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!vis[edge[i].to] &amp;&amp; vis[edge[i^<span class=\"number\">1</span>].to])&#123;</span><br><span class=\"line\">            an.<span class=\"built_in\">push_back</span>((edge[i^<span class=\"number\">1</span>].to+<span class=\"number\">1</span>)/<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(an.<span class=\"built_in\">begin</span>(),an.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> sz = an.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;sz;i++) cout&lt;&lt;an[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","网络流"]},{"title":"Useless Thoughts(遐想)","url":"/2021/08/02/Useless-Thoughts-%E9%81%90%E6%83%B3/","content":"<p><strong>War, war never changes.</strong></p>\n<p><strong>But peace, peace changes everything.</strong></p>\n<p>犹记得曾经带领举国10个远古军团在《文明Ⅵ》中鲁莽地向自己的友邦瑞士开战，在军队突破阿拉伯的援兵，围在没有任何防御的日内瓦城的所有边界方格上，取得第一次压倒性胜利时的喜悦与狂热，对占领的渴望充斥着我的大脑。  </p>\n<span id=\"more\"></span>\n<p>也记得被阿拉伯疯狂传教、在边境造城挑衅后愤然发起突袭战争，率领接近20个单位的远征大军朝着开罗进发时的意气风发；但谁能想到几回合后我就被困在防御工事内进退不得，只得在阿拉伯的现代化大军到来前从海上逃跑，而又是什么导致了这场战争呢？是对复仇的渴望。</p>\n<p>最近了解了伊拉克战争和阿富汗战争，对此更是深有同感。9.11事件成为了阿富汗战争的导火索，控制石油资源的诱惑则导致了伊拉克战争，反观历史上的重大战争，又有哪个不是基于利益和复仇的呢？</p>\n<p>但在战争的进程中，有一方的力量却被忽视了——士兵。在游戏中，他们被化为单调的数值；在国家之间的战争中，他们被作为实力较量的筹码；在军官心中，他们被作为任人摆布的棋子。哪位国家元首曾将他们与经济损失、基础建设修复、物资补给一起计算战争的代价？P社玩家之所以成为”大恶人”，还不是因为他们无视面板上增加的死亡人数，狂热的发动战争，丝毫没想过那些数字对于他们的家人，挚友意味着什么！战争永远不会是美好的，不会是地图上几条线共同导向的结果，更不会是按动鼠标上的左右键就能完全体会的，其中酿成了多少人间悲剧，造就了多少绝望的结局，我们又如何得知！</p>\n<p>但仔细思考一下，各种冲突才是导致战争的最大缘由：边境冲突，宗教冲突，政党冲突（省略）它们也许是人类永远无法避免的命运。但就像线段树一样，作为叶子节点的我们，如果更加平和、宽容待人，能从生活中一个完美的光影，一个样貌奇特的绿树，一个陌生人的有趣谈话中发现美好，不过于厌世，也不盲目服从，那样也许经过多次pushup操作，上层的祖先们就会更加和睦，做出宝贵的和平决定吧。</p>\n<p>（吹爆COD现代战争三部曲）</p>\n","tags":["Life"]},{"title":"WHK目录","url":"/2022/02/11/WHK%E7%9B%AE%E5%BD%95/","content":"<h1 id=\"目录：\"><a href=\"#目录：\" class=\"headerlink\" title=\"目录：\"></a>目录：</h1><span id=\"more\"></span>\n<h2 id=\"化学\"><a href=\"#化学\" class=\"headerlink\" title=\"化学\"></a>化学</h2><h3 id=\"必修1\"><a href=\"#必修1\" class=\"headerlink\" title=\"必修1\"></a>必修1</h3><h4 id=\"第一单元\"><a href=\"#第一单元\" class=\"headerlink\" title=\"第一单元\"></a>第一单元</h4><h5 id=\"Part-1：物质的分类\"><a href=\"#Part-1：物质的分类\" class=\"headerlink\" title=\"Part 1：物质的分类\"></a>Part 1：<a href=\"https://bowenone580.github.io/2022/02/11/物质的分类/\">物质的分类</a></h5>","tags":["Knowledge","WHK","Menu"]},{"title":"卡特兰数","url":"/2021/08/04/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","content":"<h2 id=\"更新记录\"><a href=\"#更新记录\" class=\"headerlink\" title=\"更新记录\"></a>更新记录</h2><p>2021.9.22 将部分内容替换成了$LaTeX$符号</p>\n<span id=\"more\"></span>  \n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><h3 id=\"排列数\"><a href=\"#排列数\" class=\"headerlink\" title=\"排列数\"></a>排列数</h3><p>$A_n^m$ $ = $ $\\frac{n!}{(n-m)!}$ （从$n$个数中选$m$个来排列）<br>理解为第一位可以有$n$种选择，第二位有$n-1$种，最后一位（即第$m$位）有$n-m+1$种选择<br>故为$n$ $\\times$ $(n-1)$ $\\times$ $(n-2)$ $\\times$ … $\\times$ $(n-m+1) = $ $\\frac{n!}{(n-m)!}$<br>全排列为$n!$</p>\n<h3 id=\"组合数\"><a href=\"#组合数\" class=\"headerlink\" title=\"组合数\"></a>组合数</h3><p>$C_n^m$ $=$ $\\frac{n!}{(n-m)!*m!}$<br>理解为将$A_n^m$的所有组合方式表示出来，也就是$m$的全排列，为$m!$，常将$n$与$m$写在一个括号里: $\\binom{m}{n}$<br>特别说明：$A_n^m$ $= 0$, $C_n^m$ $= 0$</p>\n<p><del>（写了这么多主要是因为看不懂将C写成括号后的表达方式）</del></p>\n<h2 id=\"卡特兰数的证明\"><a href=\"#卡特兰数的证明\" class=\"headerlink\" title=\"卡特兰数的证明\"></a>卡特兰数的证明</h2><p>首先想一个<strong>简单一点</strong>的问题：<br>你有一个栈，$n$个数，它们每一个都要进行一次入栈和出栈操作，请问共有多少种方式<br>可以将每次入栈操作看作 $+1$，出栈看作 $-1$，容易想到，合法的方案必须满足所有时刻的<strong>前缀和$&gt;=0$</strong><br>更形象地，将其转移到坐标系上，每次入栈将横坐标 $+1$，每次出栈将纵坐标 $+1$，则所有的合法情况满足<strong>横坐标值$&gt;=$纵坐标值</strong>，所有的不合法情况满足<strong>纵坐标-横坐标$&gt;=1$</strong>，则所有不合法情况和函数$y=x+1$必有大于等于1个交点，考虑将其转化为如下形式：</p>\n<p><img src=\"https://z3.ax1x.com/2021/09/05/hWt7gx.png\" alt=\"\"></p>\n<p>图中实线为不合法操作路径，将其与$y=x+1$相交后的线段关于$y=x+1$对称，得到的最终点是$(n-1,n+1)$，由于所有不合法路径必然经过$y=x+1$，所以不合法的路径的情况转化为了从$0$到$(n-1,n+1)$的路径总数之和，即$\\binom{n-1}{2n}$或$\\binom{n+1}{2n}$。<br>合法路径总数即为全部路径$-$不合法路径，即$\\binom{n}{2n}$-$\\binom{n-1}{2n}$或$\\binom{n}{2n}$-$\\binom{n+1}{2n}$ </p>\n<p><img src=\"https://z3.ax1x.com/2021/09/05/hWtHv6.md.png\" alt=\"代码示例\"></p>\n","tags":["Knowledge","组合数学"]},{"title":"数论 题解","url":"/2022/05/18/%E6%95%B0%E8%AE%BA-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"数论-题解\"><a href=\"#数论-题解\" class=\"headerlink\" title=\"数论 题解\"></a>数论 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>求$\\sum_{i=1}^n\\sum_{j=1}^p \\varphi(i^j) \\mod 10^9+7$。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>对于这种两个求和套在一起的式子，我们一般要先固定一行，看是否能化简里面的式子。</p>\n<p>发现这道题是要对于一个给定的$i$，计算所有$\\varphi(i^j)$，根据欧拉函数的定义式，可以发现每次乘上一个$i$，其所包含的质因数是不变的，只是结果多乘了一个$i$。</p>\n<p>于是有$\\varphi(i^j) = \\varphi(i)\\cdot i^{j-1}$（这个可以当作结论记下来）。</p>\n<p>把$\\varphi(i)$提出来，得到$\\sum_{j=1}^p = \\varphi(i)\\cdot (1+i+i^2+ \\cdots +i^{p-1})$，这个东西显然可以用等比数列简化：<br>$\\sum_{j=1}^p = \\varphi(i)\\cdot \\frac{i^p-1}{i-1}$。</p>\n<p>于是，我们就在$O(\\log p)$的时间内求出了$\\sum_{j=1}^p \\varphi(i^j)$的值，现在只需要求出外层求和的结果就行了。</p>\n<p>显然，$\\varphi(i)$可以用$O(n)$的时间线性筛出来，于是我们就解决了外层循环。</p>\n<p>但是，这样做的复杂度是$O(n\\cdot \\log p \\log 10^9+7)$的，在这个数据范围下无法通过。</p>\n<p>时间瓶颈在哪里呢？发现，我们在求$\\frac{i^p-1}{i-1}$时，求$i-1$的逆元花费了大量的时间，并且这里的$i$都是连续的，所以我们可以使用线性求逆元优化这个过程。（其实有通用的线性求逆元的方法）。</p>\n<p>还有，在实现时需要注意下$\\varphi(1)$和$inv[1]$之类的细节，而且求$i^p$也要用线性筛当场处理，否则无法通过</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code$:\"></a>$Code$:</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e7</span>+<span class=\"number\">10</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,p,ans,vis[N],pri[N],tot,phi[N],inv[N],pre[N],pw[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ans = ans*bas%mod;</span><br><span class=\"line\">        bas = bas*bas%mod;</span><br><span class=\"line\">        y&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    phi[<span class=\"number\">1</span>] = <span class=\"number\">1</span>; <span class=\"comment\">//注意一下</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">            vis[i] = i;</span><br><span class=\"line\">            pri[++tot] = i;</span><br><span class=\"line\">            phi[i] = i<span class=\"number\">-1</span>;</span><br><span class=\"line\">            pw[i] = <span class=\"built_in\">ksm</span>(i,p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || i*pri[j]&gt;n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            vis[i*pri[j]] = pri[j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i%pri[j]) phi[i*pri[j]] = phi[i]*(pri[j]<span class=\"number\">-1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> phi[i*pri[j]] = phi[i]*pri[j];</span><br><span class=\"line\">            pw[i*pri[j]] = pw[i]*pw[pri[j]]%mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class=\"line\">    <span class=\"built_in\">euler</span>();</span><br><span class=\"line\">    pre[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) pre[i] = pre[i<span class=\"number\">-1</span>]*i%mod;</span><br><span class=\"line\">    <span class=\"type\">int</span> invs = <span class=\"built_in\">ksm</span>(pre[n],mod<span class=\"number\">-2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">        inv[i] = pre[i<span class=\"number\">-1</span>]*invs%mod;</span><br><span class=\"line\">        invs = invs*i%mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans = p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        ans+=phi[i]*(pw[i]<span class=\"number\">-1</span>)%mod*inv[i<span class=\"number\">-1</span>]%mod;</span><br><span class=\"line\">        ans%=mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这道题巧妙的利用了欧拉函数的性质，将内层求和化简为等比数列求和，套上一个外层的线性筛解决。</p>\n<p>而且，这道题还高效的利用了时间，让我学会了在线性筛中求一些数的给定次幂，以及首次在题目中使用线性筛逆元算法，让我意识到一个$\\log$也代表着优化空间，特别是在数非常大的时候。</p>\n","tags":["Knowledge","数学"]},{"title":"树屋阶梯 题解","url":"/2022/04/12/%E6%A0%91%E5%B1%8B%E9%98%B6%E6%A2%AF-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"树屋阶梯-题解\"><a href=\"#树屋阶梯-题解\" class=\"headerlink\" title=\"树屋阶梯 题解\"></a>树屋阶梯 题解</h1><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>最开始，没有任何思路。</p>\n<p>于是看了两眼样例，猜了一些结论，发现这个有可能是对的。</p>\n<p>结论1：每个长度为$n$的阶梯都至少需要$n$个钢板。</p>\n<p>使用数学归纳法证明：</p>\n<span id=\"more\"></span>\n<p>当$n=1$时，需要一个钢板。</p>\n<p>假设这个结论在$[0,n-1]$都成立，我们需要钢板的数量最少，就需要搭建长度为$n-1$的阶梯的最小钢板数量，即$n-1$个，而新增的$n$的这个钢板最上面的一个方格是不可能被之前的任何一个钢板覆盖的，所以这个地方必须要有一个钢板。其他地方的钢板可以直接让长度为$n-1$的阶梯的钢板延伸过来，于是只用$n$个钢板的方案一定存在。</p>\n<p>结论2：我们从右往左看，每次都能在竖直范围内找到一个新的钢板。且这个钢板必然覆盖嘴上面的一块。</p>\n<p>由结论1易得。</p>\n<p>必然有一块钢板覆盖左下角这个点，而它必然覆盖了一个顶点，我们枚举这个钢板覆盖的位置，发现它正好把这个阶梯分成另外两个部分，于是这就变成了求解子问题。</p>\n<p>$f[i] = \\sum_{j=0}^{i-1}f[j]\\cdot f[i-j-1]$。</p>\n<p>这个东西打个表可以发现，跟卡特兰数一模一样，在oi-wiki上也有这个公式的介绍。</p>\n<p>于是，我们的目标就是求第$n$项卡特兰数。</p>\n<h2 id=\"Code-：\"><a href=\"#Code-：\" class=\"headerlink\" title=\"$Code$：\"></a>$Code$：</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>())</span><br><span class=\"line\"><span class=\"built_in\">sum</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">int</span>(a)+<span class=\"number\">1</span>,<span class=\"built_in\">int</span>(a)*<span class=\"number\">2</span>+<span class=\"number\">1</span>,<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>*i</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span> (<span class=\"number\">1</span>,<span class=\"built_in\">int</span>(a)+<span class=\"number\">1</span>,<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>/i</span><br><span class=\"line\"><span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>/(<span class=\"built_in\">int</span>(a)+<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(<span class=\"built_in\">sum</span>))</span><br></pre></td></tr></table></figure>\n<p>（实在不想写高精啊）</p>\n","tags":["Knowledge","数学","组合数学"]},{"title":"同余","url":"/2022/04/05/%E5%90%8C%E4%BD%99/","content":"<h1 id=\"同余\"><a href=\"#同余\" class=\"headerlink\" title=\"同余\"></a>同余</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>如果两个整数$a,b$除以$m$的余数相等，则称$a,b$模$m$同余，记作$a\\equiv b(\\mod m)$。</p>\n<p>一个在$[0,m-1]$里面的数$a$，它所属的集合$\\{a+km\\}$里面的所有数和$m$同余，则称这个集合为一个模$m$的同余类。</p>\n<p>$1$~$m$中和$m$互质的数代表的同余类共有$\\varphi(m)$个，它们构成$m$的简化剩余系。</p>\n<span id=\"more\"></span>\n<p>结论1：如果$a,b$都属于$m$的简化剩余系，则$a\\cdot b \\mod m$也属于$m$的简化剩余系。</p>\n<p>证明：显然，$a,b$都和$m$互质，则$a\\cdot b \\mod m$一定和$m$互质，必然属于$m$的简化剩余系。</p>\n<h2 id=\"运算\"><a href=\"#运算\" class=\"headerlink\" title=\"运算\"></a>运算</h2><p>模$n$意义下的运算</p>\n<ul>\n<li><p>加法</p>\n<ul>\n<li>$a+b = (a\\mod n+b\\mod n)\\mod n$</li>\n<li>$a\\equiv -b(\\mod n) \\iff a+b \\equiv 0(\\mod n)$（等式两边同时加上一个整数，模意义下等式仍然成立）</li>\n</ul>\n</li>\n<li><p>减法</p>\n<ul>\n<li>$a-b = (a\\mod n-b\\mod n) \\mod n$</li>\n<li>$a\\equiv b(\\mod n) \\iff a-b\\equiv 0(\\mod n)$（等式两边同时减去一个整数，模意义下等式仍然成立）</li>\n</ul>\n</li>\n<li><p>乘法</p>\n<ul>\n<li>$a\\cdot b = (a \\mod n\\cdot b\\mod n)\\mod n$</li>\n<li>$a\\equiv b(\\mod n) \\iff a\\cdot k\\equiv b\\cdot k(\\mod n)$（等式两边同时乘上一个整数，模意义下等式仍然成立）</li>\n</ul>\n</li>\n<li><p>除法</p>\n<ul>\n<li><p>这个后面再说</p>\n</li>\n<li><p>$a\\cdot k\\equiv b\\cdot k(\\mod n) \\iff a\\equiv b(\\mod \\frac{n}{gcd(n,k)})$</p>\n<ul>\n<li><p>证明：$a\\cdot k\\equiv b\\cdot k(\\mod n) \\iff (a-b)\\cdot k\\equiv 0(\\mod n)$。</p>\n<p>感性理解一下，$k$尽全力只能帮助$a-b$拿下$gcd(n,k)$，剩下的$\\frac{n}{gcd(n,k)}$是$a-b$必须要有的，所以$a-b\\equiv 0(\\mod \\frac{n}{gcd(n,k)})$。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>乘方</p>\n<ul>\n<li>$a\\equiv b \\iff a^k\\equiv b^k(\\mod n)$</li>\n<li>证明：设$a = k_1n+r,b = k_2n+r$，则$a^k = k_1\\cdot X+r^k,b^k = k_2\\cdot Y+r^k$，所以原式等价于$r^k\\equiv r^k$，显然成立。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"定理\"><a href=\"#定理\" class=\"headerlink\" title=\"定理\"></a>定理</h2><p><strong>费马小定理：若$p$是质数，则对于任意正整数$a$，有$a^p\\equiv a(\\mod p)$。</strong></p>\n<p><strong>欧拉定理：若正整数$a,n$互质，则$a^{\\varphi(n)}\\equiv 1(\\mod n)$。</strong></p>\n<p>证明：对于$n$的所有互质的数，我们将其从小到达排列为$a_1,a_2,\\cdots,a_{\\varphi(n)}$。</p>\n<p>之后，我们把所有这些数都乘上$a$，得到$aa_1,aa_2,\\cdots,aa_{\\varphi(n)}$，又因为$a,n$互质，所以得到的数都和$n$互质。</p>\n<p>我们再证明这些数组成的集合正好是$n$的简化剩余系：</p>\n<p>如果对于两个不同的$a_i,a_j$来说，$aa_i\\equiv aa_j(\\mod n)$，那么根据上面的运算性质，要么$a\\mid n$，要么$a_i\\equiv a_j(\\mod n)$，然而根据$a,n$互质，第一个不成立，根据我们假设的$a_i\\neq a_j$，第二个也不成立，所以这个集合正好构成$n$的简化剩余系。</p>\n<p>由此，$aa_1\\cdot aa_2\\cdots aa_{\\varphi(n)}\\equiv a_1\\cdot a_2 \\cdots a_{\\varphi(n)}(\\mod n)$，所以$a^{\\varphi(n)}\\equiv 1(\\mod n)$。</p>\n<p>当$n$为质数时，$a^{\\varphi(n)}\\equiv1(\\mod n) = a^{n-1}\\equiv 1(\\mod n) = a^n\\equiv a(\\mod n)$。</p>\n<p>由此，费马小定理成立。</p>\n<h2 id=\"欧拉定理的推论\"><a href=\"#欧拉定理的推论\" class=\"headerlink\" title=\"欧拉定理的推论\"></a>欧拉定理的推论</h2><ol>\n<li><p><strong>若$a,n$互质，则对于任意正整数$b$，有$a^b\\equiv a^{b\\mod \\varphi(n)}(\\mod n)$</strong>。</p>\n<p>证明：</p>\n<p>设$b=k\\cdot \\varphi(n)+r$，则$a^b =  a^{k\\cdot \\varphi(n)+r} = a^{\\varphi(n)^k}\\cdot a^r\\equiv 1^k\\cdot a^r\\equiv a^r$，所以原式仍旧成立。</p>\n</li>\n<li><p><strong>若$a,n$不互质，且对于正整数$b&lt;\\varphi(n)$，有$a^b\\equiv a^b(\\mod n)$</strong>。</p>\n<p>证明：</p>\n<p>显然成立。</p>\n</li>\n<li><p><strong>若$a,n$不互质，且对于正整数$b\\geq \\varphi(n)$，有$a^b\\equiv a^{b\\mod \\varphi(n)+\\varphi(n)}(\\mod n)$</strong>。</p>\n<p>证明：</p>\n<ol>\n<li><p>$a$为质数，且$a\\mid n$。</p>\n<p>设$n=n’a^r$，则$a,n’$一定互质，根据欧拉定理，可得$a^{\\varphi(n’)}\\equiv 1(\\mod n’)$。</p>\n<p>又因为$a^r,n’$互质，所以$\\varphi(n) =\\varphi(n’)\\cdot (a-1)\\cdot a^{r-1}$，即$\\varphi(n’)\\mid \\varphi(n)$。</p>\n<p>所以根据$a^{\\varphi(n’)}\\equiv 1(\\mod n’)$，可以得到$a^{\\varphi(n)}\\equiv 1(\\mod n’)$。</p>\n<p>变换形式，可得$a^{\\varphi(n)} = n’k+1$，即$a^{\\varphi(n)+r} = nk+a^r$。</p>\n<p>所以，$a^{\\varphi(n)+r}\\equiv a^r(\\mod n)$，即$a^{k\\cdot\\varphi(n)+r}\\equiv a^r(\\mod n)$。</p>\n<p>设$b = r+k\\cdot\\varphi(n)+t$，则$a^b = a^{r+k\\cdot\\varphi(n)+t} = a^{r+t}$。</p>\n<p>又因为$t = b-r-k\\cdot\\varphi(n) = (b-r)\\mod \\varphi(n)$，所以$a^b = a^{r+(b-r)\\mod \\varphi(n)}(\\mod n)$。</p>\n</li>\n<li><p>$a$为质数的幂。</p>\n<p>剩下的看不懂了，有兴趣的直接看<a href=\"https://blog.csdn.net/synapse7/article/details/19610361\">三个重要的同余式——威尔逊定理、费马小定理、欧拉定理 + 求幂大法的证明_synapse7的博客</a>。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>总之，这个式子可以降低幂次，使我们能用快速幂之类的东西简化计算。</p>\n<h2 id=\"扩展欧几里得\"><a href=\"#扩展欧几里得\" class=\"headerlink\" title=\"扩展欧几里得\"></a>扩展欧几里得</h2><p>对于任意整数$a,b$，存在一对整数$x,y$，满足$ax+by = gcd(a,b)$。</p>\n<p>在欧几里得算法的最后一步中，$b=0$，我们可以得到一组解：$a\\cdot1+0\\cdot0 = gcd(a,0)$。</p>\n<p>我们往回导一下，在$b&gt;0$时，$gcd(a,b) = gcd(b,a\\mod b)$，假设存在一对整数$x,y$满足$bx+(a\\mod b)y=gcd(b,a \\mod b)$，则$bx+(a-b\\cdot\\lfloor a/b\\rfloor)y=ay+ b(x-\\lfloor a/b\\rfloor y)$，我们只要令$x’=y,y’=x-\\lfloor a/b\\rfloor y$，就可以求出另一组解，由于当$b=0$时是有解的，所以我们归纳一下，可以得到任意时刻都有解。于是对于任意整数$a,b$，都存在一组整数$x,y$，满足$ax+by = gcd(a,b)$。</p>\n<p>当然，这里求出的仅是一组特解，并不能代表所有的解。</p>\n<p>更一般的，对于$ax+by = c$，方程有解当且仅当$gcd(a,b)\\mid c$，且通解可表示为$x=\\frac{c}{gcd(a,b)}x_0+\\frac{kb}{gcd(a,b)},y = \\frac{c}{gcd(a,b)}y_0-\\frac{ka}{gcd(a,b)}$。其中$x_0,y_0$为$ax+by = gcd(a,b)$的一组特解。</p>\n<p>证明：咕了。</p>\n<h2 id=\"乘法逆元\"><a href=\"#乘法逆元\" class=\"headerlink\" title=\"乘法逆元\"></a>乘法逆元</h2><p>我们回到之前对于运算的处理，我们对加减乘和乘方运算都有较好的处理方式，但是除法中很可能会有小数，这时候再模就不知道是什么东西了，为了将结果限制在整数范围内，我们需要一种特殊的处理方式：乘法逆元。</p>\n<p>若整数$b,m$互质，且$b\\mid a$，则存在一个整数$x$，使得$a/b\\equiv ax(\\mod m)$，称$x$为$b$的模$m$乘法逆元，记为$b^{-1}(\\mod m)$。</p>\n<p>因为$a/b\\equiv a\\cdot b^{-1}\\equiv a/b\\cdot b\\cdot b^{-1}(\\mod m)$，所以根据上面的运算规律，我们可以得到$b\\cdot b^{-1}\\equiv 1(\\mod m)$。</p>\n<p>那么，我们就是要找到$b^{-1}$取啥比较合适。</p>\n<h3 id=\"模质数\"><a href=\"#模质数\" class=\"headerlink\" title=\"模质数\"></a>模质数</h3><p>如果$m$是质数，根据费马小定理，$b^m\\equiv b(\\mod m) \\iff b^{m-1}\\equiv 1(\\mod m) \\iff b\\cdot b^{m-2}\\equiv 1(\\mod m)$，所以$b^{-1} = b^{m-2}$是$b$的乘法逆元。</p>\n<h3 id=\"线性求1-n中所有数的逆元\"><a href=\"#线性求1-n中所有数的逆元\" class=\"headerlink\" title=\"线性求1~n中所有数的逆元\"></a>线性求1~n中所有数的逆元</h3><p>还要说明一点，如果要求$1$~$n$中所有数模质数$p$的逆元，是可以线性求出的。</p>\n<p>具体来说，我们设$p=k\\cdot i+r$，其中$0\\leq r&lt;i$。</p>\n<p>于是，$k\\cdot i+r\\equiv 0(\\mod p)$。</p>\n<p>两边同乘$i^{-1}$和$r^{-1}$，得到$k\\cdot r^{-1}+i^{-1}\\equiv 0(\\mod p)$。</p>\n<p>移项，得$i^{-1}\\equiv -k\\cdot r^{-1}(\\mod p)$，也就是说，$i^{-1}\\equiv -\\lfloor p/i\\rfloor\\cdot(p\\mod i)^{-1}(\\mod p)$，我们用的都是之前已经求出的逆元，可以线性求出所有的逆元。</p>\n<h3 id=\"线性求任意n个数的逆元\"><a href=\"#线性求任意n个数的逆元\" class=\"headerlink\" title=\"线性求任意n个数的逆元\"></a>线性求任意n个数的逆元</h3><p>我们首先求出$n$个数的前缀积，记为$s_i$，之后求出$s_n$的逆元$sv_n$。</p>\n<p>$s_n=\\Pi_{i=1}^na_i$，于是$sv_n=\\Pi_{i=1}^na_i^{-1}$。</p>\n<p>我们从后往前，每次乘上$a_i$，于是得到$s’_i=\\Pi_{j=1}^ia_j^{-1}$，那么$a_i^{-1} = s’_i\\cdot s_{i-1}$。</p>\n<p>这样，我们就用$n+\\log m$的时间求出了任意$n$个数的逆元。</p>\n<h3 id=\"b-m互质\"><a href=\"#b-m互质\" class=\"headerlink\" title=\"b,m互质\"></a>b,m互质</h3><p>如果只保证$b,m$互质，我们需要求解同余方程$bx\\equiv 1(\\mod m)$。</p>\n<p>接下来，我们将讨论如何解决这个问题。</p>\n<h2 id=\"线性同余方程\"><a href=\"#线性同余方程\" class=\"headerlink\" title=\"线性同余方程\"></a>线性同余方程</h2><p>形如$ax\\equiv b(\\mod m)$的方程叫做线性同余方程，因为其未知数$x$的指数为1。</p>\n<p>我们将其变形，得$ax-b\\equiv 0(\\mod m)$，即$ax-b=-ym$。</p>\n<p>移项，得$ax+ym=b$，这个东西可以用扩展欧几里得解决。</p>\n<p>我们先求出$ax+ym = gcd(a,m)$的一组解$x,y$，之后乘$b/gcd(a,m)$，就可以求出这个方程的一个特解$x_0$。</p>\n<p>通解是所有模$m/gcd(a,m)$和$x_0$同余的数，形象一点的说，通解是$x_0\\frac{b}{gcd(a,m)}+\\frac{tm}{gcd(a,m)}$，这里的$t$取遍整个整数集合。</p>\n<h2 id=\"中国剩余定理\"><a href=\"#中国剩余定理\" class=\"headerlink\" title=\"中国剩余定理\"></a>中国剩余定理</h2><p>设$m_1,m_2,\\cdots,m_n$是$n$个两两互质的整数，$m=\\Pi_{i=1}^nm_i$，$M_i = m/m_i$，$t_i$是线性同余方程$M_it_i\\equiv 1(\\mod m_i)$的一个解，则对于任意$n$个整数$a_1,a_2\\cdots a_n$，方程组</p>\n<p>$\\left\\{\\begin{aligned}x\\equiv a_1(\\mod m_1)\\\\x\\equiv a_2(\\mod m_2)\\\\\\cdots\\\\x\\equiv a_n(\\mod m_n)\\end{aligned}\\right.$</p>\n<p>有整数解，解为$x=\\sum_{i=1}^na_iM_it_i$。</p>\n<p>证明：</p>\n<p>对于$M_i\\neq m/m_i$，有$m_i\\mid M_i$，所以$a_iM_it_i\\equiv 0(\\mod m_i)$。</p>\n<p>对于$M_i=m/m_i$，有$M_it_i\\equiv 1(\\mod m_i)$，所以$a_iM_it_i\\equiv a_i(\\mod m_i)$。</p>\n<p>所以这是原方程组的一个特解。</p>\n<p>通解就是$x+km$。</p>\n<p>证明：又咕了。</p>\n<h2 id=\"扩展中国剩余定理\"><a href=\"#扩展中国剩余定理\" class=\"headerlink\" title=\"扩展中国剩余定理\"></a>扩展中国剩余定理</h2><p>虽然刚才的解确实非常妙，但是只有在$m_1,m_2\\cdots,m_n$中所有数两两互质才能使用，这在题目中是非常罕见的限制条件，更多的是随便取一些数，让你解这个方程组，这时候我们应该怎么做呢？</p>\n<p>我们考虑用数学归纳法解决。</p>\n<p>显然，只有$x\\equiv a_1(\\mod m_1)$时，我们可以通过线性同余方程求出一个解，或判断其无解。</p>\n<p>假设现在已经求出了前$k-1$个方程的解$x$，设$m = lcm(m_1,m_2\\cdots m_{k-1})$，则$x+im$是前$k-1$个方程的一个通解，现在要求出一个整数$t$，满足$x+tm\\equiv a_k(\\mod m_k)$，即$tm\\equiv a_k-x(\\mod m_k)$，这可以通过找出这个线性同余方程的一个解得到，或判断其无解。</p>\n<h2 id=\"高次同余方程\"><a href=\"#高次同余方程\" class=\"headerlink\" title=\"高次同余方程\"></a>高次同余方程</h2><h3 id=\"BSGS算法\"><a href=\"#BSGS算法\" class=\"headerlink\" title=\"BSGS算法\"></a>BSGS算法</h3><p>在$a,p$互质时，对于形如$a^x\\equiv b(\\mod p)$之类的问题，我们可以使用BSGS求解。</p>\n<p>这个$x$可以看成$it-j$，其中$t = \\lceil \\sqrt{p}\\rceil$，这里的$i\\in [1,t],j\\in[1,t]$，这样可以取到$[0,p-1]$中的任何一个值。</p>\n<p>为什么不需要取更大的值呢？因为$a,p$互质，所以我们可以使用欧拉定理，$a^{x+\\varphi(p)}\\equiv a^x\\cdot a^{\\varphi(p)}\\equiv a^x\\cdot 1\\equiv a^x(\\mod p)$。</p>\n<p>所以，$x$只要在$[0,p-1]$的范围内就行了。</p>\n<p>对这个式子进行变形，$a^{it-j}\\equiv b \\iff a^{it}\\equiv b\\cdot a^j(\\mod p)$。</p>\n<p>我们从小到大枚举$j$，算出$b\\cdot a^j$的所有取值，当取值相等时，我们用较大的$j$更新，这样可以保证我们得到的是最小非负整数解。</p>\n<p>之后，再从小到大枚举$i$，直接求出$a^{it}$的值，查找是否有对应的$j$，使同余后结果相同，有就直接输出答案。</p>\n<p>这个答案为什么最小？我们考虑极端一点的情况，$it-1&lt;(i+1)t-t$，所以就没啥问题了。</p>\n<p>查找相等的取值好像可以用hash做到$O(1)$，但是我只会用$O(\\log n)$的map。也许以后会再更一下。</p>\n<p>这个方程也有可能无解，就是在枚举完所有的可能之后都没有找出解来。</p>\n<p>这个算法的复杂度优化主要在用map将所有$b\\cdot a^j$的值都存起来，这样我们对于每个$i$，就只用花费$O(\\log n)$的时间进行查找了，于是总复杂度就是$O(\\sqrt{p}\\cdot \\log p)$。这种分割$x$的思想是非常具有启发性的。</p>\n<h3 id=\"扩展BSGS\"><a href=\"#扩展BSGS\" class=\"headerlink\" title=\"扩展BSGS\"></a>扩展BSGS</h3><p>如果只有$a^x\\equiv b(\\mod p)$，不保证$b,p$互质，该如何做呢？</p>\n<p>我们取$d = gcd(a,p)$，将整个方程同时除以$d$，得到$\\frac{a}{d}\\cdot a^{x-1}\\equiv \\frac{b}{d}(\\mod \\frac{p}{d})$。</p>\n<p>为什么可以这样除呢？我们假设原来的方程为$a^x+kp=b$，则整体除$d$，得$\\frac{a}{d}\\cdot a^{x-1}+k\\cdot\\frac{p}{d}=\\frac{b}{d}$，这就相当于把模数也一起除$d$。</p>\n<p>现在，$\\frac{a}{d}$和$\\frac{p}{d}$显然是互质的，于是我们可以用乘法逆元把$\\frac{a}{d}$除过去，得到$a^{x-1}\\equiv \\frac{b}{d}\\cdot (\\frac{a}{d})^{-1}(\\mod \\frac{p}{d})$。</p>\n<p>我们一直这样除下去，设$D = \\Pi_{i=1}^kd_i$，直到左边的$a^{x-k}$和$\\frac{p}{D}$互质，这样我们就可以应用上面的BSGS来解决这个问题了。</p>\n<p>BSGS的时间复杂度为$O(\\sqrt{p}\\cdot\\log p)$，每次求gcd的时间复杂度为$O(\\log p)$，总的复杂度大概就是$O(\\sqrt{p}\\cdot \\log p)$。</p>\n<h2 id=\"阶\"><a href=\"#阶\" class=\"headerlink\" title=\"阶\"></a>阶</h2><p>对于两个互质的数$a,m$而言，$a^x\\equiv 1(\\mod m)$，这个$n$取最小时称作$a$模$m$的阶，记作$\\delta_m(a)$。</p>\n<p>由欧拉定理可得，$a^{\\varphi(m)}\\equiv 1(\\mod m)$，所以在$a,m$互质时，$n$一定存在。</p>\n","tags":["Knowledge","数学"]},{"title":"物质的分类","url":"/2022/02/11/%E7%89%A9%E8%B4%A8%E7%9A%84%E5%88%86%E7%B1%BB/","content":"<h2 id=\"物质的分类（-分散系-氧化物分类）\"><a href=\"#物质的分类（-分散系-氧化物分类）\" class=\"headerlink\" title=\"物质的分类（ 分散系 氧化物分类）\"></a>物质的分类（ 分散系 氧化物分类）</h2><span id=\"more\"></span>\n<h3 id=\"制备-Fe-OH-3-胶体的实验\"><a href=\"#制备-Fe-OH-3-胶体的实验\" class=\"headerlink\" title=\"制备$Fe(OH)_3$胶体的实验\"></a>制备$Fe(OH)_3$胶体的实验</h3><p>  $FeCl_3+3H_2O \\frac{\\Delta}{=} Fe(OH)_3（胶体）+3HCl$<br>  （原谅这丑陋的方程式）</p>\n<h5 id=\"要点：\"><a href=\"#要点：\" class=\"headerlink\" title=\"要点：\"></a>要点：</h5><p>  <strong>反应条件</strong>：加热<br>  要在$Fe(OH)_3$后面<strong>加上胶体 </strong><br>  不要和$NaOH$反应去了，这样会直接生成沉淀<br>  要用<strong>煮沸</strong>的<strong>蒸馏水</strong>，而且是将$FeCl_3$加入蒸馏水中，颜色变成<strong>红褐色</strong>时<strong>立即</strong>停止加热<br>  不能用<strong>玻璃棒搅拌</strong>，要<strong>振荡烧杯</strong><br>  淀粉溶液是<strong>胶体</strong>！  </p>\n<h5 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h5><p>  虽然反应是这样进行的，但是如果再加入适量$HCl$，会发生以下反应：$Fe(OH)_3+3HCl = FeCl_3+3H_2O$<br>  我的理解是因为胶体微粒带电，似乎从某种程度上阻止了反应的进行，但是加入$HCl$到一定程度后，两边的电荷逐渐失衡，反应才开始进行，为了电荷的再次平衡   </p>\n<h4 id=\"胶体的性质\"><a href=\"#胶体的性质\" class=\"headerlink\" title=\"胶体的性质\"></a>胶体的性质</h4><ul>\n<li>粒子大小介于$1nm$~$100nm$之间，不能透过半透膜  </li>\n<li>光学性质：丁达尔效应。实际上就是拿个激光笔照射之后有通路，就一定是胶体  </li>\n<li>运动学性质：布朗运动。解释是做无规则运动，好像也是因为这个性质具有介稳性  </li>\n<li>电学性质：电泳现象。通俗点说就是往哪边跑，极性就与哪边相反，异性相吸嘛  <ul>\n<li>应用：工厂静电除尘（尘是胶体）</li>\n<li>注意：胶体是电中性的，只有胶粒才带电</li>\n</ul>\n</li>\n<li>热力学性质：胶体的聚沉。貌似并不知道原理是什么<ul>\n<li>方法1：加入[[电解质]]（之后会讲）</li>\n<li>方法2：加入与胶粒带相反电荷的胶体（见$\\downarrow$的扩展）</li>\n<li>方法3：加热（实验中可能会考加热过度，现象是有红褐色固体生成）</li>\n<li>应用：三角洲形成，明矾净水，盐卤制豆腐</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"扩展：-1\"><a href=\"#扩展：-1\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h5><ol>\n<li>胶体的正负电荷<br>正电荷：金属氢氧化物（$Fe(OH)_3$），金属氧化物（$Fe_2O_3$）<br>负电荷：非金属氧化物（$As_2O_3$），金属硫化物（好像没看见？），但看见了金属（$Au$）  </li>\n<li>不同物态的胶体<br>气溶胶：烟、雾<br>液溶胶：$Fe(OH)_3$胶体、豆浆、淀粉<strong>溶液</strong><br>固溶胶：有色玻璃，烟水晶（?）</li>\n</ol>\n<h4 id=\"氧化物的分类\"><a href=\"#氧化物的分类\" class=\"headerlink\" title=\"氧化物的分类\"></a>氧化物的分类</h4><p>碱性氧化物：能和酸反应生成盐和水的氧化物，如$CuO$<br>酸性氧化物：能和碱反应生成盐和水的氧化物，如$CO_2, SO_3$<br>两性氧化物：酸碱特性皆具备，称为两性氧化物，如$Al_2O_3$<br>不成盐氧化物：两个特性都不具备的氧化物，如$NO,CO$<br><strong>特殊氧化物</strong>：好像只提到了$Fe_3O_4$和$Na_2O_2$这两个  </p>\n<h5 id=\"大体观点：\"><a href=\"#大体观点：\" class=\"headerlink\" title=\"大体观点：\"></a>大体观点：</h5><p><strong>碱性氧化物</strong> <strong>一定</strong>是 <strong>金属氧化物</strong>    <strong>没有反例！ </strong><br><strong>酸性氧化物</strong> 大部分是 <strong>非金属氧化物</strong>    反例：$Mn_2O_7$<br><strong>金属氧化物</strong> 不一定是 <strong>碱性氧化物</strong>    反例：$Mn_2O_7$（这个好像真的很好用），$Al_2O_3$（两性氧化物）<br><strong>非金属氧化物</strong> 不一定是 <strong>酸性氧化物</strong>    反例：$CO$（不成盐氧化物）<br><strong>酸性氧化物</strong> 大多可以和水反应生成相应的酸    反例：$SiO_2$<br><strong>碱性氧化物</strong> 大多不能和水反应生成相应的碱    反例：$Na_2O$，$CaO$  </p>\n<h4 id=\"补充错题：\"><a href=\"#补充错题：\" class=\"headerlink\" title=\"补充错题：\"></a>补充错题：</h4>","tags":["Knowledge","WHK"]},{"title":"糖果传递 题解","url":"/2022/04/12/%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"糖果传递-题解\"><a href=\"#糖果传递-题解\" class=\"headerlink\" title=\"糖果传递 题解\"></a>糖果传递 题解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>一切都是推式子。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>每个人都要补前面人的差值，补自己的差值。</p>\n<p>设$x_i$表示第$i$个人从第$i+1$个人那里拿了多少张牌，为正则是拿，为负则是送。</p>\n<p>于是，设第$i$个人的牌数是$s_i$，则一定满足式子$s_i+x_i-x_{i-1} = avg$。</p>\n<span id=\"more\"></span>\n<p>把所有人的式子都列出来：</p>\n<p>$s_1+x_1-x_n = avg\\\\s_2+x_2-x_1 = avg\\\\\\cdots\\\\s_n+x_n-x_{n-1} = avg$</p>\n<p>我们花费的代价是$|x_1|+|x_2|+\\cdots+|x_n|$，现在要使这个东西最小。</p>\n<p>这个东西直接凑不太好凑，我们考虑把它们都化为$x_1$的形式。</p>\n<p>$x_2 = avg-s_2+x_1\\\\x_3 = avg-s_3+avg-s_2+x_1 = 2avg-s_2-s_3+x_1\\\\x_4 = avg-s_4+2avg-s_2-s_3+x_1 = 3avg-s_2-s_3-s_4+x_1$</p>\n<p>于是，这个式子就变成了$|x_1|+|x_1+avg-s_2|+|x_1+2avg-s_2-s_3|+\\cdots +|x_1+(n-1)avg-(s_2+s_3+\\cdots +s_n)|$。</p>\n<p>显然，每个绝对值后面的数都是定值，这个可以直接预处理出来，我们不妨设每个绝对值后面的数为$f_i$。</p>\n<p>则，式子可以化为$|x_1+f_1|+|x_1+f_2|+\\cdots+|x_1+f_n|$。</p>\n<p>当$n$为偶数时，根据初中学习的绝对值相关知识，画个数轴出来，可以发现，当$x_1$在排序后的$f$数组中的$-f_{n/2}$和$-f_{n/2+1}$之间时，值最小。</p>\n<p>当$n$为奇数时，$x_1$在$-f_{(n+1)/2}$时，值最小。</p>\n<p>于是，我们先把$f_i$的值都算出来，再取$-f_{(n+1)/2}$，就是$x_1$的取值，把结果算一下就行了。</p>\n<h2 id=\"Code-：\"><a href=\"#Code-：\" class=\"headerlink\" title=\"$Code$：\"></a>$Code$：</h2><p>注意long long</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[N],f[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> avg = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tavg+=a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tavg/=n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tsum+=a[i];</span><br><span class=\"line\">\t\tf[i] = avg*(i<span class=\"number\">-1</span>)-sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(f+<span class=\"number\">1</span>,f+<span class=\"number\">1</span>+n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = f[(n+<span class=\"number\">1</span>)/<span class=\"number\">2</span>],ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans+=<span class=\"built_in\">abs</span>(x-f[i]);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","贪心"]},{"title":"浅谈随机数据生成与对拍","url":"/2021/10/12/%E6%B5%85%E8%B0%88%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E4%B8%8E%E5%AF%B9%E6%8B%8D/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近写了一个对拍器，自认为对于对拍有一定见解，但今天$cjf$说如果用$srand(time(0))$，在卑微的Windows系统下一秒钟实际上只对了一组数据，因为$time(0)$在一秒钟内不会变化，写了个程序<br>试了一下，确实如此<br><span id=\"more\"></span><br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;test.in&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,stdout);</span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">0</span>,las = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (a==las)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">\t\ta = <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!las) las = a;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>cnt统计的是和最先一次rand出来的数相同的数的个数</p>\n<p>cnt大概有1e7-2e7，可见数据生成器生成数据的不随机性（除非你的程序用时太久，不能在1s内跑完生成的数据）</p>\n<p><strong>显然，这会对对拍的效率产生严重影响，那么应该如何生成完全随机的数据呢？</strong>  </p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>先用$srand$生成10个左右的随机数，然后就可以得到10个随机种子，再用它们生成随机数，同时运行程序，就可以得到真正的随机数了。</p>\n<p>但这样有一个问题：生成的随机数都是5位数，所以在对拍几万个数据后，种子就是重复的了，那样就没有意义了，所以考虑生成更大的种子。</p>\n<p>在这里给出一种方法：用两个$for$把种子乘起来当作种子，这样种子大概率就不同了。</p>\n<p>具体传种子的方法读者可以自己实现，在这里给出一种方式：$freopen$<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sed;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;seed.in&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">    cin&gt;&gt;sed;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>((<span class=\"type\">unsigned</span>)sed);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    your code here</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>具体生成随机数的方法：<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> rs[<span class=\"number\">15</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">             rs[i] = <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=<span class=\"number\">10</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\">ofstream <span class=\"title\">output</span><span class=\"params\">(<span class=\"string\">&quot;seed.in&quot;</span>)</span></span>;</span><br><span class=\"line\">\t\t\t\toutput&lt;&lt;rs[i]*rs[j]&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;1.exe&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>其实一般只随机10个数也可以，重复周期较长</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p>貌似不生成数据，单独使用$fc$比较文件很慢？（请读者自行测试100000行以上数据，本机测得$fc$比字符比较慢很多）<br><img src=\"https://z3.ax1x.com/2021/10/12/5nzKv8.md.png\" alt=\"实测结果\"></p>\n","tags":["Knowledge","Misc"]},{"title":"约数","url":"/2022/04/02/%E7%BA%A6%E6%95%B0/","content":"<h1 id=\"约数\"><a href=\"#约数\" class=\"headerlink\" title=\"约数\"></a>约数</h1><h2 id=\"算数基本定理的推论\"><a href=\"#算数基本定理的推论\" class=\"headerlink\" title=\"算数基本定理的推论\"></a>算数基本定理的推论</h2><p>一个正整数$n$被唯一分解为$n = p_1^{c_1}p_2^{c_2}\\cdot \\cdot \\cdot p_m^{c_m}$，其中$c_i$都是正整数，$p_i$都是质数，且满足$p_1&lt;p_2&lt;\\cdot \\cdot \\cdot p_m$。</p>\n<p>则$n$的正约数个数为$(c_1+1)(c_2+1)\\cdot\\cdot\\cdot (c_m+1)$，可以看作每个质因子上面的幂都有$c_i+1$种选择。</p>\n<p>$n$的约数和为$(1+p_1+p_1^2+\\cdot\\cdot\\cdot+p_1^{c_1})\\cdot\\cdot\\cdot(1+p_m+p_m^2+\\cdot\\cdot\\cdot+p_m^{c_m})$，这可以看作每一个质因子不同幂次的不同结果相加，再乘起来就涵盖了每一种可能，也就是约数和。</p>\n<span id=\"more\"></span>\n<p>如果学了等比数列的可以快速计算这个式子：</p>\n<p>$1+p_i+p_i^2+\\cdot\\cdot\\cdot+p_i^{c_i} = \\frac{p_i^{c_i+1}-1}{p_i-1}$</p>\n<p>这样只需要$O(\\log n)$的时间就能计算约数和。</p>\n<h2 id=\"求一个数的约数集合\"><a href=\"#求一个数的约数集合\" class=\"headerlink\" title=\"求一个数的约数集合\"></a>求一个数的约数集合</h2><p>我们采用试除法，如前面所说，$n$如果能表示为$n = a*b$，那么$a$和$b$中必然有一个数小于等于$\\sqrt{n}$。</p>\n<p>所以我们只用找到所有小于等于$\\sqrt{n}$的约数，就能得到$n$所有的约数。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> k = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (n%i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (n/i!=i) a.<span class=\"built_in\">push_back</span>(n/i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a.<span class=\"built_in\">begin</span>(),a.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"type\">int</span> sz = a.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;sz;i++) cout&lt;&lt;a[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此算法的时间复杂度为$O(\\sqrt{n})$</p>\n<h2 id=\"求1-n中所有数的约数集合\"><a href=\"#求1-n中所有数的约数集合\" class=\"headerlink\" title=\"求1~n中所有数的约数集合\"></a>求1~n中所有数的约数集合</h2><p>这时，如果使用简单的试除法，就太慢了，时间复杂度为$O(n\\sqrt{n})$。</p>\n<p>我们发现，对于一个数$d$，它的所有倍数都一定有$d$这一个约数，所以我们只要枚举约数，标记这个约数的所有倍数就可以在$O(n\\log n)$的时间内完成。</p>\n<p>推论：1~n中每个数约数的总和为$O(n\\log n)$个，每个数平均有$\\log n$个约数。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; a[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n/i;j++)&#123;</span><br><span class=\"line\">\t\t\ta[i*j].<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(a[i].<span class=\"built_in\">begin</span>(),a[i].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sz = a[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;sz;j++) cout&lt;&lt;a[i][j]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>练习：</p>\n<p><a href=\"https://www.luogu.com.cn/problem/U198025\">U198025</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1463\">P1463</a></p>\n<h2 id=\"最大公约数\"><a href=\"#最大公约数\" class=\"headerlink\" title=\"最大公约数\"></a>最大公约数</h2><p>两个数的约数中，最大的公共的约数叫做最大公约数。</p>\n<p>结论1：$gcd(a,b)\\cdot lcm(a,b) = a\\cdot b$。</p>\n<p>证明：$lcm(a,b)$中，$a,b$不共同拥有的质因数一定存在，$a,b$共同拥有的质因数只要达到最大的一个即可，所以除掉公共的因数，就是$lcm(a,b)$。</p>\n<h3 id=\"求最大公约数\"><a href=\"#求最大公约数\" class=\"headerlink\" title=\"求最大公约数\"></a>求最大公约数</h3><p>$gcd(a,b) = gcd(b,a\\ mod \\ b)$。</p>\n<p>证明：</p>\n<ol>\n<li>$a\\leq b$，$gcd(a,b) = gcd(b,a \\ mod \\ b) = gcd(b,a)$。</li>\n<li>$a&gt;b$，$gcd(a,b) = gcd(b,a \\ mod \\ b) = gcd(b,a-k\\cdot b)$，如果最大公约数$d|a$，$d|b$，那么$d|k\\cdot b$，则$d|a-k\\cdot b$。</li>\n</ol>\n<h2 id=\"互质\"><a href=\"#互质\" class=\"headerlink\" title=\"互质\"></a>互质</h2><p>如果$gcd(a,b) = 1$，那么$a$和$b$就互质。</p>\n<p>对于3个数或更多数的情况，我们把$gcd(a,b,c) = 1$称为$a$、$b$和$c$这3个数互质。</p>\n<h2 id=\"欧拉函数\"><a href=\"#欧拉函数\" class=\"headerlink\" title=\"欧拉函数\"></a>欧拉函数</h2><p>1~n中和n互质的数的个数叫做欧拉函数，记为$\\varphi(n)$</p>\n<p>怎么计算这个东西呢？</p>\n<p>我们考虑哪些数和n互质，所有n的质因子的倍数都和n互质，而且仅有这些数和n互质，所以我们需要把这些数都找出来。</p>\n<p>对于n的一个质因子p，有$n/p$个p的倍数，对于n的另一个质因子q，有$n/q$个q的倍数，把这些都减掉之后，还要加上既是p的倍数，又是q的倍数的数，于是要加上$n/pq$，这样，对于只含有两个质因子p、q的n来说，$\\varphi(n) = n-n/p-n/q+n/pq =(n-n/p)-1/q(n-n/p) = n(1-1/q)(1-1/p)$。</p>\n<p>把这个性质推广到$n = p_1^{c_1}p_2^{c_2}\\cdot \\cdot \\cdot p_m^{c_m}$，可以得到：</p>\n<p>性质1：$\\varphi(n) = n(1-\\frac{1}{p_1})\\cdot\\cdot\\cdot (1-\\frac{1}{p_m})$。</p>\n<p>性质2：当$n&gt;1$时，与n互质的数的和为$n/2\\cdot\\varphi(n)$。</p>\n<p>证明：若c是n的约数，那么n-c也是n的约数，所以与n不互质的数成对出现，和都为n，那么平均值就是$n/2$，所以和n互质的数的平均值也是$n/2$，于是与n互质的数的和就是$n/2\\cdot\\varphi(n)$。</p>\n<p>性质3：若$a,b$互质，那么$\\varphi(ab) = \\varphi(a)\\cdot\\varphi(b)$。</p>\n<p>证明：直接按定义式计算即可。</p>\n<p>虽然这个性质看上去比较显然，但是由此我们可以引出一个重要的东西：积性函数。</p>\n<p>如果当a和b互质时，有$f(ab) = f(a)\\cdot f(b)$，那么称函数$f(x)$为积性函数。</p>\n<p>性质4：对于所有积性函数$f(x)$，$f(n) = \\Pi_{i=1}^mf(p_i^{c_i})$，此处$p_i$和$c_i$是n按照算数基本定理分解出来的质因数和对应的幂。</p>\n<p>证明：因为对于任意两个不相同的$p_i$来说，它们肯定互质，所以可以按照积性函数的性质乘起来，之后就得到了n。</p>\n<p>性质5：若$p|n$且$p^2|n$，则$\\varphi(n) = \\varphi(n/p)\\cdot p$，这个可以由定义得到。</p>\n<p>性质6：若$p|n$且$p^2\\nmid n$，则$\\varphi(n) = \\varphi(n/p)\\cdot p\\cdot \\frac{p-1}{p} = \\varphi(n)\\cdot(p-1)$。</p>\n<p>性质7：$\\sum_{d\\mid n}\\varphi(d) = n$。</p>\n<p>证明：好像还不会证。。。</p>\n","tags":["Knowledge","数学"]},{"title":"网络流初步","url":"/2022/03/07/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E6%AD%A5/","content":"<h2 id=\"求解最大流\"><a href=\"#求解最大流\" class=\"headerlink\" title=\"求解最大流\"></a>求解最大流</h2><h3 id=\"Edmond-Karp算法（EK算法）\"><a href=\"#Edmond-Karp算法（EK算法）\" class=\"headerlink\" title=\"Edmond Karp算法（EK算法）\"></a>Edmond Karp算法（EK算法）</h3><p>这种算法不是很常用，但是比较好理解，没有什么分层图之类的优化技巧，可以直接感性理解求解网络流问题的基本思想。此算法复杂度为$O(nm^2)$，虽说很多时候卡不满，但是和SPFA一样，<strong>有被不经意间（刻意）卡掉的风险</strong>。</p>\n<span id=\"more\"></span>\n<p>首先，我们要知道什么是一个<strong>网络</strong>。其实是给你一张图，其中有一个<strong>源点</strong>$s$，一个<strong>汇点</strong>$t$，源点负责发放流量，汇点负责收集流量，网络中的边都有<strong>流量限制</strong>，也就是说经过这条边的流量不能超过这个限制。我们要的是到达汇点的流量最大。其中源点供应的流量是无限的。</p>\n<p>遍历整个图，每次尝试寻找一条<strong>增广路</strong>（一条从$s$到$t$的路径，其中所有边的剩余流量都大于$0$），在找不到增广路时就找到了<strong>最大流</strong>。每找到一条增广路，我们就把这条路的所有边的剩余容量减少，表示有流从这里经过。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/flow1.png\" alt=\"\"></p>\n<p>我们先走$4 \\rightarrow 2 \\rightarrow3$，这样有20的流量从$2$到达$3$，我们将$4\\rightarrow2\\rightarrow3$这条增广路的剩余流量修改一下，$4\\rightarrow2$变成$10$，$2\\rightarrow3$变成$0$，这样我们就得到了一个<strong>残量网络</strong>（即已经有部分流量被占用了）。再走$4\\rightarrow3$，$4\\rightarrow3$修改为$0$。走$4\\rightarrow2\\rightarrow1\\rightarrow3$，由于最小的边是$4\\rightarrow2$，所以只有$10$的流量流到$3$。</p>\n<p>于是，我们就得到了这个网络的最大流量：$50$。</p>\n<p>但是，随便找一条增广路就是最优的吗，显然不是：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/1.png\" alt=\"\"></p>\n<p>如上图，每条边的容量都是$1$，那么我们随便选一个增广路：$s\\rightarrow1\\rightarrow2\\rightarrow t$，这样我们就得到了$1$的流量，但是$s\\rightarrow2$和$1\\rightarrow t$都流不了任何东西了。</p>\n<p>换一种选法：$s\\rightarrow1\\rightarrow t$和$s\\rightarrow2\\rightarrow t$，这样我们就可以得到$2$的流量，比之前瞎选的优。</p>\n<p>如果不能瞎选，该如何解决这种问题呢？</p>\n<p>由于网络有很多种，我们显然不能针对每种情况都设计一个算法，使得每次选择的路径都是最优的，更好的方法是不断尝试，逐渐把不优的替换掉，而这种替换需要一个反悔的工具：<strong>反向边</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/2.png\" style=\"zoom:67%;\" /></p>\n<p>我们再次从$s$开始寻找增广路，可以从$s\\rightarrow2\\rightarrow1\\rightarrow t$，这样就可以得到最大流量$2$了。</p>\n<p>但这样为什么是对的呢？</p>\n<p>这一次走了从$2\\rightarrow1$的反向边，可以看作$1$原来流到$2$的流回去了（反向边相当于把流送回去），再流向之后走的$1\\rightarrow t$，而原来流向$2\\rightarrow t$的流量由$s\\rightarrow2$提供，这样就可以得到一条增广路了。当没有增广路时，说明我们找到了最大流（虽然我并不会证明这个的正确性）。</p>\n<p>时间复杂度简易证明：</p>\n<p>假设网络上有$n$个点，$m$条边。</p>\n<p>第一个结论：在EK算法中，$t$和$s$间的最短路长度一定是不降的，因为每次增广一个路径，这个路径按照$BFS$是最短的路径，所以每次必然减少一个最短路径，我们考虑最坏的情况，变成一个二分图之类的东西，最短路的长度都为$3$，这时需要增广$m$次，也就是说最短路的长度不变时，最多增广$m$次。</p>\n<p>第二个结论：每次$BFS$的时间复杂度为$O(m)$。</p>\n<p>第三个结论：每次增广中必然出现一个边，其剩余流量被完全占用，这条边要再有流量，需要反向边被增广，也就是说它再有剩余流量时，肯定是$t$和$s$之间的最短距离增加$2$时，才能被再次增广。由于一共只有$n$个点，最短路的长度最大是$n$，改变次数最多为$n/2$次。</p>\n<p>综合一、三结论，可得增广复杂度最多为$O(nm)$，而每次增广的复杂度最多时$O(m)$，所以EK算法的时间复杂度是$O(nm^2)$。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,tim = <span class=\"number\">1</span>,vis[N],inc[N],pre[N],Max;</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\tq.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\tvis[s] = tim;</span><br><span class=\"line\">\tinc[s] = inf;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; vis[y]!=tim)&#123;</span><br><span class=\"line\">\t\t\t\tinc[y] = <span class=\"built_in\">min</span>(inc[x],edge[i].w);</span><br><span class=\"line\">\t\t\t\tpre[y] = i;</span><br><span class=\"line\">\t\t\t\tvis[y] = tim;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = t,incf = inc[t];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (now!=s)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> i = pre[now];</span><br><span class=\"line\">\t\tedge[i].w-=incf;</span><br><span class=\"line\">\t\tedge[i^<span class=\"number\">1</span>].w+=incf;</span><br><span class=\"line\">\t\tnow = edge[i^<span class=\"number\">1</span>].to;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tMax+=incf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,w;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,w);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">\t\ttim++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;Max&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"Dinic算法\"><a href=\"#Dinic算法\" class=\"headerlink\" title=\"Dinic算法\"></a>Dinic算法</h3><p>主要思想：</p>\n<p>先做一次BFS将图按到$s$的最短路长度分层，之后做一次DFS（每次增广时可以多路增广），每次只向最短路长度比它大$1$的点输出流量，这样找下去，直到$t$到$s$没有路径，说明没有增广路了，也就是找到了最大流。</p>\n<p>时间复杂度证明：</p>\n<p>第一个结论：每次增广，必然把所有能够增广的都增广了，也就是说$t$到$s$的最短路的长度至少增加$1$，最多增加$n$次</p>\n<p>第二个结论：每次$BFS$，时间复杂度为$O(m)$，每次$DFS$，我们都要维护一个当前弧，也就是说当前弧最多变化$nm$次，于是单次增广的时间复杂度最大为$O(nm)$</p>\n<p>综合一、二结论，Dinic算法的时间复杂度最大为$O(n^2m)$</p>\n<p>也就是说，它适合处理稠密图，但在$n$是$1e3$级别，$m$是$1e5$级别，Dinic算法可能无法在给定时间内处理所有情况，这时就需要用到HLPP了。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,d[N],now[N];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> ans;</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(d,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(d));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\td[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tnow[s] = head[s];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !d[y])&#123;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t\t\td[y] = d[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tnow[y] = head[y];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> flow)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v,use,res = flow,i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=now[u];i &amp;&amp; res;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\tnow[u] = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; d[v] == d[u]+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tuse = <span class=\"built_in\">dfs</span>(v,<span class=\"built_in\">min</span>(edge[i].w,res));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!use) d[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tedge[i].w-=use;</span><br><span class=\"line\">\t\t\tedge[i^<span class=\"number\">1</span>].w+=use;</span><br><span class=\"line\">\t\t\tres-=use;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> flow-res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,w;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,w);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flow;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tflow = <span class=\"built_in\">dfs</span>(s,inf);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!flow) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tans+=flow;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","网络流"]},{"title":"背包问题浅析","url":"/2022/02/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/","content":"<h2 id=\"最基础的背包——01背包\"><a href=\"#最基础的背包——01背包\" class=\"headerlink\" title=\"最基础的背包——01背包\"></a>最基础的背包——01背包</h2><p>问题：</p>\n<p>给定一个容量为$w$的背包，有$n$件物品，每件物品都有一个价值$v$和一个体积$c$，问背包能装下的物品的最大价值和</p>\n<p>思路：</p>\n<p>每件物品都有选或不选(0或1)两种状态，考虑用此作为$dp$的一个维度，对于特定容量的价值，是从之前的容量的价值递推出来的，故可以用此作为$dp$的第二个维度，于是就有了$dp$数组$f[i][j]$表示考虑了前$i$个物品，容量为$j$时的最大价值</p>\n<p>如何转移呢？</p>\n<span id=\"more\"></span>\n<p>对$f$数组的修改必然涉及到一个变量：价值$v$，所以需要$v$参与$dp$的转移方程，稍加考虑即可推出一个简明的方程：</p>\n<p>$f[i][j] = max(f[i-1][j],f[i-1][j-c[i]]+v[i])$</p>\n<p>$max$的第一项表示不选择这个物品，直接使用$i-1$个物品的最大价值；第二项表示选择这个物品，所获得的价值是不放这个物品的背包的最大价值加上这个物品的价值</p>\n<p>可以发现，这个方程只和第$i$项和第$i-1$项有关，所以可以使用滚动数组做空间优化，即$f[j] = max(f[j],f[j-c[i]]+v[i])$</p>\n<p>但是，需要注意此处可能对$f[j]$进行修改，但是我们需要用的是修改之前的值，所以需要倒序修改$f[j]$，防止$f[j-c[i]]$变成了现在的价值，而不是在放入$i-1$个物品的价值</p>\n<p>时间复杂度：$O(nw)$</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1048\">P1048 采药</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> w,n,v[<span class=\"number\">105</span>],c[<span class=\"number\">105</span>],f[<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;w&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;c[i]&gt;&gt;v[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=w;j&gt;=c[i];j--) f[j] = <span class=\"built_in\">max</span>(f[j],f[j-c[i]]+v[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[w]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"01背包的变形——完全背包\"><a href=\"#01背包的变形——完全背包\" class=\"headerlink\" title=\"01背包的变形——完全背包\"></a>01背包的变形——完全背包</h2><p>问题：</p>\n<p>给定一个容量为$w$的背包，有$n$<strong>种</strong>物品，每<strong>种</strong>物品都有一个价值$v$和一个体积$c$，<strong>且数量无限</strong>，问背包能装下的物品的最大价值和</p>\n<p>思路：</p>\n<p>还是考虑原来的$dp$方程：</p>\n<p>$f[j] = max(f[j],f[j-c[i]]+v[i])$</p>\n<p>把修改顺序变为正序修改，思考一下$f[j]$的意义</p>\n<p>当$j’ = j+c[i]$时，$f[j’] = f[j]+v[i]$，此时的$f[j]$表示的是考虑<strong>前$i$个</strong>物品的最大值，显然当前物品放入的情况也被考虑进去了，所以此时正序递推正好满足题目要求</p>\n<p>时间复杂度：$O(nw)$</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1616\">P1616 疯狂的采药</a></p>\n<p><strong>注意：</strong></p>\n<p>1.数据范围更改了</p>\n<p>2.由于$w$可能到$1e7$，而且每种物品的价值可能到$1e4$，如果一件物品，它的价值是$1e4$，体积是$1$，那么结果可能会到$1e11$，需要开$long\\ long$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> w,n,v[<span class=\"number\">10005</span>],c[<span class=\"number\">10005</span>];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> f[<span class=\"number\">10000005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;w&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;c[i]&gt;&gt;v[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=c[i];j&lt;=w;j++) f[j] = <span class=\"built_in\">max</span>(f[j],f[j-c[i]]+v[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[w]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"优化后的01背包——多重背包\"><a href=\"#优化后的01背包——多重背包\" class=\"headerlink\" title=\"优化后的01背包——多重背包\"></a>优化后的01背包——多重背包</h2><p>问题：</p>\n<p>给定一个容量为$w$的背包，有$n$种物品，每种物品都有一个价值$v$和一个体积$c$，<strong>且数量为$m$个</strong>，问背包能装下的物品的最大价值和</p>\n<p>因为每种物品数量有限，所以无法用完全背包求解（可能会使用多于$m$个物品），考虑将其转化为01背包</p>\n<p>最朴素的想法是把每种物品拆成$m$个单独的物品，把所有的物品都单独拿出来，这样就变成了01背包问题</p>\n<p>但是，这样做的复杂度是$O(nmw)$的，在$n \\geq 1000$时就跑不过了，所以要考虑优化</p>\n<p>由于二进制的很多特殊性质，以及对$log$的谜之追求，出现了一种优化方法：二进制拆分</p>\n<p><del>众所周知，任何一个数都可以被表示为二进制形式</del></p>\n<p>例如：$ 42 = (101010)_2$</p>\n<p>所以，我们把这$m$个物品拆成一堆二进制，例如上面的$42$可以拆成$(1)_2=1$,$(10)_2=2$,$(100)_2=4$,$(1000)_2=8$,$(10000)_2=16$,最后剩下来一个$11$。</p>\n<p>不难看出，前面$5$个二进制可以组成$0 \\sim 31$中的任何一个数，而其中的$32 \\sim 42$中的所有数都可以由$21 \\sim 31$加上$11$得到，所以$0 \\sim 42$中的所有数都可以由这些拆出来的数组合得到</p>\n<p>这样，我们可以把每个背包拆成这些物品，之后当作01背包求解，于是复杂度就降低到了$O(n \\log mw)$</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P6567\">P6567 买表</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">4e2</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,k[N],a[N],t,f[<span class=\"number\">500010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;k[i]&gt;&gt;a[i];</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> bas = k[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">30</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[i]&lt;(<span class=\"number\">1</span>&lt;&lt;j)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">500005</span>;p&gt;=bas;p--) <span class=\"keyword\">if</span> (f[p-bas]) f[p] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tbas&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\ta[i]-=(<span class=\"number\">1</span>&lt;&lt;j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[i])&#123;</span><br><span class=\"line\">\t\t\tbas = a[i]*k[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">500005</span>;j&gt;=bas;j--) <span class=\"keyword\">if</span> (f[j-bas]) f[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;t;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (f[t]) cout&lt;&lt;<span class=\"string\">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"融合的01背包——分组背包\"><a href=\"#融合的01背包——分组背包\" class=\"headerlink\" title=\"融合的01背包——分组背包\"></a>融合的01背包——分组背包</h2><p>问题：</p>\n<p>给你$n$个物品，每个物品属于一个组，同一组中只能选择一个物品，问容量为$m$的背包的最大价值</p>\n<p>思路：</p>\n<p>同一组中的所有物品都只能选一次，我们通过01背包来限制选择的次数</p>\n<p>同一组中的所有物品只能选一个，我们通过同一价值来避免一个组中选择多个物品</p>\n<p>时间复杂度：$O(nm)$</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1757\">P1757 通天之分组背包</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,f[N];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; v[N],w[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\tw[z].<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">\t\tv[z].<span class=\"built_in\">push_back</span>(y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sz = w[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=m;j&gt;=<span class=\"number\">0</span>;j--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;sz;p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (j&gt;=w[i][p])&#123;</span><br><span class=\"line\">\t\t\t\t\tf[j] = <span class=\"built_in\">max</span>(f[j],f[j-w[i][p]]+v[i][p]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","DP"]},{"title":"莫队算法初步","url":"/2022/02/09/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/","content":"<h2 id=\"莫队的基本思想\"><a href=\"#莫队的基本思想\" class=\"headerlink\" title=\"莫队的基本思想\"></a>莫队的基本思想</h2><p>简单的莫队是针对这样一种题目：给定很多离线的询问，没有修改，而且数据范围根号算法能过。</p>\n<p>一般的算法都是对单次查询过程进行优化，但莫队对询问进行了优化：</p>\n<span id=\"more\"></span>\n<p>把询问可能出现的区间分成$\\sqrt n$个块，再将询问排序，具体规则是先对左端点所在的块排序，如果左端点在同一块中，就对右端点升序排序。</p>\n<p>这样，我们把排序好的询问一个个计算，定义$L$为当前左端点，$R$为当前右端点，处理每个询问时把左端点和右端点都移动到当前询问的左、右端点处，移动时用$O(1)$或接近的时间复杂度维护$L$和$R$之间的答案，移动好时，这个询问对应的答案就成了$L$和$R$之间的答案。</p>\n<p>但是莫队为什么快呢？因为对于每个块中的询问，左端点都是在这个块中活动$q$次询问可能会卡成$q \\times \\sqrt n$，假设每个询问都倍卡，左端点移动的复杂度最大就是$O(q \\times \\sqrt n)$。再看右端点，如果每个块中右端点都从这个块的起点移动到了最后一个块的终点，右端点移动的复杂度最大就是$O(n \\times \\sqrt n)$。如果$L$和$R$移动的代价为$w$，总共的复杂度最大就是$O(w \\times (n+q) \\times \\sqrt n)$。</p>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><p><a href=\"https://www.luogu.com.cn/problem/P2709\">P2709 小B的询问</a></p>\n<p><a href=\"http://zhengruioi.com/contest/966/problem/1992\">ZROI 奇数</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/SP3267\">SP3267 DQUERY</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF86D\">CF86D Powerful array</a></p>\n<p>To be added.</p>\n<h2 id=\"带修莫队\"><a href=\"#带修莫队\" class=\"headerlink\" title=\"带修莫队\"></a>带修莫队</h2>","tags":["Knowledge","分块"]},{"title":"自建题目目录与解答","url":"/2022/01/15/%E8%87%AA%E5%BB%BA%E9%A2%98%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%8E%E8%A7%A3%E7%AD%94/","content":"<h2 id=\"Tri\"><a href=\"#Tri\" class=\"headerlink\" title=\"Tri\"></a><a href=\"https://www.luogu.com.cn/problem/U198025\">Tri</a></h2><p>首先考虑最暴力的做法，只用把所有的三角形数都枚举一遍，再看看因数数量即可，但是，假设判断了$q$个三角形数，其中每个数为$m$，如果$\\sqrt m$判断因数是否符合条件，会让总复杂度达到$q \\sqrt m$级别的，这显然是无法接受的</p>\n<p>于是想到一个定理：</p>\n<p>如果一个数$p$能够被表示为$p = {a_1}^{k1}+{a_2}^{k2}+…+{a_n}^{k_n}$，那么$p$的因数个数即为$(k_1+1)<em>(k_2+1)</em>…*(k_n+1)$，这代表我们只需要知道一个数的所有质因数，就可以知道它的约数个数，于是总时间复杂度就被降低到了$O(q\\log m)$级别的，有了很可观的改善</p>\n<span id=\"more\"></span>\n<p>$Sample \\ Code:$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e6</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">1e6</span>,k,vis[N*<span class=\"number\">2</span>],pri[N],tot;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sum;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&gt;N || vis[i]&lt;pri[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">1</span>,coun;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot &amp;&amp; x;i++)&#123;</span><br><span class=\"line\">\t\tcoun = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%pri[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcoun++;</span><br><span class=\"line\">\t\t\tx/=pri[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt*=coun;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cnt&gt;k) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tsum+=i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">chk</span>(sum)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;sum&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但是对于$n\\geq 1200$，这种算法也无法在$1.5s$的时限内跑完，所以还需要优化</p>\n<p>如何优化呢？</p>\n<p>因为三角形数是形为$p*(p+1)/2$的数，所以这个$p$必然是根号级别的，可以从这里下手</p>\n<p>而且易证$p$和$p+1$是互质的，其中包含的质因数必然完全不同，所以三角形数的因数可以由$p$的因数和$p+1$的因数相乘得到</p>\n<p>可以先把一定范围内的数的因数预处理出来，之后判断时直接调用即可</p>\n<p>这里采用了与上一份代码类似的因数个数计算方法</p>\n<p>$Sample \\ Code:$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1.5e5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">1e5</span>,k,vis[N*<span class=\"number\">2</span>],pri[N],tot,v[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&gt;N || vis[i]&lt;pri[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">1</span>,coun;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\tcoun = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%pri[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcoun++;</span><br><span class=\"line\">\t\t\tx/=pri[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt*=coun;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++) v[i] = <span class=\"built_in\">get</span>(i);</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i%<span class=\"number\">2</span>) ans = v[i]*v[(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = v[i/<span class=\"number\">2</span>]*v[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans&gt;k)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">1ll</span>*i*(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;Set n to a bigger value&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但是，对于更大的$n$，这种算法却出奇的慢，原因就在于$get$函数中大量使用取模和除法操作，而且判断了很多不能整除的质数，最后可能还没有最简单的加法来得快</p>\n<p>而且一个一个累加，虽然看上去很慢，但是每一个因数都累加到了，绝无重复操作和无用操作，极大的提高了算法的效率</p>\n<p>这里采用尝试法，把所有因数都试出来，虽然看上去接近于$O(n^2)$，但是由于每个数的平均质因数在$log$级别，所以其实是接近$O(n*\\log n)$再带一个大常数的（前$1e7$个数的因数计算花费$2s$）</p>\n<p>$Sample \\ Code:$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2.8e6</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">2.5e6</span>,k,v[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i;j&lt;=N;j+=i) v[j]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&amp;<span class=\"number\">1</span>) ans = v[i]*v[(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = v[i/<span class=\"number\">2</span>]*v[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans&gt;k)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">1ll</span>*i*(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;Set n to a bigger value&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>于是，这个简短的代码就是这道题目前的最优解了，题解愉快的结束了！</p>\n<p>为了防止不必要的卡常，已把本题时限开到$2s$，默认开启$O2$优化，即使你的$N$设置的不是那么微妙，也是可以轻松通过的</p>\n","tags":["Knowledge","Misc"]},{"title":"质数","url":"/2022/04/01/%E8%B4%A8%E6%95%B0/","content":"<h1 id=\"质数\"><a href=\"#质数\" class=\"headerlink\" title=\"质数\"></a>质数</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>每个所有因数只有自己和1的数叫做<strong>质数</strong>，而其他不符合这个条件的数叫做<strong>合数</strong>。</p>\n<h2 id=\"筛出质数\"><a href=\"#筛出质数\" class=\"headerlink\" title=\"筛出质数\"></a>筛出质数</h2><ul>\n<li>暴力筛法<ul>\n<li>每次取出所有小于它的不是1的数，判断是否为它的因数，如果全都不是，那么这个数就是质数。</li>\n<li>时间复杂度$O(n)$。</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n<ul>\n<li>优化过的暴力筛法<ul>\n<li>每次取出所有小于等于根号它的数，判断是否为它的因数，如果全都不是，那么这个数就是质数。</li>\n<li>正确性：每个合数必然有一个小于等于根号它的因数，可以用反证法证明。</li>\n<li>时间复杂度$O(\\sqrt{n})$</li>\n</ul>\n</li>\n<li>埃氏筛<ul>\n<li>每一个是质数的数都标记它的倍数为合数，所有没有被标记的就是质数。</li>\n<li>正确性：每个合数必然有至少一个质因子，而每个质数的质因子只有它本身。</li>\n<li>时间复杂度$O(n\\log \\log n)$。（反正接近线性，应该也没人会特意卡这个）</li>\n</ul>\n</li>\n<li>欧式筛<ul>\n<li>我们模拟一下，可以发现埃氏筛中，有些数会被筛很多次，如12即被2筛过，也被3筛过，这样会浪费大量时间，如果我们规定每个数只能被它的最小质因子筛，那就不会重复筛一个数了。</li>\n<li>正确性：一个数的质因子之间有大小关系，我们只要让这个数被最小的质因子筛，顺序就是唯一的。</li>\n<li>时间复杂度$O(n)$。比较推荐使用这种筛法，因为它还可以筛一些积性函数。</li>\n</ul>\n</li>\n</ul>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P3383\">P3383</a></p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e8</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,vis[N],pri[N],tot,lim;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123; <span class=\"comment\">//是质数 </span></span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (pri[j]&gt;vis[i] || <span class=\"number\">1ll</span>*pri[j]*i&gt;lim) <span class=\"keyword\">break</span>; <span class=\"comment\">//只能由最小的因数筛掉 </span></span><br><span class=\"line\">\t\t\tvis[pri[j]*i] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;lim&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\tcout&lt;&lt;pri[x]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"质因数分解\"><a href=\"#质因数分解\" class=\"headerlink\" title=\"质因数分解\"></a>质因数分解</h2><p>从2~$\\sqrt{n}$里面枚举因数，一直除，直到这个数不含有此因数为止。</p>\n<p>有没有可能除了一个合数呢？不可能。</p>\n<p>因为每个合数必然由比它小的质数组成，而我们把所有组成它的质数都除掉了，所以不可能出现合数。</p>\n<p>时间复杂度为$O(\\sqrt{n})$，你大可无视里面不断除的过程，这个过程在long long范围内也不会超过64次。</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P2043\">P2043</a></p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,cnt[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">work</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> k = <span class=\"built_in\">sqrt</span>(x);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tx/=i;</span><br><span class=\"line\">\t\t\tcnt[i]++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&gt;<span class=\"number\">1</span>) cnt[x]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++) <span class=\"built_in\">work</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">if</span> (cnt[i]) cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当$n$更大时，可以配合埃氏筛，先把所有质数筛出来，1~$n$中是质数和质数的任意次方的倍数的数都对质因子有贡献。时间复杂度为$O(n\\log n)$。（虽然埃氏筛要带两$\\log$，但是这里就忽略不计了，你也可以用线性筛实现）</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,cnt[N],vis[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> las = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n/i;j++)&#123;</span><br><span class=\"line\">\t\t\t\tvis[i*j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (j/las == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tcnt[i]+=<span class=\"number\">1ll</span>*n/j/i;</span><br><span class=\"line\">\t\t\t\t\tlas*=i;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">if</span> (cnt[i]) cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Fun-Facts\"><a href=\"#Fun-Facts\" class=\"headerlink\" title=\"Fun Facts\"></a>Fun Facts</h2><p>1~1000中有168个质数</p>\n<p>1~10000中有1229个质数</p>\n<p>1~100000中有9592个质数</p>\n<p>1~1000000中有78498个质数</p>\n<p>1~$2^{32}$中有203280221个质数</p>\n<p>在$10^{18}$内的最大质数间隙不超过1500</p>\n","tags":["Knowledge","数学"]},{"title":"超能粒子炮 题解","url":"/2022/04/12/%E8%B6%85%E8%83%BD%E7%B2%92%E5%AD%90%E7%82%AE-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"超能粒子炮-题解\"><a href=\"#超能粒子炮-题解\" class=\"headerlink\" title=\"超能粒子炮 题解\"></a>超能粒子炮 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>让你求$(\\sum_{i=0}^kC_n^i \\mod 2333) \\mod 2333$。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>题目中没有明确说明$k$和$n$的关系，如果$k\\geq n$，那么答案就是$2^n\\mod 2333$。</p>\n<p>现在，我们只用考虑$k&lt;n$的情况了。</p>\n<p>$k$最大可以到$1e18$，显然无法直接计算。</p>\n<span id=\"more\"></span>\n<p>但是这个模数较小，于是我们想到了Lucas定理，这样我们所有计算的东西都在2333以内了。</p>\n<p>手动模拟一下，当$i\\geq2333$时，我们使用Lucas定理将式子变成$C_{n\\mod 2333}^{i\\mod 2333}\\cdot C_{n/2333}^{i/2333}$。</p>\n<p>当$2333\\leq i&lt; 4666$时，后面的东西没有变化，前面的就是$2^{n\\mod 2333}-1$。这启示我们这个式子中存在很多一样的东西，我们可以把它们捆绑在一起来降低复杂度。</p>\n<p>前面的东西就是一直循环的，我们现在需要计算后面的东西，而后面的东西也可以用Lucas定理化简：</p>\n<p>$C_{n/2333}^{i/2333} = C_{n/2333\\mod 2333}^{i/2333\\mod 2333}\\cdot C_{n/{2333^2}}^{i/{2333^2}}$。</p>\n<p>前面的东西每2333个数变化一次，后面的又可以重复计算，这不就可以用递归解决吗？</p>\n<p>设$f(x,n)$表示计算$\\sum_{i=0}^x C_{n}^i$。这个式子可以简化成$\\sum_{i=0}^{x/p-1}C_{n/2333}^i\\cdot (\\sum_{j=0}^{2332}C_{n\\mod 2333}^j)+C_{n/2333}^{x/2333}\\cdot \\sum_{i=0}^{x\\mod 2333}C_{n\\mod 2333}^i$。</p>\n<p>前面的一坨显然可以化为$f(k/p-1,n/2333)$，这样就可以递归解决这个问题了。</p>\n<p>先花$2333^2$的时间预处理出组合数和前缀和，之后用$T\\log^2 p$的时间解决问题（有一个$\\log$花在求$C_{n/2333}^{k/2333}$上）。</p>\n<h2 id=\"Code-：\"><a href=\"#Code-：\" class=\"headerlink\" title=\"$Code$：\"></a>$Code$：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">3e3</span>+<span class=\"number\">10</span>,p = <span class=\"number\">2333</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,k,c[N][N],sum[N][N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tc[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;p;j++) sum[<span class=\"number\">0</span>][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;p;i++)&#123;</span><br><span class=\"line\">\t\tc[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=i;j++) c[i][j] = (c[i<span class=\"number\">-1</span>][j]+c[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>])%p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;p;j++) sum[i][j] = sum[i][j<span class=\"number\">-1</span>]+c[i][j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lucas</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!x) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c[y%p][x%p]*<span class=\"built_in\">lucas</span>(x/p,y/p)%p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"built_in\">f</span>(x/p<span class=\"number\">-1</span>,n/p)*sum[n%<span class=\"number\">2333</span>][p<span class=\"number\">-1</span>]%p+<span class=\"built_in\">lucas</span>(x/p,n/p)*sum[n%<span class=\"number\">2333</span>][x%<span class=\"number\">2333</span>]%p)%p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"built_in\">f</span>(k,n)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","数学","组合数学"]},{"title":"题解 UVA323 Jury Compromise","url":"/2022/03/19/%E9%A2%98%E8%A7%A3-UVA323-Jury-Compromise/","content":"<h1 id=\"题解-UVA323-Jury-Compromise\"><a href=\"#题解-UVA323-Jury-Compromise\" class=\"headerlink\" title=\"题解 UVA323 Jury Compromise\"></a>题解 UVA323 Jury Compromise</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>有 $n$ 个人，从中选出$m$个人，每个人有两个得分值$a$和$b$，我们要使$|\\sum^{m}_{i=1}a[i]-\\sum^{m}_{i=1}b[i]|$最小，如果有多种情况满足，选择其中$\\sum^{m}_{i=1}a[i]+\\sum^{m}_{i=1}b[i]$最大的一个。输出最大分值和选择的方案。</p>\n<p>$n\\leq200$</p>\n<p>$m\\leq20$</p>\n<p>$0\\leq a,b\\leq20$</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"O-2-n-算法\"><a href=\"#O-2-n-算法\" class=\"headerlink\" title=\"$O(2^n)$算法\"></a>$O(2^n)$算法</h3><p>第一眼看上去，好像没有任何思路，贪心也不太可行。</p>\n<p>于是考虑暴力。。。</p>\n<p>最暴力的想法是枚举选的人，求出最值。注意到，题目中的分值范围很小，所有人分差最大也只是$400$，所以这$2^{200}$种选择里面，必然有很多种选择，它们的分差是一样的，这就导致了很多重复计算，我们不如枚举分差。</p>\n<p>枚举分差，显然不能直接搜索，而DP可以很好地解决这个问题。</p>\n<h3 id=\"O-nm-2-错误算法\"><a href=\"#O-nm-2-错误算法\" class=\"headerlink\" title=\"$O(nm^2)$错误算法\"></a>$O(nm^2)$错误算法</h3><p>我们初步的想法是设$f[i]$表示分差为$i$时，能够取到的最大分值，每次加入一个人时，我们枚举分差，更新数组即可。</p>\n<p>第$j$个人加入后得到$i$的分差的转移方程：$f[i] = max(f[i],f[i-a[j]+b[j]]+a[j]+b[j])$</p>\n<p>但是，这样做会有后效性，在$j$不变时，我们可能先改动了$f[i-a[j]+b[j]]$的值，导致这里的$f[i-a[j]+b[j]]$不是上一次的值，导致使用多次第$j$个人。</p>\n<p>如果判断$a[j]-b[j]$的正负来确定枚举顺序的确可以解决这个问题，但是这样不好处理之后的输出方案问题，于是我们索性多开一个维度。</p>\n<h3 id=\"O-nm-2-正确算法\"><a href=\"#O-nm-2-正确算法\" class=\"headerlink\" title=\"$O(nm^2)$正确算法\"></a>$O(nm^2)$正确算法</h3><p>设$f[i][j]$表示选择了$i$个人，分差为$j$的方案数。</p>\n<p>第$p$个人加入后得到$j$的分差的转移方程：$f[i][j] = max(f[i][j],f[i-1][j-a[p]+b[p]]+a[p]+b[p])$</p>\n<p>由于下标不能出现负数，我们把所有的分差都加上$400$，这样就没有负数了。</p>\n<p>初始化时，将所有数都设为负无穷，$f[0][400] = 0$，这样可以保证不会从不合法的状态转移。</p>\n<p>输出时我们找到一个和$400$最近的，值最大且大于$0$的就行了。</p>\n<h3 id=\"剩下的输出\"><a href=\"#剩下的输出\" class=\"headerlink\" title=\"剩下的输出\"></a>剩下的输出</h3><p>我们不仅要输出最大值，还要输出选择的方案，我们考虑用一个数组记录转移的情况。</p>\n<p>设$d[i][j][p]$表示前$i$个人中，选择了$j$个人，得到$p$的分差，最后选择的是哪个人。</p>\n<p>转移时先把上一次的照搬过来，对应不选第$i$个人的情况，之后如果这一次能够让$f[j][p]$更大，就更新$d[i][j][p]$。</p>\n<p>输出方案时，我们从$d[n][m][Min]$开始输出，每次$Min-=a[d[n[m][Min]]]-b[d[n][m][Min]]$，$m-=1$，$n$转移到$d[n][m][Min]-1$，一直到$m=0$时结束。</p>\n<p>之后倒序输出就行了</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>前面的DP应该不是很难想到，但是各种细节需要注意：</p>\n<ol>\n<li>数组下标不能为负数，要加一个基准值</li>\n<li>转移时记录转移情况，方便输出方案</li>\n<li>数组要初始化为负无穷，避免从不合法的情况转移</li>\n<li>多测要清空</li>\n</ol>\n<p>本题实际上是将每个人视为一个物品，做了一次01背包。考察了背包和输出方案。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e3</span>+<span class=\"number\">10</span>,M = <span class=\"number\">25</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,f[M][N],p[N],q[N],d[<span class=\"number\">205</span>][M][N],totp,totq,per[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = m,nnow = n;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (now)&#123;</span><br><span class=\"line\">\t\tnnow = d[nnow][now][x];</span><br><span class=\"line\">\t\tper[now] = nnow;</span><br><span class=\"line\">\t\ttotp+=p[nnow];</span><br><span class=\"line\">\t\ttotq+=q[nnow];</span><br><span class=\"line\">\t\tx = x-p[nnow]+q[nnow];</span><br><span class=\"line\">\t\tnnow--;</span><br><span class=\"line\">\t\tnow--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!n &amp;&amp; !m) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\tnow++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">-0x3f</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\t\ttotp = totq = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;p[i]&gt;&gt;q[i];</span><br><span class=\"line\">\t\tf[<span class=\"number\">0</span>][<span class=\"number\">400</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p1=<span class=\"number\">1</span>;p1&lt;=n;p1++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">800</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\td[p1][i][j] = d[p1<span class=\"number\">-1</span>][i][j];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=m;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">800</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ((j-p[p1]+q[p1])&lt;<span class=\"number\">0</span> || (j-p[p1]+q[p1])&gt;<span class=\"number\">800</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (f[i][j]&lt;f[i<span class=\"number\">-1</span>][j-(p[p1]-q[p1])]+p[p1]+q[p1])&#123;</span><br><span class=\"line\">\t\t\t\t\t\tf[i][j] = f[i<span class=\"number\">-1</span>][j-(p[p1]-q[p1])]+p[p1]+q[p1];</span><br><span class=\"line\">\t\t\t\t\t\td[p1][i][j] = p1;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> Min = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">800</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (f[m][i]&gt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(Min<span class=\"number\">-400</span>) == <span class=\"built_in\">abs</span>(i<span class=\"number\">-400</span>))&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (f[m][i]&gt;=f[m][Min]) Min = i;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(Min<span class=\"number\">-400</span>)&gt;<span class=\"built_in\">abs</span>(i<span class=\"number\">-400</span>)) Min = i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">get</span>(Min);</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Jury #&quot;</span>&lt;&lt;now&lt;&lt;endl;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Best jury has value &quot;</span>&lt;&lt;totp&lt;&lt;<span class=\"string\">&quot; for prosecution and value &quot;</span>&lt;&lt;totq&lt;&lt;<span class=\"string\">&quot; for defence:&quot;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(per+<span class=\"number\">1</span>,per+<span class=\"number\">1</span>+m);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cout&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;per[i];</span><br><span class=\"line\">\t\tcout&lt;&lt;endl&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","DP"]}]