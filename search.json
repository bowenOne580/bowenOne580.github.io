[{"title":"test","url":"/2022/01/24/test/","content":"\r\n"},{"title":"卡特兰数","url":"/2021/08/04/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","content":"<h2 id=\"更新记录\">更新记录</h2>\r\n<p>2021.9.22 将部分内容替换成了<span class=\"math inline\">\\(LaTeX\\)</span>符号</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"前置知识\">前置知识</h2>\r\n<h3 id=\"排列数\">排列数</h3>\r\n<p><span class=\"math inline\">\\(A_n^m\\)</span> $ = $ <span class=\"math inline\">\\(\\frac{n!}{(n-m)!}\\)</span> （从<span class=\"math inline\">\\(n\\)</span>个数中选<span class=\"math inline\">\\(m\\)</span>个来排列）<br />\r\n理解为第一位可以有<span class=\"math inline\">\\(n\\)</span>种选择，第二位有<span class=\"math inline\">\\(n-1\\)</span>种，最后一位（即第<span class=\"math inline\">\\(m\\)</span>位）有<span class=\"math inline\">\\(n-m+1\\)</span>种选择 故为<span class=\"math inline\">\\(n\\)</span> <span class=\"math inline\">\\(\\times\\)</span> <span class=\"math inline\">\\((n-1)\\)</span> <span class=\"math inline\">\\(\\times\\)</span> <span class=\"math inline\">\\((n-2)\\)</span> <span class=\"math inline\">\\(\\times\\)</span> … <span class=\"math inline\">\\(\\times\\)</span> $(n-m+1) = $ <span class=\"math inline\">\\(\\frac{n!}{(n-m)!}\\)</span> 全排列为<span class=\"math inline\">\\(n!\\)</span></p>\r\n<h3 id=\"组合数\">组合数</h3>\r\n<p><span class=\"math inline\">\\(C_n^m\\)</span> <span class=\"math inline\">\\(=\\)</span> <span class=\"math inline\">\\(\\frac{n!}{(n-m)!*m!}\\)</span><br />\r\n理解为将<span class=\"math inline\">\\(A_n^m\\)</span>的所有组合方式表示出来，也就是<span class=\"math inline\">\\(m\\)</span>的全排列，为<span class=\"math inline\">\\(m!\\)</span>，常将<span class=\"math inline\">\\(n\\)</span>与<span class=\"math inline\">\\(m\\)</span>写在一个括号里: <span class=\"math inline\">\\(\\binom{m}{n}\\)</span><br />\r\n特别说明：<span class=\"math inline\">\\(A_n^m\\)</span> <span class=\"math inline\">\\(= 0\\)</span>, <span class=\"math inline\">\\(C_n^m\\)</span> <span class=\"math inline\">\\(= 0\\)</span></p>\r\n<p><del>（写了这么多主要是因为看不懂将C写成括号后的表达方式）</del></p>\r\n<h2 id=\"卡特兰数的证明\">卡特兰数的证明</h2>\r\n<p>首先想一个<strong>简单一点</strong>的问题：<br />\r\n你有一个栈，<span class=\"math inline\">\\(n\\)</span>个数，它们每一个都要进行一次入栈和出栈操作，请问共有多少种方式<br />\r\n可以将每次入栈操作看作 <span class=\"math inline\">\\(+1\\)</span>，出栈看作 <span class=\"math inline\">\\(-1\\)</span>，容易想到，合法的方案必须满足所有时刻的<strong>前缀和<span class=\"math inline\">\\(&gt;=0\\)</span></strong><br />\r\n更形象地，将其转移到坐标系上，每次入栈将横坐标 <span class=\"math inline\">\\(+1\\)</span>，每次出栈将纵坐标 <span class=\"math inline\">\\(+1\\)</span>，则所有的合法情况满足<strong>横坐标值<span class=\"math inline\">\\(&gt;=\\)</span>纵坐标值</strong>，所有的不合法情况满足<strong>纵坐标-横坐标<span class=\"math inline\">\\(&gt;=1\\)</span></strong>，则所有不合法情况和函数<span class=\"math inline\">\\(y=x+1\\)</span>必有大于等于1个交点，考虑将其转化为如下形式：</p>\r\n<p><img src=\"https://z3.ax1x.com/2021/09/05/hWt7gx.png\" /></p>\r\n<p>图中实线为不合法操作路径，将其与<span class=\"math inline\">\\(y=x+1\\)</span>相交后的线段关于<span class=\"math inline\">\\(y=x+1\\)</span>对称，得到的最终点是<span class=\"math inline\">\\((n-1,n+1)\\)</span>，由于所有不合法路径必然经过<span class=\"math inline\">\\(y=x+1\\)</span>，所以不合法的路径的情况转化为了从<span class=\"math inline\">\\(0\\)</span>到<span class=\"math inline\">\\((n-1,n+1)\\)</span>的路径总数之和，即<span class=\"math inline\">\\(\\binom{n-1}{2n}\\)</span>或<span class=\"math inline\">\\(\\binom{n+1}{2n}\\)</span>。<br />\r\n合法路径总数即为全部路径<span class=\"math inline\">\\(-\\)</span>不合法路径，即<span class=\"math inline\">\\(\\binom{n}{2n}\\)</span>-<span class=\"math inline\">\\(\\binom{n-1}{2n}\\)</span>或<span class=\"math inline\">\\(\\binom{n}{2n}\\)</span>-<span class=\"math inline\">\\(\\binom{n+1}{2n}\\)</span></p>\r\n<figure>\r\n<img src=\"https://z3.ax1x.com/2021/09/05/hWtHv6.md.png\" alt=\"代码示例\" /><figcaption aria-hidden=\"true\">代码示例</figcaption>\r\n</figure>\r\n","tags":["Knowledge"]},{"title":"Useless Thoughts(遐想)","url":"/2021/08/02/Useless-Thoughts-%E9%81%90%E6%83%B3/","content":"<p><strong>War, war never changes.</strong></p>\r\n<p><strong>But peace, peace changes everything.</strong></p>\r\n<p>犹记得曾经带领举国10个远古军团在《文明Ⅵ》中鲁莽地向自己的友邦瑞士开战，在军队突破阿拉伯的援兵，围在没有任何防御的日内瓦城的所有边界方格上，取得第一次压倒性胜利时的喜悦与狂热，对占领的渴望充斥着我的大脑。</p>\r\n<span id=\"more\"></span>\r\n<p>也记得被阿拉伯疯狂传教、在边境造城挑衅后愤然发起突袭战争，率领接近20个单位的远征大军朝着开罗进发时的意气风发；但谁能想到几回合后我就被困在防御工事内进退不得，只得在阿拉伯的现代化大军到来前从海上逃跑，而又是什么导致了这场战争呢？是对复仇的渴望。</p>\r\n<p>最近了解了伊拉克战争和阿富汗战争，对此更是深有同感。9.11事件成为了阿富汗战争的导火索，控制石油资源的诱惑则导致了伊拉克战争，反观历史上的重大战争，又有哪个不是基于利益和复仇的呢？</p>\r\n<p>但在战争的进程中，有一方的力量却被忽视了——士兵。在游戏中，他们被化为单调的数值；在国家之间的战争中，他们被作为实力较量的筹码；在军官心中，他们被作为任人摆布的棋子。哪位国家元首曾将他们与经济损失、基础建设修复、物资补给一起计算战争的代价？P社玩家之所以成为\"大恶人\"，还不是因为他们无视面板上增加的死亡人数，狂热的发动战争，丝毫没想过那些数字对于他们的家人，挚友意味着什么！战争永远不会是美好的，不会是地图上几条线共同导向的结果，更不会是按动鼠标上的左右键就能完全体会的，其中酿成了多少人间悲剧，造就了多少绝望的结局，我们又如何得知！</p>\r\n<p>但仔细思考一下，各种冲突才是导致战争的最大缘由：边境冲突，宗教冲突，政党冲突（省略）它们也许是人类永远无法避免的命运。但就像线段树一样，作为叶子节点的我们，如果更加平和、宽容待人，能从生活中一个完美的光影，一个样貌奇特的绿树，一个陌生人的有趣谈话中发现美好，不过于厌世，也不盲目服从，那样也许经过多次pushup操作，上层的祖先们就会更加和睦，做出宝贵的和平决定吧。</p>\r\n<p>（吹爆COD现代战争三部曲）</p>\r\n","tags":["Life"]},{"title":"Blog is open now!","url":"/2022/01/24/Blog-is-open-now/","content":"<h2 id=\"博客迁移已完成之后的东西大概都在这里写了\">博客迁移已完成，之后的东西大概都在这里写了</h2>\r\n<p>由于多重原因，洛谷博客据说要没了，昨晚考虑把博客迁移到这里来，经过一中午和一下午的努力，博客迁移工作终于完成了，之后的东西就都在这里写吧。</p>\r\n<p><a href=\"https://imgtu.com/i/7TSqln\"><img src=\"https://s4.ax1x.com/2022/01/24/7TSqln.png\" alt=\"截图\" /></a></p>\r\n","tags":["Life"]},{"title":"浅谈随机数据生成与对拍","url":"/2021/10/12/%E6%B5%85%E8%B0%88%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E4%B8%8E%E5%AF%B9%E6%8B%8D/","content":"<h2 id=\"背景\">背景</h2>\r\n<p>最近写了一个对拍器，自认为对于对拍有一定见解，但今天<span class=\"math inline\">\\(cjf\\)</span>说如果用<span class=\"math inline\">\\(srand(time(0))\\)</span>，在卑微的Windows系统下一秒钟实际上只对了一组数据，因为<span class=\"math inline\">\\(time(0)\\)</span>在一秒钟内不会变化，写了个程序 试了一下，确实如此 <span id=\"more\"></span> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;test.in&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,stdout);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>,las = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (a==las)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">\t\ta = <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!las) las = a;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure> cnt统计的是和最先一次rand出来的数相同的数的个数</p>\r\n<p>cnt大概有1e7-2e7，可见数据生成器生成数据的不随机性（除非你的程序用时太久，不能在1s内跑完生成的数据）</p>\r\n<p><strong>显然，这会对对拍的效率产生严重影响，那么应该如何生成完全随机的数据呢？</strong></p>\r\n<h2 id=\"方法\">方法</h2>\r\n<p>先用<span class=\"math inline\">\\(srand\\)</span>生成10个左右的随机数，然后就可以得到10个随机种子，再用它们生成随机数，同时运行程序，就可以得到真正的随机数了。</p>\r\n<p>但这样有一个问题：生成的随机数都是5位数，所以在对拍几万个数据后，种子就是重复的了，那样就没有意义了，所以考虑生成更大的种子。</p>\r\n<p>在这里给出一种方法：用两个<span class=\"math inline\">\\(for\\)</span>把种子乘起来当作种子，这样种子大概率就不同了。</p>\r\n<p>具体传种子的方法读者可以自己实现，在这里给出一种方式：<span class=\"math inline\">\\(freopen\\)</span> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sed;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;seed.in&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">    cin&gt;&gt;sed;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>((<span class=\"keyword\">unsigned</span>)sed);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    your code here</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> 具体生成随机数的方法： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> rs[<span class=\"number\">15</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">             rs[i] = <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=<span class=\"number\">10</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\">ofstream <span class=\"title\">output</span><span class=\"params\">(<span class=\"string\">&quot;seed.in&quot;</span>)</span></span>;</span><br><span class=\"line\">\t\t\t\toutput&lt;&lt;rs[i]*rs[j]&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;1.exe&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure> 其实一般只随机10个数也可以，重复周期较长</p>\r\n<h2 id=\"附录\">附录</h2>\r\n<p>貌似不生成数据，单独使用<span class=\"math inline\">\\(fc\\)</span>比较文件很慢？（请读者自行测试100000行以上数据，本机测得<span class=\"math inline\">\\(fc\\)</span>比字符比较慢很多） <img src=\"https://z3.ax1x.com/2021/10/12/5nzKv8.md.png\" alt=\"实测结果\" /></p>\r\n","tags":["Knowledge"]},{"title":"NOIP2021 Journal","url":"/2021/11/20/NOIP2021-Journal/","content":"<p>人生中第一场NOIP，就这样落幕了</p>\r\n<h1 id=\"day--1\">Day -1</h1>\r\n<p>随便打了几个板子，发现没有什么需要复习的，因为所学实在太少，心态也十分放松，大概是知道自己状态不好，在短时间内也无法挽救，不会的知识实在太多，而能熟练运用的又太少，感觉再做什么也无济于事了。</p>\r\n<p><del>于是看了Person Of Interest Season 4，突然很想写一个能和我对话、保护我、洞悉世事的程序</del></p>\r\n<p>是的，考试的前一天就这样平凡地过去了</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"day-1\">Day 1</h1>\r\n<p>大概7：50就进了考场，找到自己的座位，却发现电脑没开。于是自行打开，却发现有两个Windows10？等了一会，老师说用第二个，于是不那么顺利地进入了系统。</p>\r\n<p>先把缺省源打了，之后打了个对拍器，发现没关同步，于是加了两行代码到缺省源里，设置了编译选项，准备工作完成。</p>\r\n<p>大概在打完后不就，发现试卷的密码在大屏幕上，好像是IronHeart之类的（<del>钢铁雄心？？？</del>），难道出题人是Paradox玩家？但是没时间想那么多了，解压完成后就立刻打开了试题。</p>\r\n<p>照例先开第一题，发现题目说的东西很奇怪，而且数据范围也并非线性：<span class=\"math inline\">\\(1e7\\)</span>，这<span class=\"math inline\">\\(O(nlogn)\\)</span>都有点悬，不会要<span class=\"math inline\">\\(O(n)\\)</span>吧，但是这样也小了个七八倍，反正就很奇怪。</p>\r\n<p>之后仔细看了下题，发现只要把每一个符合条件的数的倍数都标记一遍就行了？（好像这便是著名的<span class=\"math inline\">\\(O(nlogn)\\)</span>算法）</p>\r\n<p>但是我觉得题目肯定不会这么简单，这样写肯定是要被卡的，于是研究了很久的性质，发现只要标记一个符合条件的数的质数倍就行了，因为合数肯定可以表示为若干个质数的乘积。</p>\r\n<p>但是即使这样写，也可能有TLE的风险，因为这样筛并不是绝对线性的，例如<strong>宇宙所有问题的终极答案<span class=\"math inline\">\\(42\\)</span></strong>，它既可以表示成<span class=\"math inline\">\\(14\\times3 = 7\\times2\\times3\\)</span>，也可以表示成<span class=\"math inline\">\\(21\\times2 = 7\\times3\\times2\\)</span>，这样数<span class=\"math inline\">\\(42\\)</span>就被标记了两次，显然还有更多这样的数，所以这样做就不是线性的</p>\r\n<p>如何让每个数只被标记一次呢？其实也很显然：只要一个数的倍数被分解为的质因数中最小的数小于等于要乘的质数，就行了，因为满足倍数被分解为若干个不降的质数的情况只有一种。很好，这样就是完全线性的了！</p>\r\n<p>但是我没想到的是，由于还要用一遍<span class=\"math inline\">\\(Euler\\)</span>筛筛出所有的质数，所以复杂度是两个<span class=\"math inline\">\\(O(n)\\)</span>的，实测跑的比广为流传的<span class=\"math inline\">\\(O(nlogn)\\)</span>算法还要慢。。。</p>\r\n<p>由于各种意想不到的<span class=\"math inline\">\\(bug\\)</span>，过了<span class=\"math inline\">\\(1.5h\\)</span>才打完T1且开拍了</p>\r\n<p>算了，反正T1写完了，按理说要看T2了，于是我就看了。</p>\r\n<p>第一眼是一个以<span class=\"math inline\">\\(m+1\\)</span>为指数的暴力，开心地在<span class=\"math inline\">\\(30min\\)</span>左右写完了，发现样例2要跑<span class=\"math inline\">\\(11s\\)</span>？感觉再优化也没什么希望了，就暂时放下了，开T3</p>\r\n<p>T3一看，就想到了ZROI上的一道题，然而看了好久，发现其本质不是一个东西，拿前缀和推也没啥性质，而且这个序列可能可以无限操作下去，很难有重复的情况，推了一堆没有用的东西，发现只剩下<span class=\"math inline\">\\(1.5h\\)</span>左右了，以我的水平顶多打几个暴力走人，于是看了眼T4，发现没啥希望，跟斗地主一样恶心，就回去看T2了</p>\r\n<p>突然发现这样搜索搜到了很多重复的情况，很明显是不优的，如果改成枚举每一位选了多少个，就可以用排列乘出所有的情况，复杂度有了小小的改善，于是开写</p>\r\n<p>写完之后，发现乘那个权值时__int128爆了，于是开始写高精，发现不会<span class=\"math inline\">\\(log\\)</span>的取模，于是把写了<span class=\"math inline\">\\(45min\\)</span>的高精代码删了，又改成__int128，感觉没啥希望了，于是写T3的暴力</p>\r\n<p>T3由于不知道要操作多少次，就找了一个有可能过<span class=\"math inline\">\\(n&lt;=10\\)</span>的点且不超时的<span class=\"math inline\">\\(9\\)</span>次放进去了，发现第二个样例都过不了，此时离考试结束只有<span class=\"math inline\">\\(30min\\)</span>不到了，于是把考生须知填了，之后开始打坐。</p>\r\n<p>所有程序的文件名检查完之后，又看了一眼题面，试图找到一点思路，突然发现T2说的是小于等于<span class=\"math inline\">\\(k\\)</span>，草！</p>\r\n<p>于是疯狂改，再边乘边取模，最后竟然过了样例2？很满意</p>\r\n<p>打铃，收卷，结束。</p>\r\n<p>是的，我的第一场NOIP就这样结束了，内心毫无波澜的提交了文件夹，看见人均200+，虽有失望，可是并没有为此懊恼，因为有那么多没学的，有那么多不会的<span class=\"math inline\">\\(trick\\)</span>，这也很公平。</p>\r\n<p>停课结束后，又要投入到紧张的<span class=\"math inline\">\\(whk\\)</span>学习中，虽然有那么多不会的，那又如何呢，总是要补的。</p>\r\n<p>其实，生活中许多不如意，是你欠你自己的，付出与回报不会成正比，但是要回报，必须付出些什么，而最不必的便是为这些付出懊恼，你欠的，总是要还回来的嘛。</p>\r\n<blockquote>\r\n<p>This is my final fit</p>\r\n<p>My final bellyache with</p>\r\n<p>No alarms and no surprises</p>\r\n<p>No alarms and no surprises please</p>\r\n</blockquote>\r\n","tags":["Life"]},{"title":"自建题目目录与解答","url":"/2022/01/15/%E8%87%AA%E5%BB%BA%E9%A2%98%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%8E%E8%A7%A3%E7%AD%94/","content":"<h2 id=\"tri\"><a href=\"https://www.luogu.com.cn/problem/U198025\">Tri</a></h2>\r\n<p>首先考虑最暴力的做法，只用把所有的三角形数都枚举一遍，再看看因数数量即可，但是，假设判断了<span class=\"math inline\">\\(q\\)</span>个三角形数，其中每个数为<span class=\"math inline\">\\(m\\)</span>，如果<span class=\"math inline\">\\(\\sqrt m\\)</span>判断因数是否符合条件，会让总复杂度达到<span class=\"math inline\">\\(q \\sqrt m\\)</span>级别的，这显然是无法接受的</p>\r\n<p>于是想到一个定理：</p>\r\n<p>如果一个数<span class=\"math inline\">\\(p\\)</span>能够被表示为<span class=\"math inline\">\\(p = {a_1}^{k1}+{a_2}^{k2}+...+{a_n}^{k_n}\\)</span>，那么<span class=\"math inline\">\\(p\\)</span>的因数个数即为<span class=\"math inline\">\\((k_1+1)*(k_2+1)*...*(k_n+1)\\)</span>，这代表我们只需要知道一个数的所有质因数，就可以知道它的约数个数，于是总时间复杂度就被降低到了<span class=\"math inline\">\\(O(q\\log m)\\)</span>级别的，有了很可观的改善</p>\r\n<span id=\"more\"></span>\r\n<p><span class=\"math inline\">\\(Sample \\ Code:\\)</span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1e6</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">1e6</span>,k,vis[N*<span class=\"number\">2</span>],pri[N],tot;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&gt;N || vis[i]&lt;pri[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>,coun;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot &amp;&amp; x;i++)&#123;</span><br><span class=\"line\">\t\tcoun = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%pri[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcoun++;</span><br><span class=\"line\">\t\t\tx/=pri[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt*=coun;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cnt&gt;k) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tsum+=i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">chk</span>(sum)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;sum&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>但是对于<span class=\"math inline\">\\(n\\geq 1200\\)</span>，这种算法也无法在<span class=\"math inline\">\\(1.5s\\)</span>的时限内跑完，所以还需要优化</p>\r\n<p>如何优化呢？</p>\r\n<p>因为三角形数是形为<span class=\"math inline\">\\(p*(p+1)/2\\)</span>的数，所以这个<span class=\"math inline\">\\(p\\)</span>必然是根号级别的，可以从这里下手</p>\r\n<p>而且易证<span class=\"math inline\">\\(p\\)</span>和<span class=\"math inline\">\\(p+1\\)</span>是互质的，其中包含的质因数必然完全不同，所以三角形数的因数可以由<span class=\"math inline\">\\(p\\)</span>的因数和<span class=\"math inline\">\\(p+1\\)</span>的因数相乘得到</p>\r\n<p>可以先把一定范围内的数的因数预处理出来，之后判断时直接调用即可</p>\r\n<p>这里采用了与上一份代码类似的因数个数计算方法</p>\r\n<p><span class=\"math inline\">\\(Sample \\ Code:\\)</span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1.5e5</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">1e5</span>,k,vis[N*<span class=\"number\">2</span>],pri[N],tot,v[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&gt;N || vis[i]&lt;pri[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>,coun;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\tcoun = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%pri[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcoun++;</span><br><span class=\"line\">\t\t\tx/=pri[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt*=coun;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++) v[i] = <span class=\"built_in\">get</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i%<span class=\"number\">2</span>) ans = v[i]*v[(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = v[i/<span class=\"number\">2</span>]*v[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans&gt;k)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">1ll</span>*i*(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;Set n to a bigger value&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>但是，对于更大的<span class=\"math inline\">\\(n\\)</span>，这种算法却出奇的慢，原因就在于<span class=\"math inline\">\\(get\\)</span>函数中大量使用取模和除法操作，而且判断了很多不能整除的质数，最后可能还没有最简单的加法来得快</p>\r\n<p>而且一个一个累加，虽然看上去很慢，但是每一个因数都累加到了，绝无重复操作和无用操作，极大的提高了算法的效率</p>\r\n<p>这里采用尝试法，把所有因数都试出来，虽然看上去接近于<span class=\"math inline\">\\(O(n^2)\\)</span>，但是由于每个数的平均质因数在<span class=\"math inline\">\\(log\\)</span>级别，所以其实是接近<span class=\"math inline\">\\(O(n*\\log n)\\)</span>再带一个大常数的（前<span class=\"math inline\">\\(1e7\\)</span>个数的因数计算花费<span class=\"math inline\">\\(2s\\)</span>）</p>\r\n<p><span class=\"math inline\">\\(Sample \\ Code:\\)</span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2.8e6</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">2.5e6</span>,k,v[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=i;j&lt;=N;j+=i) v[j]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&amp;<span class=\"number\">1</span>) ans = v[i]*v[(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = v[i/<span class=\"number\">2</span>]*v[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans&gt;k)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">1ll</span>*i*(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;Set n to a bigger value&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>于是，这个简短的代码就是这道题目前的最优解了，题解愉快的结束了！</p>\r\n<p>为了防止不必要的卡常，已把本题时限开到<span class=\"math inline\">\\(2s\\)</span>，默认开启<span class=\"math inline\">\\(O2\\)</span>优化，即使你的<span class=\"math inline\">\\(N\\)</span>设置的不是那么微妙，也是可以轻松通过的</p>\r\n","tags":["Knowledge"]}]