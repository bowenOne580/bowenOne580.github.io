[{"title":"Blog is open now!","url":"/2022/01/24/Blog-is-open-now/","content":"<h2\r\nid=\"博客迁移已完成之后的东西大概都在这里写了\">博客迁移已完成，之后的东西大概都在这里写了</h2>\r\n<p>由于多重原因，洛谷博客据说要没了，昨晚考虑把博客迁移到这里来，经过一中午和一下午的努力，博客迁移工作终于完成了，之后的东西就都在这里写吧。</p>\r\n<p><a href=\"https://imgtu.com/i/7TSqln\"><img\r\nsrc=\"https://s4.ax1x.com/2022/01/24/7TSqln.png\" alt=\"截图\" /></a></p>\r\n","tags":["Life"]},{"title":"NOIP2021 Journal","url":"/2021/11/20/NOIP2021-Journal/","content":"<p>人生中第一场NOIP，就这样落幕了</p>\r\n<h1 id=\"day--1\">Day -1</h1>\r\n<p>随便打了几个板子，发现没有什么需要复习的，因为所学实在太少，心态也十分放松，大概是知道自己状态不好，在短时间内也无法挽救，不会的知识实在太多，而能熟练运用的又太少，感觉再做什么也无济于事了。</p>\r\n<p><del>于是看了Person Of Interest Season\r\n4，突然很想写一个能和我对话、保护我、洞悉世事的程序</del></p>\r\n<p>是的，考试的前一天就这样平凡地过去了</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"day-1\">Day 1</h1>\r\n<p>大概7：50就进了考场，找到自己的座位，却发现电脑没开。于是自行打开，却发现有两个Windows10？等了一会，老师说用第二个，于是不那么顺利地进入了系统。</p>\r\n<p>先把缺省源打了，之后打了个对拍器，发现没关同步，于是加了两行代码到缺省源里，设置了编译选项，准备工作完成。</p>\r\n<p>大概在打完后不就，发现试卷的密码在大屏幕上，好像是IronHeart之类的（<del>钢铁雄心？？？</del>），难道出题人是Paradox玩家？但是没时间想那么多了，解压完成后就立刻打开了试题。</p>\r\n<p>照例先开第一题，发现题目说的东西很奇怪，而且数据范围也并非线性：<span\r\nclass=\"math inline\">\\(1e7\\)</span>，这<span\r\nclass=\"math inline\">\\(O(nlogn)\\)</span>都有点悬，不会要<span\r\nclass=\"math inline\">\\(O(n)\\)</span>吧，但是这样也小了个七八倍，反正就很奇怪。</p>\r\n<p>之后仔细看了下题，发现只要把每一个符合条件的数的倍数都标记一遍就行了？（好像这便是著名的<span\r\nclass=\"math inline\">\\(O(nlogn)\\)</span>算法）</p>\r\n<p>但是我觉得题目肯定不会这么简单，这样写肯定是要被卡的，于是研究了很久的性质，发现只要标记一个符合条件的数的质数倍就行了，因为合数肯定可以表示为若干个质数的乘积。</p>\r\n<p>但是即使这样写，也可能有TLE的风险，因为这样筛并不是绝对线性的，例如<strong>宇宙所有问题的终极答案<span\r\nclass=\"math inline\">\\(42\\)</span></strong>，它既可以表示成<span\r\nclass=\"math inline\">\\(14\\times3 =\r\n7\\times2\\times3\\)</span>，也可以表示成<span\r\nclass=\"math inline\">\\(21\\times2 = 7\\times3\\times2\\)</span>，这样数<span\r\nclass=\"math inline\">\\(42\\)</span>就被标记了两次，显然还有更多这样的数，所以这样做就不是线性的</p>\r\n<p>如何让每个数只被标记一次呢？其实也很显然：只要一个数的倍数被分解为的质因数中最小的数小于等于要乘的质数，就行了，因为满足倍数被分解为若干个不降的质数的情况只有一种。很好，这样就是完全线性的了！</p>\r\n<p>但是我没想到的是，由于还要用一遍<span\r\nclass=\"math inline\">\\(Euler\\)</span>筛筛出所有的质数，所以复杂度是两个<span\r\nclass=\"math inline\">\\(O(n)\\)</span>的，实测跑的比广为流传的<span\r\nclass=\"math inline\">\\(O(nlogn)\\)</span>算法还要慢。。。</p>\r\n<p>由于各种意想不到的<span class=\"math inline\">\\(bug\\)</span>，过了<span\r\nclass=\"math inline\">\\(1.5h\\)</span>才打完T1且开拍了</p>\r\n<p>算了，反正T1写完了，按理说要看T2了，于是我就看了。</p>\r\n<p>第一眼是一个以<span\r\nclass=\"math inline\">\\(m+1\\)</span>为指数的暴力，开心地在<span\r\nclass=\"math inline\">\\(30min\\)</span>左右写完了，发现样例2要跑<span\r\nclass=\"math inline\">\\(11s\\)</span>？感觉再优化也没什么希望了，就暂时放下了，开T3</p>\r\n<p>T3一看，就想到了ZROI上的一道题，然而看了好久，发现其本质不是一个东西，拿前缀和推也没啥性质，而且这个序列可能可以无限操作下去，很难有重复的情况，推了一堆没有用的东西，发现只剩下<span\r\nclass=\"math inline\">\\(1.5h\\)</span>左右了，以我的水平顶多打几个暴力走人，于是看了眼T4，发现没啥希望，跟斗地主一样恶心，就回去看T2了</p>\r\n<p>突然发现这样搜索搜到了很多重复的情况，很明显是不优的，如果改成枚举每一位选了多少个，就可以用排列乘出所有的情况，复杂度有了小小的改善，于是开写</p>\r\n<p>写完之后，发现乘那个权值时__int128爆了，于是开始写高精，发现不会<span\r\nclass=\"math inline\">\\(log\\)</span>的取模，于是把写了<span\r\nclass=\"math inline\">\\(45min\\)</span>的高精代码删了，又改成__int128，感觉没啥希望了，于是写T3的暴力</p>\r\n<p>T3由于不知道要操作多少次，就找了一个有可能过<span\r\nclass=\"math inline\">\\(n&lt;=10\\)</span>的点且不超时的<span\r\nclass=\"math inline\">\\(9\\)</span>次放进去了，发现第二个样例都过不了，此时离考试结束只有<span\r\nclass=\"math inline\">\\(30min\\)</span>不到了，于是把考生须知填了，之后开始打坐。</p>\r\n<p>所有程序的文件名检查完之后，又看了一眼题面，试图找到一点思路，突然发现T2说的是小于等于<span\r\nclass=\"math inline\">\\(k\\)</span>，草！</p>\r\n<p>于是疯狂改，再边乘边取模，最后竟然过了样例2？很满意</p>\r\n<p>打铃，收卷，结束。</p>\r\n<p>是的，我的第一场NOIP就这样结束了，内心毫无波澜的提交了文件夹，看见人均200+，虽有失望，可是并没有为此懊恼，因为有那么多没学的，有那么多不会的<span\r\nclass=\"math inline\">\\(trick\\)</span>，这也很公平。</p>\r\n<p>停课结束后，又要投入到紧张的<span\r\nclass=\"math inline\">\\(whk\\)</span>学习中，虽然有那么多不会的，那又如何呢，总是要补的。</p>\r\n<p>其实，生活中许多不如意，是你欠你自己的，付出与回报不会成正比，但是要回报，必须付出些什么，而最不必的便是为这些付出懊恼，你欠的，总是要还回来的嘛。</p>\r\n<blockquote>\r\n<p>This is my final fit</p>\r\n<p>My final bellyache with</p>\r\n<p>No alarms and no surprises</p>\r\n<p>No alarms and no surprises please</p>\r\n</blockquote>\r\n","tags":["Life"]},{"title":"P4662黑手党题解","url":"/2022/03/19/P4662%E9%BB%91%E6%89%8B%E5%85%9A%E9%A2%98%E8%A7%A3/","content":"<h2 id=\"题目大意\">题目大意</h2>\r\n<p>给一个有 <span class=\"math inline\">\\(n\\)</span> 个点和 <span\r\nclass=\"math inline\">\\(m\\)</span> 条边的图，现在给定一个源点 <span\r\nclass=\"math inline\">\\(a\\)</span> ，一个汇点 <span\r\nclass=\"math inline\">\\(b\\)</span>\r\n和去掉每个点所需的费用，求出需要去掉哪些点，使 <span\r\nclass=\"math inline\">\\(a\\)</span> 和 <span\r\nclass=\"math inline\">\\(b\\)</span> 不再连通的费用最小。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<p>我们发现，只要把点变成边，边权设为去掉这个点的费用，就变成了求一个网络的最小割，即最大流，于是考虑通过Dinic算法求出最大流。</p>\r\n<p>我们用拆点解决将点变成边的问题。首先，原来图中就有的边，是不允许去掉的，所以我们要保证它不会被割掉，将其边权设为正无穷。对于图中的点，我们可以把一个点拆成两个，一个称作入点，即有流量进入的点，一个称作出点，即流量流向别的地方的点，我们从入点向出点连边，边权设为费用，这样我们就将点转化为了边。而原来图中连的边，可以看作从一个点的出点连向另一个点的入点。</p>\r\n<p>之后，我们可以跑一遍Dinic求出最大流，这样我们就找到了最小割。<strong>需要注意的是，题目中说明源点\r\n<span class=\"math inline\">\\(a\\)</span> 和汇点 <span\r\nclass=\"math inline\">\\(b\\)</span> 也是可以去掉的，所以我们要从源点 <span\r\nclass=\"math inline\">\\(a\\)</span> 的入边到汇点 <span\r\nclass=\"math inline\">\\(b\\)</span> 的出边跑最大流，这样才能让源点 <span\r\nclass=\"math inline\">\\(a\\)</span> 和汇点 <span\r\nclass=\"math inline\">\\(b\\)</span> 都能被去掉</strong>。</p>\r\n<p>这一部分是比较常见的套路。</p>\r\n<p><strong>不太寻常的是题目中的输出，求的是构成最小割的一个方案。</strong></p>\r\n<p>我们再来思考最小割的意义：</p>\r\n<p>最小割，即去掉某些边后，网络的源点和汇点不再连通，且边权之和最小。</p>\r\n<p>显然，在求出最大流后的残量网络中，从源点一定无法到达汇点。</p>\r\n<p>也就是说，我们只要从源点开始走，走所能到达的点，一定会存在某一时刻走不动了，如下图所示：</p>\r\n<figure>\r\n<img\r\nsrc=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/image-20220319161843973.png\"\r\nalt=\"image-20220319161843973\" />\r\n<figcaption aria-hidden=\"true\">image-20220319161843973</figcaption>\r\n</figure>\r\n<p>此图中，从源点开始，一直走，直到走到了 <span\r\nclass=\"math inline\">\\(x\\)</span>，发现后面再走 <span\r\nclass=\"math inline\">\\(y\\)</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span> 的边权都为 <span\r\nclass=\"math inline\">\\(0\\)</span> ，不能继续走了，就说明如果将 <span\r\nclass=\"math inline\">\\(y\\)</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span> 割掉，源点途径 <span\r\nclass=\"math inline\">\\(x\\)</span>\r\n的路径就永远无法到达汇点，也就是说，所有满足这样，这条边指向的点（如\r\n<span class=\"math inline\">\\(x\\)</span> ）被访问，但是出发点（如 <span\r\nclass=\"math inline\">\\(y\\)</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span>\r\n）没有被访问的点，都是需要被去除的点，这样才能构成一个割。</p>\r\n<h2 id=\"code\">Code</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">6e2</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,dis[N],now[N],in[N],out[N],vis[N];</span><br><span class=\"line\">queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; an;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">e</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[M*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">    edge[++tot].to = y;</span><br><span class=\"line\">    edge[tot].next = head[x];</span><br><span class=\"line\">    edge[tot].w = w;</span><br><span class=\"line\">    head[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dis));</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">    dis[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    now[s] = head[s];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">            y = edge[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !dis[y])&#123;</span><br><span class=\"line\">                dis[y] = dis[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                now[y] = head[y];</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> flow)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v,res = flow,use;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=now[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">        v = edge[i].to;</span><br><span class=\"line\">        now[u] = i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; dis[v] == dis[u]+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            use = <span class=\"built_in\">dfs</span>(v,<span class=\"built_in\">min</span>(edge[i].w,res));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!use) dis[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            edge[i].w-=use;</span><br><span class=\"line\">            edge[i^<span class=\"number\">1</span>].w+=use;</span><br><span class=\"line\">            res-=use;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!res) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> flow-res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    vis[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">        v = edge[i].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !vis[v]) <span class=\"built_in\">dfs2</span>(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"comment\">//算出入点和出点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        in[i] = i*<span class=\"number\">2</span><span class=\"number\">-1</span>;</span><br><span class=\"line\">        out[i] = i*<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = in[s];</span><br><span class=\"line\">    t = out[t];</span><br><span class=\"line\">    <span class=\"comment\">//读入与建图</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[i],out[i],x);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[i],in[i],<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[x],in[y],inf);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[y],out[x],<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[y],in[x],inf);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[x],out[y],<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//Dinic求出最小割</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flow,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (flow = <span class=\"built_in\">dfs</span>(s,inf)) ans+=flow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//求出一个方案使源点和汇点不连通</span></span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=tot;i+=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!vis[edge[i].to] &amp;&amp; vis[edge[i^<span class=\"number\">1</span>].to])&#123;</span><br><span class=\"line\">            an.<span class=\"built_in\">push_back</span>((edge[i^<span class=\"number\">1</span>].to+<span class=\"number\">1</span>)/<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(an.<span class=\"built_in\">begin</span>(),an.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sz = an.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;sz;i++) cout&lt;&lt;an[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["Knowledge","网络流"]},{"title":"Useless Thoughts(遐想)","url":"/2021/08/02/Useless-Thoughts-%E9%81%90%E6%83%B3/","content":"<p><strong>War, war never changes.</strong></p>\r\n<p><strong>But peace, peace changes everything.</strong></p>\r\n<p>犹记得曾经带领举国10个远古军团在《文明Ⅵ》中鲁莽地向自己的友邦瑞士开战，在军队突破阿拉伯的援兵，围在没有任何防御的日内瓦城的所有边界方格上，取得第一次压倒性胜利时的喜悦与狂热，对占领的渴望充斥着我的大脑。</p>\r\n<span id=\"more\"></span>\r\n<p>也记得被阿拉伯疯狂传教、在边境造城挑衅后愤然发起突袭战争，率领接近20个单位的远征大军朝着开罗进发时的意气风发；但谁能想到几回合后我就被困在防御工事内进退不得，只得在阿拉伯的现代化大军到来前从海上逃跑，而又是什么导致了这场战争呢？是对复仇的渴望。</p>\r\n<p>最近了解了伊拉克战争和阿富汗战争，对此更是深有同感。9.11事件成为了阿富汗战争的导火索，控制石油资源的诱惑则导致了伊拉克战争，反观历史上的重大战争，又有哪个不是基于利益和复仇的呢？</p>\r\n<p>但在战争的进程中，有一方的力量却被忽视了——士兵。在游戏中，他们被化为单调的数值；在国家之间的战争中，他们被作为实力较量的筹码；在军官心中，他们被作为任人摆布的棋子。哪位国家元首曾将他们与经济损失、基础建设修复、物资补给一起计算战争的代价？P社玩家之所以成为\"大恶人\"，还不是因为他们无视面板上增加的死亡人数，狂热的发动战争，丝毫没想过那些数字对于他们的家人，挚友意味着什么！战争永远不会是美好的，不会是地图上几条线共同导向的结果，更不会是按动鼠标上的左右键就能完全体会的，其中酿成了多少人间悲剧，造就了多少绝望的结局，我们又如何得知！</p>\r\n<p>但仔细思考一下，各种冲突才是导致战争的最大缘由：边境冲突，宗教冲突，政党冲突（省略）它们也许是人类永远无法避免的命运。但就像线段树一样，作为叶子节点的我们，如果更加平和、宽容待人，能从生活中一个完美的光影，一个样貌奇特的绿树，一个陌生人的有趣谈话中发现美好，不过于厌世，也不盲目服从，那样也许经过多次pushup操作，上层的祖先们就会更加和睦，做出宝贵的和平决定吧。</p>\r\n<p>（吹爆COD现代战争三部曲）</p>\r\n","tags":["Life"]},{"title":"卡特兰数","url":"/2021/08/04/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","content":"<h2 id=\"更新记录\">更新记录</h2>\r\n<p>2021.9.22 将部分内容替换成了<span\r\nclass=\"math inline\">\\(LaTeX\\)</span>符号</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"前置知识\">前置知识</h2>\r\n<h3 id=\"排列数\">排列数</h3>\r\n<p><span class=\"math inline\">\\(A_n^m\\)</span> $ = $ <span\r\nclass=\"math inline\">\\(\\frac{n!}{(n-m)!}\\)</span> （从<span\r\nclass=\"math inline\">\\(n\\)</span>个数中选<span\r\nclass=\"math inline\">\\(m\\)</span>个来排列）<br />\r\n理解为第一位可以有<span\r\nclass=\"math inline\">\\(n\\)</span>种选择，第二位有<span\r\nclass=\"math inline\">\\(n-1\\)</span>种，最后一位（即第<span\r\nclass=\"math inline\">\\(m\\)</span>位）有<span\r\nclass=\"math inline\">\\(n-m+1\\)</span>种选择 故为<span\r\nclass=\"math inline\">\\(n\\)</span> <span\r\nclass=\"math inline\">\\(\\times\\)</span> <span\r\nclass=\"math inline\">\\((n-1)\\)</span> <span\r\nclass=\"math inline\">\\(\\times\\)</span> <span\r\nclass=\"math inline\">\\((n-2)\\)</span> <span\r\nclass=\"math inline\">\\(\\times\\)</span> … <span\r\nclass=\"math inline\">\\(\\times\\)</span> $(n-m+1) = $ <span\r\nclass=\"math inline\">\\(\\frac{n!}{(n-m)!}\\)</span> 全排列为<span\r\nclass=\"math inline\">\\(n!\\)</span></p>\r\n<h3 id=\"组合数\">组合数</h3>\r\n<p><span class=\"math inline\">\\(C_n^m\\)</span> <span\r\nclass=\"math inline\">\\(=\\)</span> <span\r\nclass=\"math inline\">\\(\\frac{n!}{(n-m)!*m!}\\)</span><br />\r\n理解为将<span\r\nclass=\"math inline\">\\(A_n^m\\)</span>的所有组合方式表示出来，也就是<span\r\nclass=\"math inline\">\\(m\\)</span>的全排列，为<span\r\nclass=\"math inline\">\\(m!\\)</span>，常将<span\r\nclass=\"math inline\">\\(n\\)</span>与<span\r\nclass=\"math inline\">\\(m\\)</span>写在一个括号里: <span\r\nclass=\"math inline\">\\(\\binom{m}{n}\\)</span><br />\r\n特别说明：<span class=\"math inline\">\\(A_n^m\\)</span> <span\r\nclass=\"math inline\">\\(= 0\\)</span>, <span\r\nclass=\"math inline\">\\(C_n^m\\)</span> <span class=\"math inline\">\\(=\r\n0\\)</span></p>\r\n<p><del>（写了这么多主要是因为看不懂将C写成括号后的表达方式）</del></p>\r\n<h2 id=\"卡特兰数的证明\">卡特兰数的证明</h2>\r\n<p>首先想一个<strong>简单一点</strong>的问题：<br />\r\n你有一个栈，<span\r\nclass=\"math inline\">\\(n\\)</span>个数，它们每一个都要进行一次入栈和出栈操作，请问共有多少种方式<br />\r\n可以将每次入栈操作看作 <span class=\"math inline\">\\(+1\\)</span>，出栈看作\r\n<span\r\nclass=\"math inline\">\\(-1\\)</span>，容易想到，合法的方案必须满足所有时刻的<strong>前缀和<span\r\nclass=\"math inline\">\\(&gt;=0\\)</span></strong><br />\r\n更形象地，将其转移到坐标系上，每次入栈将横坐标 <span\r\nclass=\"math inline\">\\(+1\\)</span>，每次出栈将纵坐标 <span\r\nclass=\"math inline\">\\(+1\\)</span>，则所有的合法情况满足<strong>横坐标值<span\r\nclass=\"math inline\">\\(&gt;=\\)</span>纵坐标值</strong>，所有的不合法情况满足<strong>纵坐标-横坐标<span\r\nclass=\"math inline\">\\(&gt;=1\\)</span></strong>，则所有不合法情况和函数<span\r\nclass=\"math inline\">\\(y=x+1\\)</span>必有大于等于1个交点，考虑将其转化为如下形式：</p>\r\n<p><img src=\"https://z3.ax1x.com/2021/09/05/hWt7gx.png\" /></p>\r\n<p>图中实线为不合法操作路径，将其与<span\r\nclass=\"math inline\">\\(y=x+1\\)</span>相交后的线段关于<span\r\nclass=\"math inline\">\\(y=x+1\\)</span>对称，得到的最终点是<span\r\nclass=\"math inline\">\\((n-1,n+1)\\)</span>，由于所有不合法路径必然经过<span\r\nclass=\"math inline\">\\(y=x+1\\)</span>，所以不合法的路径的情况转化为了从<span\r\nclass=\"math inline\">\\(0\\)</span>到<span\r\nclass=\"math inline\">\\((n-1,n+1)\\)</span>的路径总数之和，即<span\r\nclass=\"math inline\">\\(\\binom{n-1}{2n}\\)</span>或<span\r\nclass=\"math inline\">\\(\\binom{n+1}{2n}\\)</span>。<br />\r\n合法路径总数即为全部路径<span\r\nclass=\"math inline\">\\(-\\)</span>不合法路径，即<span\r\nclass=\"math inline\">\\(\\binom{n}{2n}\\)</span>-<span\r\nclass=\"math inline\">\\(\\binom{n-1}{2n}\\)</span>或<span\r\nclass=\"math inline\">\\(\\binom{n}{2n}\\)</span>-<span\r\nclass=\"math inline\">\\(\\binom{n+1}{2n}\\)</span></p>\r\n<figure>\r\n<img src=\"https://z3.ax1x.com/2021/09/05/hWtHv6.md.png\"\r\nalt=\"代码示例\" />\r\n<figcaption aria-hidden=\"true\">代码示例</figcaption>\r\n</figure>\r\n","tags":["Knowledge","组合数学"]},{"title":"浅谈随机数据生成与对拍","url":"/2021/10/12/%E6%B5%85%E8%B0%88%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E4%B8%8E%E5%AF%B9%E6%8B%8D/","content":"<h2 id=\"背景\">背景</h2>\r\n<p>最近写了一个对拍器，自认为对于对拍有一定见解，但今天<span\r\nclass=\"math inline\">\\(cjf\\)</span>说如果用<span\r\nclass=\"math inline\">\\(srand(time(0))\\)</span>，在卑微的Windows系统下一秒钟实际上只对了一组数据，因为<span\r\nclass=\"math inline\">\\(time(0)\\)</span>在一秒钟内不会变化，写了个程序\r\n试了一下，确实如此 <span id=\"more\"></span> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;test.in&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,stdout);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>,las = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (a==las)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">\t\ta = <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!las) las = a;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\ncnt统计的是和最先一次rand出来的数相同的数的个数</p>\r\n<p>cnt大概有1e7-2e7，可见数据生成器生成数据的不随机性（除非你的程序用时太久，不能在1s内跑完生成的数据）</p>\r\n<p><strong>显然，这会对对拍的效率产生严重影响，那么应该如何生成完全随机的数据呢？</strong></p>\r\n<h2 id=\"方法\">方法</h2>\r\n<p>先用<span\r\nclass=\"math inline\">\\(srand\\)</span>生成10个左右的随机数，然后就可以得到10个随机种子，再用它们生成随机数，同时运行程序，就可以得到真正的随机数了。</p>\r\n<p>但这样有一个问题：生成的随机数都是5位数，所以在对拍几万个数据后，种子就是重复的了，那样就没有意义了，所以考虑生成更大的种子。</p>\r\n<p>在这里给出一种方法：用两个<span\r\nclass=\"math inline\">\\(for\\)</span>把种子乘起来当作种子，这样种子大概率就不同了。</p>\r\n<p>具体传种子的方法读者可以自己实现，在这里给出一种方式：<span\r\nclass=\"math inline\">\\(freopen\\)</span> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sed;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;seed.in&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">    cin&gt;&gt;sed;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>((<span class=\"keyword\">unsigned</span>)sed);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    your code here</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n具体生成随机数的方法： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> rs[<span class=\"number\">15</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">             rs[i] = <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=<span class=\"number\">10</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\">ofstream <span class=\"title\">output</span><span class=\"params\">(<span class=\"string\">&quot;seed.in&quot;</span>)</span></span>;</span><br><span class=\"line\">\t\t\t\toutput&lt;&lt;rs[i]*rs[j]&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;1.exe&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n其实一般只随机10个数也可以，重复周期较长</p>\r\n<h2 id=\"附录\">附录</h2>\r\n<p>貌似不生成数据，单独使用<span\r\nclass=\"math inline\">\\(fc\\)</span>比较文件很慢？（请读者自行测试100000行以上数据，本机测得<span\r\nclass=\"math inline\">\\(fc\\)</span>比字符比较慢很多） <img\r\nsrc=\"https://z3.ax1x.com/2021/10/12/5nzKv8.md.png\" alt=\"实测结果\" /></p>\r\n","tags":["Knowledge","Misc"]},{"title":"物质的分类","url":"/2022/02/11/%E7%89%A9%E8%B4%A8%E7%9A%84%E5%88%86%E7%B1%BB/","content":"<h2 id=\"物质的分类-分散系-氧化物分类\">物质的分类（ 分散系\r\n氧化物分类）</h2>\r\n<span id=\"more\"></span>\r\n<h3 id=\"制备feoh_3胶体的实验\">制备<span\r\nclass=\"math inline\">\\(Fe(OH)_3\\)</span>胶体的实验</h3>\r\n<p><span class=\"math inline\">\\(FeCl_3+3H_2O \\frac{\\Delta}{=}\r\nFe(OH)_3（胶体）+3HCl\\)</span><br />\r\n（原谅这丑陋的方程式）</p>\r\n<h5 id=\"要点\">要点：</h5>\r\n<p><strong>反应条件</strong>：加热<br />\r\n要在<span class=\"math inline\">\\(Fe(OH)_3\\)</span>后面<strong>加上胶体\r\n</strong> 不要和<span\r\nclass=\"math inline\">\\(NaOH\\)</span>反应去了，这样会直接生成沉淀<br />\r\n要用<strong>煮沸</strong>的<strong>蒸馏水</strong>，而且是将<span\r\nclass=\"math inline\">\\(FeCl_3\\)</span>加入蒸馏水中，颜色变成<strong>红褐色</strong>时<strong>立即</strong>停止加热<br />\r\n不能用<strong>玻璃棒搅拌</strong>，要<strong>振荡烧杯</strong><br />\r\n淀粉溶液是<strong>胶体</strong>！</p>\r\n<h5 id=\"扩展\">扩展：</h5>\r\n<p>虽然反应是这样进行的，但是如果再加入适量<span\r\nclass=\"math inline\">\\(HCl\\)</span>，会发生以下反应：<span\r\nclass=\"math inline\">\\(Fe(OH)_3+3HCl = FeCl_3+3H_2O\\)</span><br />\r\n我的理解是因为胶体微粒带电，似乎从某种程度上阻止了反应的进行，但是加入<span\r\nclass=\"math inline\">\\(HCl\\)</span>到一定程度后，两边的电荷逐渐失衡，反应才开始进行，为了电荷的再次平衡</p>\r\n<h4 id=\"胶体的性质\">胶体的性质</h4>\r\n<ul>\r\n<li>粒子大小介于<span class=\"math inline\">\\(1nm\\)</span>~<span\r\nclass=\"math inline\">\\(100nm\\)</span>之间，不能透过半透膜<br />\r\n</li>\r\n<li>光学性质：丁达尔效应。实际上就是拿个激光笔照射之后有通路，就一定是胶体<br />\r\n</li>\r\n<li>运动学性质：布朗运动。解释是做无规则运动，好像也是因为这个性质具有介稳性<br />\r\n</li>\r\n<li>电学性质：电泳现象。通俗点说就是往哪边跑，极性就与哪边相反，异性相吸嘛\r\n<ul>\r\n<li>应用：工厂静电除尘（尘是胶体）</li>\r\n<li>注意：胶体是电中性的，只有胶粒才带电</li>\r\n</ul></li>\r\n<li>热力学性质：胶体的聚沉。貌似并不知道原理是什么\r\n<ul>\r\n<li>方法1：加入[[电解质]]（之后会讲）</li>\r\n<li>方法2：加入与胶粒带相反电荷的胶体（见<span\r\nclass=\"math inline\">\\(\\downarrow\\)</span>的扩展）</li>\r\n<li>方法3：加热（实验中可能会考加热过度，现象是有红褐色固体生成）</li>\r\n<li>应用：三角洲形成，明矾净水，盐卤制豆腐</li>\r\n</ul></li>\r\n</ul>\r\n<h5 id=\"扩展-1\">扩展：</h5>\r\n<ol type=\"1\">\r\n<li>胶体的正负电荷 正电荷：金属氢氧化物（<span\r\nclass=\"math inline\">\\(Fe(OH)_3\\)</span>），金属氧化物（<span\r\nclass=\"math inline\">\\(Fe_2O_3\\)</span>）<br />\r\n负电荷：非金属氧化物（<span\r\nclass=\"math inline\">\\(As_2O_3\\)</span>），金属硫化物（好像没看见？），但看见了金属（<span\r\nclass=\"math inline\">\\(Au\\)</span>）<br />\r\n</li>\r\n<li>不同物态的胶体 气溶胶：烟、雾<br />\r\n液溶胶：<span\r\nclass=\"math inline\">\\(Fe(OH)_3\\)</span>胶体、豆浆、淀粉<strong>溶液</strong><br />\r\n固溶胶：有色玻璃，烟水晶（?）</li>\r\n</ol>\r\n<h4 id=\"氧化物的分类\">氧化物的分类</h4>\r\n<p>碱性氧化物：能和酸反应生成盐和水的氧化物，如<span\r\nclass=\"math inline\">\\(CuO\\)</span><br />\r\n酸性氧化物：能和碱反应生成盐和水的氧化物，如<span\r\nclass=\"math inline\">\\(CO_2, SO_3\\)</span><br />\r\n两性氧化物：酸碱特性皆具备，称为两性氧化物，如<span\r\nclass=\"math inline\">\\(Al_2O_3\\)</span><br />\r\n不成盐氧化物：两个特性都不具备的氧化物，如<span\r\nclass=\"math inline\">\\(NO,CO\\)</span><br />\r\n<strong>特殊氧化物</strong>：好像只提到了<span\r\nclass=\"math inline\">\\(Fe_3O_4\\)</span>和<span\r\nclass=\"math inline\">\\(Na_2O_2\\)</span>这两个</p>\r\n<h5 id=\"大体观点\">大体观点：</h5>\r\n<p><strong>碱性氧化物</strong> <strong>一定</strong>是\r\n<strong>金属氧化物</strong> <strong>没有反例！ </strong>\r\n<strong>酸性氧化物</strong> 大部分是 <strong>非金属氧化物</strong>\r\n反例：<span class=\"math inline\">\\(Mn_2O_7\\)</span><br />\r\n<strong>金属氧化物</strong> 不一定是 <strong>碱性氧化物</strong>\r\n反例：<span\r\nclass=\"math inline\">\\(Mn_2O_7\\)</span>（这个好像真的很好用），<span\r\nclass=\"math inline\">\\(Al_2O_3\\)</span>（两性氧化物）<br />\r\n<strong>非金属氧化物</strong> 不一定是 <strong>酸性氧化物</strong>\r\n反例：<span class=\"math inline\">\\(CO\\)</span>（不成盐氧化物）<br />\r\n<strong>酸性氧化物</strong> 大多可以和水反应生成相应的酸 反例：<span\r\nclass=\"math inline\">\\(SiO_2\\)</span><br />\r\n<strong>碱性氧化物</strong> 大多不能和水反应生成相应的碱 反例：<span\r\nclass=\"math inline\">\\(Na_2O\\)</span>，<span\r\nclass=\"math inline\">\\(CaO\\)</span></p>\r\n<h4 id=\"补充错题\">补充错题：</h4>\r\n","tags":["Knowledge","WHK"]},{"title":"WHK目录","url":"/2022/02/11/WHK%E7%9B%AE%E5%BD%95/","content":"<h1 id=\"目录\">目录：</h1>\r\n<span id=\"more\"></span>\r\n<h2 id=\"化学\">化学</h2>\r\n<h3 id=\"必修1\">必修1</h3>\r\n<h4 id=\"第一单元\">第一单元</h4>\r\n<h5 id=\"part-1物质的分类\">Part 1：<a\r\nhref=\"https://bowenone580.github.io/2022/02/11/物质的分类/\">物质的分类</a></h5>\r\n","tags":["Knowledge","WHK","Menu"]},{"title":"网络流初步","url":"/2022/03/07/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E6%AD%A5/","content":"<h2 id=\"求解最大流\">求解最大流</h2>\r\n<h3 id=\"edmond-karp算法ek算法\">Edmond Karp算法（EK算法）</h3>\r\n<p>这种算法不是很常用，但是比较好理解，没有什么分层图之类的优化技巧，可以直接感性理解求解网络流问题的基本思想。此算法复杂度为<span\r\nclass=\"math inline\">\\(O(nm^2)\\)</span>，虽说很多时候卡不满，但是和SPFA一样，<strong>有被不经意间（刻意）卡掉的风险</strong>。</p>\r\n<span id=\"more\"></span>\r\n<p>首先，我们要知道什么是一个<strong>网络</strong>。其实是给你一张图，其中有一个<strong>源点</strong><span\r\nclass=\"math inline\">\\(s\\)</span>，一个<strong>汇点</strong><span\r\nclass=\"math inline\">\\(t\\)</span>，源点负责发放流量，汇点负责收集流量，网络中的边都有<strong>流量限制</strong>，也就是说经过这条边的流量不能超过这个限制。我们要的是到达汇点的流量最大。其中源点供应的流量是无限的。</p>\r\n<p>遍历整个图，每次尝试寻找一条<strong>增广路</strong>（一条从<span\r\nclass=\"math inline\">\\(s\\)</span>到<span\r\nclass=\"math inline\">\\(t\\)</span>的路径，其中所有边的剩余流量都大于<span\r\nclass=\"math inline\">\\(0\\)</span>），在找不到增广路时就找到了<strong>最大流</strong>。每找到一条增广路，我们就把这条路的所有边的剩余容量减少，表示有流从这里经过。</p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/flow1.png\" /></p>\r\n<p>我们先走<span class=\"math inline\">\\(4 \\rightarrow 2\r\n\\rightarrow3\\)</span>，这样有20的流量从<span\r\nclass=\"math inline\">\\(2\\)</span>到达<span\r\nclass=\"math inline\">\\(3\\)</span>，我们将<span\r\nclass=\"math inline\">\\(4\\rightarrow2\\rightarrow3\\)</span>这条增广路的剩余流量修改一下，<span\r\nclass=\"math inline\">\\(4\\rightarrow2\\)</span>变成<span\r\nclass=\"math inline\">\\(10\\)</span>，<span\r\nclass=\"math inline\">\\(2\\rightarrow3\\)</span>变成<span\r\nclass=\"math inline\">\\(0\\)</span>，这样我们就得到了一个<strong>残量网络</strong>（即已经有部分流量被占用了）。再走<span\r\nclass=\"math inline\">\\(4\\rightarrow3\\)</span>，<span\r\nclass=\"math inline\">\\(4\\rightarrow3\\)</span>修改为<span\r\nclass=\"math inline\">\\(0\\)</span>。走<span\r\nclass=\"math inline\">\\(4\\rightarrow2\\rightarrow1\\rightarrow3\\)</span>，由于最小的边是<span\r\nclass=\"math inline\">\\(4\\rightarrow2\\)</span>，所以只有<span\r\nclass=\"math inline\">\\(10\\)</span>的流量流到<span\r\nclass=\"math inline\">\\(3\\)</span>。</p>\r\n<p>于是，我们就得到了这个网络的最大流量：<span\r\nclass=\"math inline\">\\(50\\)</span>。</p>\r\n<p>但是，随便找一条增广路就是最优的吗，显然不是：</p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/1.png\" /></p>\r\n<p>如上图，每条边的容量都是<span\r\nclass=\"math inline\">\\(1\\)</span>，那么我们随便选一个增广路：<span\r\nclass=\"math inline\">\\(s\\rightarrow1\\rightarrow2\\rightarrow\r\nt\\)</span>，这样我们就得到了<span\r\nclass=\"math inline\">\\(1\\)</span>的流量，但是<span\r\nclass=\"math inline\">\\(s\\rightarrow2\\)</span>和<span\r\nclass=\"math inline\">\\(1\\rightarrow t\\)</span>都流不了任何东西了。</p>\r\n<p>换一种选法：<span class=\"math inline\">\\(s\\rightarrow1\\rightarrow\r\nt\\)</span>和<span class=\"math inline\">\\(s\\rightarrow2\\rightarrow\r\nt\\)</span>，这样我们就可以得到<span\r\nclass=\"math inline\">\\(2\\)</span>的流量，比之前瞎选的优。</p>\r\n<p>如果不能瞎选，该如何解决这种问题呢？</p>\r\n<p>由于网络有很多种，我们显然不能针对每种情况都设计一个算法，使得每次选择的路径都是最优的，更好的方法是不断尝试，逐渐把不优的替换掉，而这种替换需要一个反悔的工具：<strong>反向边</strong>。</p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/2.png\" style=\"zoom:67%;\" /></p>\r\n<p>我们再次从<span\r\nclass=\"math inline\">\\(s\\)</span>开始寻找增广路，可以从<span\r\nclass=\"math inline\">\\(s\\rightarrow2\\rightarrow1\\rightarrow\r\nt\\)</span>，这样就可以得到最大流量<span\r\nclass=\"math inline\">\\(2\\)</span>了。</p>\r\n<p>但这样为什么是对的呢？</p>\r\n<p>这一次走了从<span\r\nclass=\"math inline\">\\(2\\rightarrow1\\)</span>的反向边，可以看作<span\r\nclass=\"math inline\">\\(1\\)</span>原来流到<span\r\nclass=\"math inline\">\\(2\\)</span>的流回去了（反向边相当于把流送回去），再流向之后走的<span\r\nclass=\"math inline\">\\(1\\rightarrow t\\)</span>，而原来流向<span\r\nclass=\"math inline\">\\(2\\rightarrow t\\)</span>的流量由<span\r\nclass=\"math inline\">\\(s\\rightarrow2\\)</span>提供，这样就可以得到一条增广路了。当没有增广路时，说明我们找到了最大流（虽然我并不会证明这个的正确性）。</p>\r\n<p>时间复杂度简易证明：</p>\r\n<p>假设网络上有<span class=\"math inline\">\\(n\\)</span>个点，<span\r\nclass=\"math inline\">\\(m\\)</span>条边。</p>\r\n<p>第一个结论：在EK算法中，<span class=\"math inline\">\\(t\\)</span>和<span\r\nclass=\"math inline\">\\(s\\)</span>间的最短路长度一定是不降的，因为每次增广一个路径，这个路径按照<span\r\nclass=\"math inline\">\\(BFS\\)</span>是最短的路径，所以每次必然减少一个最短路径，我们考虑最坏的情况，变成一个二分图之类的东西，最短路的长度都为<span\r\nclass=\"math inline\">\\(3\\)</span>，这时需要增广<span\r\nclass=\"math inline\">\\(m\\)</span>次，也就是说最短路的长度不变时，最多增广<span\r\nclass=\"math inline\">\\(m\\)</span>次。</p>\r\n<p>第二个结论：每次<span\r\nclass=\"math inline\">\\(BFS\\)</span>的时间复杂度为<span\r\nclass=\"math inline\">\\(O(m)\\)</span>。</p>\r\n<p>第三个结论：每次增广中必然出现一个边，其剩余流量被完全占用，这条边要再有流量，需要反向边被增广，也就是说它再有剩余流量时，肯定是<span\r\nclass=\"math inline\">\\(t\\)</span>和<span\r\nclass=\"math inline\">\\(s\\)</span>之间的最短距离增加<span\r\nclass=\"math inline\">\\(2\\)</span>时，才能被再次增广。由于一共只有<span\r\nclass=\"math inline\">\\(n\\)</span>个点，最短路的长度最大是<span\r\nclass=\"math inline\">\\(n\\)</span>，改变次数最多为<span\r\nclass=\"math inline\">\\(n/2\\)</span>次。</p>\r\n<p>综合一、三结论，可得增广复杂度最多为<span\r\nclass=\"math inline\">\\(O(nm)\\)</span>，而每次增广的复杂度最多时<span\r\nclass=\"math inline\">\\(O(m)\\)</span>，所以EK算法的时间复杂度是<span\r\nclass=\"math inline\">\\(O(nm^2)\\)</span>。</p>\r\n<p><span class=\"math inline\">\\(Code\\)</span>：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,tim = <span class=\"number\">1</span>,vis[N],inc[N],pre[N],Max;</span><br><span class=\"line\">queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">e</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\tq.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\tvis[s] = tim;</span><br><span class=\"line\">\tinc[s] = inf;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; vis[y]!=tim)&#123;</span><br><span class=\"line\">\t\t\t\tinc[y] = <span class=\"built_in\">min</span>(inc[x],edge[i].w);</span><br><span class=\"line\">\t\t\t\tpre[y] = i;</span><br><span class=\"line\">\t\t\t\tvis[y] = tim;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> now = t,incf = inc[t];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (now!=s)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = pre[now];</span><br><span class=\"line\">\t\tedge[i].w-=incf;</span><br><span class=\"line\">\t\tedge[i^<span class=\"number\">1</span>].w+=incf;</span><br><span class=\"line\">\t\tnow = edge[i^<span class=\"number\">1</span>].to;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tMax+=incf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x,y,w;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,w);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">\t\ttim++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;Max&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"dinic算法\">Dinic算法</h3>\r\n<p>主要思想：</p>\r\n<p>先做一次BFS将图按到<span\r\nclass=\"math inline\">\\(s\\)</span>的最短路长度分层，之后做一次DFS（每次增广时可以多路增广），每次只向最短路长度比它大<span\r\nclass=\"math inline\">\\(1\\)</span>的点输出流量，这样找下去，直到<span\r\nclass=\"math inline\">\\(t\\)</span>到<span\r\nclass=\"math inline\">\\(s\\)</span>没有路径，说明没有增广路了，也就是找到了最大流。</p>\r\n<p>时间复杂度证明：</p>\r\n<p>第一个结论：每次增广，必然把所有能够增广的都增广了，也就是说<span\r\nclass=\"math inline\">\\(t\\)</span>到<span\r\nclass=\"math inline\">\\(s\\)</span>的最短路的长度至少增加<span\r\nclass=\"math inline\">\\(1\\)</span>，最多增加<span\r\nclass=\"math inline\">\\(n\\)</span>次</p>\r\n<p>第二个结论：每次<span\r\nclass=\"math inline\">\\(BFS\\)</span>，时间复杂度为<span\r\nclass=\"math inline\">\\(O(m)\\)</span>，每次<span\r\nclass=\"math inline\">\\(DFS\\)</span>，我们都要维护一个当前弧，也就是说当前弧最多变化<span\r\nclass=\"math inline\">\\(nm\\)</span>次，于是单次增广的时间复杂度最大为<span\r\nclass=\"math inline\">\\(O(nm)\\)</span></p>\r\n<p>综合一、二结论，Dinic算法的时间复杂度最大为<span\r\nclass=\"math inline\">\\(O(n^2m)\\)</span></p>\r\n<p>也就是说，它适合处理稠密图，但在<span\r\nclass=\"math inline\">\\(n\\)</span>是<span\r\nclass=\"math inline\">\\(1e3\\)</span>级别，<span\r\nclass=\"math inline\">\\(m\\)</span>是<span\r\nclass=\"math inline\">\\(1e5\\)</span>级别，Dinic算法可能无法在给定时间内处理所有情况，这时就需要用到HLPP了。</p>\r\n<p><span class=\"math inline\">\\(Code\\)</span>：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,d[N],now[N];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\">queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">e</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(d,<span class=\"number\">0</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(d));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\td[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tnow[s] = head[s];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !d[y])&#123;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t\t\td[y] = d[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tnow[y] = head[y];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> flow)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> v,use,res = flow,i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=now[u];i &amp;&amp; res;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\tnow[u] = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; d[v] == d[u]+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tuse = <span class=\"built_in\">dfs</span>(v,<span class=\"built_in\">min</span>(edge[i].w,res));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!use) d[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tedge[i].w-=use;</span><br><span class=\"line\">\t\t\tedge[i^<span class=\"number\">1</span>].w+=use;</span><br><span class=\"line\">\t\t\tres-=use;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> flow-res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x,y,w;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,w);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> flow;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tflow = <span class=\"built_in\">dfs</span>(s,inf);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!flow) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tans+=flow;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n","tags":["Knowledge","网络流"]},{"title":"背包问题浅析","url":"/2022/02/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/","content":"<h2 id=\"最基础的背包01背包\">最基础的背包——01背包</h2>\r\n<p>问题：</p>\r\n<p>给定一个容量为<span class=\"math inline\">\\(w\\)</span>的背包，有<span\r\nclass=\"math inline\">\\(n\\)</span>件物品，每件物品都有一个价值<span\r\nclass=\"math inline\">\\(v\\)</span>和一个体积<span\r\nclass=\"math inline\">\\(c\\)</span>，问背包能装下的物品的最大价值和</p>\r\n<p>思路：</p>\r\n<p>每件物品都有选或不选(0或1)两种状态，考虑用此作为<span\r\nclass=\"math inline\">\\(dp\\)</span>的一个维度，对于特定容量的价值，是从之前的容量的价值递推出来的，故可以用此作为<span\r\nclass=\"math inline\">\\(dp\\)</span>的第二个维度，于是就有了<span\r\nclass=\"math inline\">\\(dp\\)</span>数组<span\r\nclass=\"math inline\">\\(f[i][j]\\)</span>表示考虑了前<span\r\nclass=\"math inline\">\\(i\\)</span>个物品，容量为<span\r\nclass=\"math inline\">\\(j\\)</span>时的最大价值</p>\r\n<p>如何转移呢？</p>\r\n<span id=\"more\"></span>\r\n<p>对<span\r\nclass=\"math inline\">\\(f\\)</span>数组的修改必然涉及到一个变量：价值<span\r\nclass=\"math inline\">\\(v\\)</span>，所以需要<span\r\nclass=\"math inline\">\\(v\\)</span>参与<span\r\nclass=\"math inline\">\\(dp\\)</span>的转移方程，稍加考虑即可推出一个简明的方程：</p>\r\n<p><span class=\"math inline\">\\(f[i][j] =\r\nmax(f[i-1][j],f[i-1][j-c[i]]+v[i])\\)</span></p>\r\n<p><span\r\nclass=\"math inline\">\\(max\\)</span>的第一项表示不选择这个物品，直接使用<span\r\nclass=\"math inline\">\\(i-1\\)</span>个物品的最大价值；第二项表示选择这个物品，所获得的价值是不放这个物品的背包的最大价值加上这个物品的价值</p>\r\n<p>可以发现，这个方程只和第<span\r\nclass=\"math inline\">\\(i\\)</span>项和第<span\r\nclass=\"math inline\">\\(i-1\\)</span>项有关，所以可以使用滚动数组做空间优化，即<span\r\nclass=\"math inline\">\\(f[j] = max(f[j],f[j-c[i]]+v[i])\\)</span></p>\r\n<p>但是，需要注意此处可能对<span\r\nclass=\"math inline\">\\(f[j]\\)</span>进行修改，但是我们需要用的是修改之前的值，所以需要倒序修改<span\r\nclass=\"math inline\">\\(f[j]\\)</span>，防止<span\r\nclass=\"math inline\">\\(f[j-c[i]]\\)</span>变成了现在的价值，而不是在放入<span\r\nclass=\"math inline\">\\(i-1\\)</span>个物品的价值</p>\r\n<p>时间复杂度：<span class=\"math inline\">\\(O(nw)\\)</span></p>\r\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1048\">P1048\r\n采药</a></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">int</span> w,n,v[<span class=\"number\">105</span>],c[<span class=\"number\">105</span>],f[<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;w&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;c[i]&gt;&gt;v[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=w;j&gt;=c[i];j--) f[j] = <span class=\"built_in\">max</span>(f[j],f[j-c[i]]+v[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[w]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"背包的变形完全背包\">01背包的变形——完全背包</h2>\r\n<p>问题：</p>\r\n<p>给定一个容量为<span class=\"math inline\">\\(w\\)</span>的背包，有<span\r\nclass=\"math inline\">\\(n\\)</span><strong>种</strong>物品，每<strong>种</strong>物品都有一个价值<span\r\nclass=\"math inline\">\\(v\\)</span>和一个体积<span\r\nclass=\"math inline\">\\(c\\)</span>，<strong>且数量无限</strong>，问背包能装下的物品的最大价值和</p>\r\n<p>思路：</p>\r\n<p>还是考虑原来的<span class=\"math inline\">\\(dp\\)</span>方程：</p>\r\n<p><span class=\"math inline\">\\(f[j] =\r\nmax(f[j],f[j-c[i]]+v[i])\\)</span></p>\r\n<p>把修改顺序变为正序修改，思考一下<span\r\nclass=\"math inline\">\\(f[j]\\)</span>的意义</p>\r\n<p>当<span class=\"math inline\">\\(j&#39; = j+c[i]\\)</span>时，<span\r\nclass=\"math inline\">\\(f[j&#39;] = f[j]+v[i]\\)</span>，此时的<span\r\nclass=\"math inline\">\\(f[j]\\)</span>表示的是考虑<strong>前<span\r\nclass=\"math inline\">\\(i\\)</span>个</strong>物品的最大值，显然当前物品放入的情况也被考虑进去了，所以此时正序递推正好满足题目要求</p>\r\n<p>时间复杂度：<span class=\"math inline\">\\(O(nw)\\)</span></p>\r\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1616\">P1616\r\n疯狂的采药</a></p>\r\n<p><strong>注意：</strong></p>\r\n<p>1.数据范围更改了</p>\r\n<p>2.由于<span class=\"math inline\">\\(w\\)</span>可能到<span\r\nclass=\"math inline\">\\(1e7\\)</span>，而且每种物品的价值可能到<span\r\nclass=\"math inline\">\\(1e4\\)</span>，如果一件物品，它的价值是<span\r\nclass=\"math inline\">\\(1e4\\)</span>，体积是<span\r\nclass=\"math inline\">\\(1\\)</span>，那么结果可能会到<span\r\nclass=\"math inline\">\\(1e11\\)</span>，需要开<span\r\nclass=\"math inline\">\\(long\\ long\\)</span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">int</span> w,n,v[<span class=\"number\">10005</span>],c[<span class=\"number\">10005</span>];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> f[<span class=\"number\">10000005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;w&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;c[i]&gt;&gt;v[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=c[i];j&lt;=w;j++) f[j] = <span class=\"built_in\">max</span>(f[j],f[j-c[i]]+v[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[w]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"优化后的01背包多重背包\">优化后的01背包——多重背包</h2>\r\n<p>问题：</p>\r\n<p>给定一个容量为<span class=\"math inline\">\\(w\\)</span>的背包，有<span\r\nclass=\"math inline\">\\(n\\)</span>种物品，每种物品都有一个价值<span\r\nclass=\"math inline\">\\(v\\)</span>和一个体积<span\r\nclass=\"math inline\">\\(c\\)</span>，<strong>且数量为<span\r\nclass=\"math inline\">\\(m\\)</span>个</strong>，问背包能装下的物品的最大价值和</p>\r\n<p>因为每种物品数量有限，所以无法用完全背包求解（可能会使用多于<span\r\nclass=\"math inline\">\\(m\\)</span>个物品），考虑将其转化为01背包</p>\r\n<p>最朴素的想法是把每种物品拆成<span\r\nclass=\"math inline\">\\(m\\)</span>个单独的物品，把所有的物品都单独拿出来，这样就变成了01背包问题</p>\r\n<p>但是，这样做的复杂度是<span\r\nclass=\"math inline\">\\(O(nmw)\\)</span>的，在<span class=\"math inline\">\\(n\r\n\\geq 1000\\)</span>时就跑不过了，所以要考虑优化</p>\r\n<p>由于二进制的很多特殊性质，以及对<span\r\nclass=\"math inline\">\\(log\\)</span>的谜之追求，出现了一种优化方法：二进制拆分</p>\r\n<p><del>众所周知，任何一个数都可以被表示为二进制形式</del></p>\r\n<p>例如：$ 42 = (101010)_2$</p>\r\n<p>所以，我们把这<span\r\nclass=\"math inline\">\\(m\\)</span>个物品拆成一堆二进制，例如上面的<span\r\nclass=\"math inline\">\\(42\\)</span>可以拆成<span\r\nclass=\"math inline\">\\((1)_2=1\\)</span>,<span\r\nclass=\"math inline\">\\((10)_2=2\\)</span>,<span\r\nclass=\"math inline\">\\((100)_2=4\\)</span>,<span\r\nclass=\"math inline\">\\((1000)_2=8\\)</span>,<span\r\nclass=\"math inline\">\\((10000)_2=16\\)</span>,最后剩下来一个<span\r\nclass=\"math inline\">\\(11\\)</span>。</p>\r\n<p>不难看出，前面<span\r\nclass=\"math inline\">\\(5\\)</span>个二进制可以组成<span\r\nclass=\"math inline\">\\(0 \\sim 31\\)</span>中的任何一个数，而其中的<span\r\nclass=\"math inline\">\\(32 \\sim 42\\)</span>中的所有数都可以由<span\r\nclass=\"math inline\">\\(21 \\sim 31\\)</span>加上<span\r\nclass=\"math inline\">\\(11\\)</span>得到，所以<span class=\"math inline\">\\(0\r\n\\sim 42\\)</span>中的所有数都可以由这些拆出来的数组合得到</p>\r\n<p>这样，我们可以把每个背包拆成这些物品，之后当作01背包求解，于是复杂度就降低到了<span\r\nclass=\"math inline\">\\(O(n \\log mw)\\)</span></p>\r\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P6567\">P6567\r\n买表</a></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">4e2</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,k[N],a[N],t,f[<span class=\"number\">500010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;k[i]&gt;&gt;a[i];</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> bas = k[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">30</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[i]&lt;(<span class=\"number\">1</span>&lt;&lt;j)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p=<span class=\"number\">500005</span>;p&gt;=bas;p--) <span class=\"keyword\">if</span> (f[p-bas]) f[p] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tbas&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\ta[i]-=(<span class=\"number\">1</span>&lt;&lt;j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[i])&#123;</span><br><span class=\"line\">\t\t\tbas = a[i]*k[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">500005</span>;j&gt;=bas;j--) <span class=\"keyword\">if</span> (f[j-bas]) f[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;t;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (f[t]) cout&lt;&lt;<span class=\"string\">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"融合的01背包分组背包\">融合的01背包——分组背包</h2>\r\n<p>问题：</p>\r\n<p>给你<span\r\nclass=\"math inline\">\\(n\\)</span>个物品，每个物品属于一个组，同一组中只能选择一个物品，问容量为<span\r\nclass=\"math inline\">\\(m\\)</span>的背包的最大价值</p>\r\n<p>思路：</p>\r\n<p>同一组中的所有物品都只能选一次，我们通过01背包来限制选择的次数</p>\r\n<p>同一组中的所有物品只能选一个，我们通过同一价值来避免一个组中选择多个物品</p>\r\n<p>时间复杂度：<span class=\"math inline\">\\(O(nm)\\)</span></p>\r\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1757\">P1757\r\n通天之分组背包</a></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,f[N];</span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; v[N],w[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\tw[z].<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">\t\tv[z].<span class=\"built_in\">push_back</span>(y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sz = w[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=m;j&gt;=<span class=\"number\">0</span>;j--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p=<span class=\"number\">0</span>;p&lt;sz;p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (j&gt;=w[i][p])&#123;</span><br><span class=\"line\">\t\t\t\t\tf[j] = <span class=\"built_in\">max</span>(f[j],f[j-w[i][p]]+v[i][p]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n","tags":["Knowledge","DP"]},{"title":"自建题目目录与解答","url":"/2022/01/15/%E8%87%AA%E5%BB%BA%E9%A2%98%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%8E%E8%A7%A3%E7%AD%94/","content":"<h2 id=\"tri\"><a\r\nhref=\"https://www.luogu.com.cn/problem/U198025\">Tri</a></h2>\r\n<p>首先考虑最暴力的做法，只用把所有的三角形数都枚举一遍，再看看因数数量即可，但是，假设判断了<span\r\nclass=\"math inline\">\\(q\\)</span>个三角形数，其中每个数为<span\r\nclass=\"math inline\">\\(m\\)</span>，如果<span class=\"math inline\">\\(\\sqrt\r\nm\\)</span>判断因数是否符合条件，会让总复杂度达到<span\r\nclass=\"math inline\">\\(q \\sqrt m\\)</span>级别的，这显然是无法接受的</p>\r\n<p>于是想到一个定理：</p>\r\n<p>如果一个数<span class=\"math inline\">\\(p\\)</span>能够被表示为<span\r\nclass=\"math inline\">\\(p =\r\n{a_1}^{k1}+{a_2}^{k2}+...+{a_n}^{k_n}\\)</span>，那么<span\r\nclass=\"math inline\">\\(p\\)</span>的因数个数即为<span\r\nclass=\"math inline\">\\((k_1+1)*(k_2+1)*...*(k_n+1)\\)</span>，这代表我们只需要知道一个数的所有质因数，就可以知道它的约数个数，于是总时间复杂度就被降低到了<span\r\nclass=\"math inline\">\\(O(q\\log m)\\)</span>级别的，有了很可观的改善</p>\r\n<span id=\"more\"></span>\r\n<p><span class=\"math inline\">\\(Sample \\ Code:\\)</span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1e6</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">1e6</span>,k,vis[N*<span class=\"number\">2</span>],pri[N],tot;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&gt;N || vis[i]&lt;pri[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>,coun;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot &amp;&amp; x;i++)&#123;</span><br><span class=\"line\">\t\tcoun = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%pri[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcoun++;</span><br><span class=\"line\">\t\t\tx/=pri[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt*=coun;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cnt&gt;k) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tsum+=i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">chk</span>(sum)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;sum&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>但是对于<span class=\"math inline\">\\(n\\geq\r\n1200\\)</span>，这种算法也无法在<span\r\nclass=\"math inline\">\\(1.5s\\)</span>的时限内跑完，所以还需要优化</p>\r\n<p>如何优化呢？</p>\r\n<p>因为三角形数是形为<span\r\nclass=\"math inline\">\\(p*(p+1)/2\\)</span>的数，所以这个<span\r\nclass=\"math inline\">\\(p\\)</span>必然是根号级别的，可以从这里下手</p>\r\n<p>而且易证<span class=\"math inline\">\\(p\\)</span>和<span\r\nclass=\"math inline\">\\(p+1\\)</span>是互质的，其中包含的质因数必然完全不同，所以三角形数的因数可以由<span\r\nclass=\"math inline\">\\(p\\)</span>的因数和<span\r\nclass=\"math inline\">\\(p+1\\)</span>的因数相乘得到</p>\r\n<p>可以先把一定范围内的数的因数预处理出来，之后判断时直接调用即可</p>\r\n<p>这里采用了与上一份代码类似的因数个数计算方法</p>\r\n<p><span class=\"math inline\">\\(Sample \\ Code:\\)</span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1.5e5</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">1e5</span>,k,vis[N*<span class=\"number\">2</span>],pri[N],tot,v[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&gt;N || vis[i]&lt;pri[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>,coun;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\tcoun = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%pri[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcoun++;</span><br><span class=\"line\">\t\t\tx/=pri[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt*=coun;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++) v[i] = <span class=\"built_in\">get</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i%<span class=\"number\">2</span>) ans = v[i]*v[(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = v[i/<span class=\"number\">2</span>]*v[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans&gt;k)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">1ll</span>*i*(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;Set n to a bigger value&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>但是，对于更大的<span\r\nclass=\"math inline\">\\(n\\)</span>，这种算法却出奇的慢，原因就在于<span\r\nclass=\"math inline\">\\(get\\)</span>函数中大量使用取模和除法操作，而且判断了很多不能整除的质数，最后可能还没有最简单的加法来得快</p>\r\n<p>而且一个一个累加，虽然看上去很慢，但是每一个因数都累加到了，绝无重复操作和无用操作，极大的提高了算法的效率</p>\r\n<p>这里采用尝试法，把所有因数都试出来，虽然看上去接近于<span\r\nclass=\"math inline\">\\(O(n^2)\\)</span>，但是由于每个数的平均质因数在<span\r\nclass=\"math inline\">\\(log\\)</span>级别，所以其实是接近<span\r\nclass=\"math inline\">\\(O(n*\\log n)\\)</span>再带一个大常数的（前<span\r\nclass=\"math inline\">\\(1e7\\)</span>个数的因数计算花费<span\r\nclass=\"math inline\">\\(2s\\)</span>）</p>\r\n<p><span class=\"math inline\">\\(Sample \\ Code:\\)</span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2.8e6</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">2.5e6</span>,k,v[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=i;j&lt;=N;j+=i) v[j]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&amp;<span class=\"number\">1</span>) ans = v[i]*v[(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = v[i/<span class=\"number\">2</span>]*v[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans&gt;k)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">1ll</span>*i*(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;Set n to a bigger value&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>于是，这个简短的代码就是这道题目前的最优解了，题解愉快的结束了！</p>\r\n<p>为了防止不必要的卡常，已把本题时限开到<span\r\nclass=\"math inline\">\\(2s\\)</span>，默认开启<span\r\nclass=\"math inline\">\\(O2\\)</span>优化，即使你的<span\r\nclass=\"math inline\">\\(N\\)</span>设置的不是那么微妙，也是可以轻松通过的</p>\r\n","tags":["Knowledge","Misc"]},{"title":"莫队算法初步","url":"/2022/02/09/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/","content":"<h2 id=\"莫队的基本思想\">莫队的基本思想</h2>\r\n<p>简单的莫队是针对这样一种题目：给定很多离线的询问，没有修改，而且数据范围根号算法能过。</p>\r\n<p>一般的算法都是对单次查询过程进行优化，但莫队对询问进行了优化：</p>\r\n<span id=\"more\"></span>\r\n<p>把询问可能出现的区间分成<span class=\"math inline\">\\(\\sqrt\r\nn\\)</span>个块，再将询问排序，具体规则是先对左端点所在的块排序，如果左端点在同一块中，就对右端点升序排序。</p>\r\n<p>这样，我们把排序好的询问一个个计算，定义<span\r\nclass=\"math inline\">\\(L\\)</span>为当前左端点，<span\r\nclass=\"math inline\">\\(R\\)</span>为当前右端点，处理每个询问时把左端点和右端点都移动到当前询问的左、右端点处，移动时用<span\r\nclass=\"math inline\">\\(O(1)\\)</span>或接近的时间复杂度维护<span\r\nclass=\"math inline\">\\(L\\)</span>和<span\r\nclass=\"math inline\">\\(R\\)</span>之间的答案，移动好时，这个询问对应的答案就成了<span\r\nclass=\"math inline\">\\(L\\)</span>和<span\r\nclass=\"math inline\">\\(R\\)</span>之间的答案。</p>\r\n<p>但是莫队为什么快呢？因为对于每个块中的询问，左端点都是在这个块中活动<span\r\nclass=\"math inline\">\\(q\\)</span>次询问可能会卡成<span\r\nclass=\"math inline\">\\(q \\times \\sqrt\r\nn\\)</span>，假设每个询问都倍卡，左端点移动的复杂度最大就是<span\r\nclass=\"math inline\">\\(O(q \\times \\sqrt\r\nn)\\)</span>。再看右端点，如果每个块中右端点都从这个块的起点移动到了最后一个块的终点，右端点移动的复杂度最大就是<span\r\nclass=\"math inline\">\\(O(n \\times \\sqrt n)\\)</span>。如果<span\r\nclass=\"math inline\">\\(L\\)</span>和<span\r\nclass=\"math inline\">\\(R\\)</span>移动的代价为<span\r\nclass=\"math inline\">\\(w\\)</span>，总共的复杂度最大就是<span\r\nclass=\"math inline\">\\(O(w \\times (n+q) \\times \\sqrt n)\\)</span>。</p>\r\n<h3 id=\"例题\">例题</h3>\r\n<p><a href=\"https://www.luogu.com.cn/problem/P2709\">P2709\r\n小B的询问</a></p>\r\n<p><a href=\"http://zhengruioi.com/contest/966/problem/1992\">ZROI\r\n奇数</a></p>\r\n<p><a href=\"https://www.luogu.com.cn/problem/SP3267\">SP3267\r\nDQUERY</a></p>\r\n<p><a href=\"https://www.luogu.com.cn/problem/CF86D\">CF86D Powerful\r\narray</a></p>\r\n<p>To be added.</p>\r\n<h2 id=\"带修莫队\">带修莫队</h2>\r\n","tags":["Knowledge","分块"]}]