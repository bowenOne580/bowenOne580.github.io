[{"title":"Blog is open now!","url":"/2022/01/24/Blog-is-open-now/","content":"<h2\r\nid=\"博客迁移已完成之后的东西大概都在这里写了\">博客迁移已完成，之后的东西大概都在这里写了</h2>\r\n<p>由于多重原因，洛谷博客据说要没了，昨晚考虑把博客迁移到这里来，经过一中午和一下午的努力，博客迁移工作终于完成了，之后的东西就都在这里写吧。</p>\r\n<p><a href=\"https://imgtu.com/i/7TSqln\"><img\r\nsrc=\"https://s4.ax1x.com/2022/01/24/7TSqln.png\" alt=\"截图\" /></a></p>\r\n","tags":["Life"]},{"title":"NOIP2021 Journal","url":"/2021/11/20/NOIP2021-Journal/","content":"<p>人生中第一场NOIP，就这样落幕了</p>\r\n<h1 id=\"day--1\">Day -1</h1>\r\n<p>随便打了几个板子，发现没有什么需要复习的，因为所学实在太少，心态也十分放松，大概是知道自己状态不好，在短时间内也无法挽救，不会的知识实在太多，而能熟练运用的又太少，感觉再做什么也无济于事了。</p>\r\n<p><del>于是看了Person Of Interest Season\r\n4，突然很想写一个能和我对话、保护我、洞悉世事的程序</del></p>\r\n<p>是的，考试的前一天就这样平凡地过去了</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"day-1\">Day 1</h1>\r\n<p>大概7：50就进了考场，找到自己的座位，却发现电脑没开。于是自行打开，却发现有两个Windows10？等了一会，老师说用第二个，于是不那么顺利地进入了系统。</p>\r\n<p>先把缺省源打了，之后打了个对拍器，发现没关同步，于是加了两行代码到缺省源里，设置了编译选项，准备工作完成。</p>\r\n<p>大概在打完后不就，发现试卷的密码在大屏幕上，好像是IronHeart之类的（<del>钢铁雄心？？？</del>），难道出题人是Paradox玩家？但是没时间想那么多了，解压完成后就立刻打开了试题。</p>\r\n<p>照例先开第一题，发现题目说的东西很奇怪，而且数据范围也并非线性：<span\r\nclass=\"math inline\">\\(1e7\\)</span>，这<span\r\nclass=\"math inline\">\\(O(nlogn)\\)</span>都有点悬，不会要<span\r\nclass=\"math inline\">\\(O(n)\\)</span>吧，但是这样也小了个七八倍，反正就很奇怪。</p>\r\n<p>之后仔细看了下题，发现只要把每一个符合条件的数的倍数都标记一遍就行了？（好像这便是著名的<span\r\nclass=\"math inline\">\\(O(nlogn)\\)</span>算法）</p>\r\n<p>但是我觉得题目肯定不会这么简单，这样写肯定是要被卡的，于是研究了很久的性质，发现只要标记一个符合条件的数的质数倍就行了，因为合数肯定可以表示为若干个质数的乘积。</p>\r\n<p>但是即使这样写，也可能有TLE的风险，因为这样筛并不是绝对线性的，例如<strong>宇宙所有问题的终极答案<span\r\nclass=\"math inline\">\\(42\\)</span></strong>，它既可以表示成<span\r\nclass=\"math inline\">\\(14\\times3 =\r\n7\\times2\\times3\\)</span>，也可以表示成<span\r\nclass=\"math inline\">\\(21\\times2 = 7\\times3\\times2\\)</span>，这样数<span\r\nclass=\"math inline\">\\(42\\)</span>就被标记了两次，显然还有更多这样的数，所以这样做就不是线性的</p>\r\n<p>如何让每个数只被标记一次呢？其实也很显然：只要一个数的倍数被分解为的质因数中最小的数小于等于要乘的质数，就行了，因为满足倍数被分解为若干个不降的质数的情况只有一种。很好，这样就是完全线性的了！</p>\r\n<p>但是我没想到的是，由于还要用一遍<span\r\nclass=\"math inline\">\\(Euler\\)</span>筛筛出所有的质数，所以复杂度是两个<span\r\nclass=\"math inline\">\\(O(n)\\)</span>的，实测跑的比广为流传的<span\r\nclass=\"math inline\">\\(O(nlogn)\\)</span>算法还要慢。。。</p>\r\n<p>由于各种意想不到的<span class=\"math inline\">\\(bug\\)</span>，过了<span\r\nclass=\"math inline\">\\(1.5h\\)</span>才打完T1且开拍了</p>\r\n<p>算了，反正T1写完了，按理说要看T2了，于是我就看了。</p>\r\n<p>第一眼是一个以<span\r\nclass=\"math inline\">\\(m+1\\)</span>为指数的暴力，开心地在<span\r\nclass=\"math inline\">\\(30min\\)</span>左右写完了，发现样例2要跑<span\r\nclass=\"math inline\">\\(11s\\)</span>？感觉再优化也没什么希望了，就暂时放下了，开T3</p>\r\n<p>T3一看，就想到了ZROI上的一道题，然而看了好久，发现其本质不是一个东西，拿前缀和推也没啥性质，而且这个序列可能可以无限操作下去，很难有重复的情况，推了一堆没有用的东西，发现只剩下<span\r\nclass=\"math inline\">\\(1.5h\\)</span>左右了，以我的水平顶多打几个暴力走人，于是看了眼T4，发现没啥希望，跟斗地主一样恶心，就回去看T2了</p>\r\n<p>突然发现这样搜索搜到了很多重复的情况，很明显是不优的，如果改成枚举每一位选了多少个，就可以用排列乘出所有的情况，复杂度有了小小的改善，于是开写</p>\r\n<p>写完之后，发现乘那个权值时__int128爆了，于是开始写高精，发现不会<span\r\nclass=\"math inline\">\\(log\\)</span>的取模，于是把写了<span\r\nclass=\"math inline\">\\(45min\\)</span>的高精代码删了，又改成__int128，感觉没啥希望了，于是写T3的暴力</p>\r\n<p>T3由于不知道要操作多少次，就找了一个有可能过<span\r\nclass=\"math inline\">\\(n&lt;=10\\)</span>的点且不超时的<span\r\nclass=\"math inline\">\\(9\\)</span>次放进去了，发现第二个样例都过不了，此时离考试结束只有<span\r\nclass=\"math inline\">\\(30min\\)</span>不到了，于是把考生须知填了，之后开始打坐。</p>\r\n<p>所有程序的文件名检查完之后，又看了一眼题面，试图找到一点思路，突然发现T2说的是小于等于<span\r\nclass=\"math inline\">\\(k\\)</span>，草！</p>\r\n<p>于是疯狂改，再边乘边取模，最后竟然过了样例2？很满意</p>\r\n<p>打铃，收卷，结束。</p>\r\n<p>是的，我的第一场NOIP就这样结束了，内心毫无波澜的提交了文件夹，看见人均200+，虽有失望，可是并没有为此懊恼，因为有那么多没学的，有那么多不会的<span\r\nclass=\"math inline\">\\(trick\\)</span>，这也很公平。</p>\r\n<p>停课结束后，又要投入到紧张的<span\r\nclass=\"math inline\">\\(whk\\)</span>学习中，虽然有那么多不会的，那又如何呢，总是要补的。</p>\r\n<p>其实，生活中许多不如意，是你欠你自己的，付出与回报不会成正比，但是要回报，必须付出些什么，而最不必的便是为这些付出懊恼，你欠的，总是要还回来的嘛。</p>\r\n<blockquote>\r\n<p>This is my final fit</p>\r\n<p>My final bellyache with</p>\r\n<p>No alarms and no surprises</p>\r\n<p>No alarms and no surprises please</p>\r\n</blockquote>\r\n","tags":["Life"]},{"title":"Counting Swaps 题解","url":"/2022/04/11/Counting-Swaps-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"counting-swaps-题解\">Counting Swaps 题解</h1>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<p>我们得到的序列是<span class=\"math inline\">\\(p_1,p_2\\cdots\r\np_n\\)</span>，如果从每个<span class=\"math inline\">\\(i\\)</span>向<span\r\nclass=\"math inline\">\\(p_j=i\\)</span>的<span\r\nclass=\"math inline\">\\(j\\)</span>连一条边，那么我们的目标就是使这个图中存在<span\r\nclass=\"math inline\">\\(n\\)</span>个自环。</p>\r\n<h3 id=\"观察题目得到猜想\">观察题目，得到猜想</h3>\r\n<span id=\"more\"></span>\r\n<p><strong>结论1：这个图必然由若干个环构成。</strong></p>\r\n<p>由于点<span class=\"math inline\">\\(i\\)</span>连向<span\r\nclass=\"math inline\">\\(p_j=i\\)</span>的<span\r\nclass=\"math inline\">\\(j\\)</span>和<span\r\nclass=\"math inline\">\\(p_i\\)</span>，所以每个点必然连接着两条边。如果图中有不是环的东西，那么必然存在一个点，其只有一条出边，这与每个点都连接两条边矛盾，所以原命题成立。</p>\r\n<p><strong>思考1：交换<span class=\"math inline\">\\(p_i\\)</span>和<span\r\nclass=\"math inline\">\\(p_j\\)</span>会对原图产生什么影响？</strong></p>\r\n<p>之前连向<span class=\"math inline\">\\(p_i\\)</span>的是<span\r\nclass=\"math inline\">\\(p_q=i\\)</span>的<span\r\nclass=\"math inline\">\\(q\\)</span>和编号为<span\r\nclass=\"math inline\">\\(p_i\\)</span>的点。</p>\r\n<p>显然，根据连边的规则，从编号为<span\r\nclass=\"math inline\">\\(p_i\\)</span>的点连向<span\r\nclass=\"math inline\">\\(j\\)</span>的边不会改变，但是另一条边变成了从<span\r\nclass=\"math inline\">\\(p_{q&#39;}=j\\)</span>连向<span\r\nclass=\"math inline\">\\(p_i\\)</span>的边。</p>\r\n<p>另一个点连接的两个点分别是编号为<span\r\nclass=\"math inline\">\\(p_j\\)</span>和<span\r\nclass=\"math inline\">\\(p_{q&#39;&#39;}=i\\)</span>。</p>\r\n<p>其实手动模拟一下可能会更清晰。</p>\r\n<p>这样，这两个点就交换了各自的一条边，形成了两个环。</p>\r\n<p>形式化的说，如果原来的环是<span class=\"math inline\">\\(v_1\\rightarrow\r\nv_2\\cdots v_n\\to v_1\\)</span>，交换<span\r\nclass=\"math inline\">\\(i,j\\)</span>（令<span\r\nclass=\"math inline\">\\(i&lt;j\\)</span>）之后的环就变成了<span\r\nclass=\"math inline\">\\(v_i\\to v_{i+1}\\cdots v_j\\to v_i\\)</span>和<span\r\nclass=\"math inline\">\\(v_1\\to v_2\\cdots v_i\\to v_{j+1}\\cdots v_n\\to\r\nv_1\\)</span>。</p>\r\n<p>得到结论：在一个长度为<span\r\nclass=\"math inline\">\\(n\\)</span>的环内交换<span\r\nclass=\"math inline\">\\(i,j\\)</span>，会变成两个长度为<span\r\nclass=\"math inline\">\\(j-i\\)</span>和<span\r\nclass=\"math inline\">\\(n-j+i\\)</span>的环。</p>\r\n<p><strong>结论2：将一个包含<span\r\nclass=\"math inline\">\\(m\\)</span>个点的环拆成<span\r\nclass=\"math inline\">\\(m\\)</span>个自环，最少需要<span\r\nclass=\"math inline\">\\(m-1\\)</span>次操作。</strong></p>\r\n<p>用数学归纳法证明。</p>\r\n<p>在<span\r\nclass=\"math inline\">\\(m=1\\)</span>时，自己本身就是自环了，不用拆，需要<span\r\nclass=\"math inline\">\\(1-1 = 0\\)</span>次操作。</p>\r\n<p>假设对于任意<span class=\"math inline\">\\(i\\in\r\n[1,m-1]\\)</span>，都只需要<span\r\nclass=\"math inline\">\\(m-1\\)</span>次操作，那么对于一个长度为<span\r\nclass=\"math inline\">\\(m\\)</span>的环，我们可以</p>\r\n<p>任取两个点<span\r\nclass=\"math inline\">\\(i,j\\)</span>，交换它们，根据思考1，环将变成<span\r\nclass=\"math inline\">\\(j-i\\)</span>和<span\r\nclass=\"math inline\">\\(m-j+i\\)</span>两个环。</p>\r\n<p>而将这两个环拆成自环需要<span class=\"math inline\">\\(j-i-1+m-j+i-1 =\r\nm-2\\)</span>次操作，加上交换<span\r\nclass=\"math inline\">\\(i,j\\)</span>这一次操作，总共需要<span\r\nclass=\"math inline\">\\(m-1\\)</span>次操作。</p>\r\n<p>于是，原命题成立。</p>\r\n<h3 id=\"进一步思考\">进一步思考</h3>\r\n<p>现在，我们已经知道了最小的次数是<span\r\nclass=\"math inline\">\\(n-\\)</span>环的个数，要求总共有多少种交换的方法能够达到这个次数。</p>\r\n<p>设<span\r\nclass=\"math inline\">\\(F_n\\)</span>表示用最少的次数将一个长度为<span\r\nclass=\"math inline\">\\(n\\)</span>的环变为<span\r\nclass=\"math inline\">\\(n\\)</span>个自环的方案数，根据思考1和结论2，我们可以把这个环拆成大小为<span\r\nclass=\"math inline\">\\(x\\)</span>和<span\r\nclass=\"math inline\">\\(y\\)</span>的两个环，设<span\r\nclass=\"math inline\">\\(T_(x,y)\\)</span>表示有多少种方法拆成大小为<span\r\nclass=\"math inline\">\\(x\\)</span>和<span\r\nclass=\"math inline\">\\(y\\)</span>的两个环：</p>\r\n<p>当<span class=\"math inline\">\\(x=y\\)</span>时，<span\r\nclass=\"math inline\">\\(T(x,y) = n/2\\)</span>，从<span\r\nclass=\"math inline\">\\(i\\)</span>和<span\r\nclass=\"math inline\">\\(i+x\\)</span>切没有区别。</p>\r\n<p>当<span class=\"math inline\">\\(x\\neq y\\)</span>时，<span\r\nclass=\"math inline\">\\(T(x,y) = n\\)</span>，在任意一个点<span\r\nclass=\"math inline\">\\(i\\)</span>切都是不同的方案。</p>\r\n<p>于是，<span class=\"math inline\">\\(F_n = \\sum T(x,y)\\cdot F_x\\cdot\r\nF_y\\cdot \\frac{(n-2)!}{(x-1)!\\cdot (y-1)!}\\)</span>。</p>\r\n<p>最后乘的那个东西可以看作有<span\r\nclass=\"math inline\">\\(x\\)</span>个0和<span\r\nclass=\"math inline\">\\(y\\)</span>个1的排列数，直接用多重集的排列数计算即可。</p>\r\n<p>至于为啥<span\r\nclass=\"math inline\">\\(x\\)</span>个0都是相同的，因为区分操作的情况在计算<span\r\nclass=\"math inline\">\\(F_x\\)</span>的时候就已经计算过了，所以这里可以把它们当成相同的。</p>\r\n<p>因为每个自环计算方案是独立的，所以我们要把所有的方案数乘起来，再像上面一样乘一个多重集的排列数：</p>\r\n<p><span class=\"math inline\">\\(ans = F_{l_1}\\cdot F_{l_2}\\cdots\r\nF_{l_k}\\cdot \\frac{(n-k)!}{(l_1-1)!\\cdot (l_2-1)! \\cdots\r\n(l_k-1)!}\\)</span>。</p>\r\n<p>这样，我们可以<span\r\nclass=\"math inline\">\\(O(n^2)\\)</span>推出所有我们需要的<span\r\nclass=\"math inline\">\\(F_i\\)</span>值，之后乘起来，加个乘法逆元，总复杂度为<span\r\nclass=\"math inline\">\\(O(n^2\\log n)\\)</span>。</p>\r\n<p>之后好像就没法优化了，除非你把<span\r\nclass=\"math inline\">\\(F_i\\)</span>的前几项放到OEIS上去。。。</p>\r\n<p>于是，我们借助网络得到<span\r\nclass=\"math inline\">\\(F_i\\)</span>的通向公式：<span\r\nclass=\"math inline\">\\(F_i = i^{i-2}\\)</span>，这样复杂度就变成了<span\r\nclass=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\r\n<h2 id=\"总结\">总结</h2>\r\n<p>总之，这是一道非常不错（毒瘤）的组合入门题（至少<a\r\nhref=\"https://www.luogu.com.cn/discuss/53018\">小粉兔是这么说的</a>），考察了对加法原理和乘法原理的理解、数学归纳法的使用、多重集的排列数的了解，需要一定的猜测和证明能力，组合数学的基础才能完全理解。</p>\r\n<h2 id=\"code\"><span class=\"math inline\">\\(Code\\)</span></h2>\r\n<p>要在处理所有询问之前把<span\r\nclass=\"math inline\">\\(F_i\\)</span>和阶乘预处理出来，这样复杂度才是对的。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,p = <span class=\"number\">1e9</span>+<span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> t,n,a[N],head[N],tot,l[N],cnt,vis[N],jie[N],f[N];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">e</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> p)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ans = ans*bas%p;</span><br><span class=\"line\">\t\tbas = bas*bas%p;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tf[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=<span class=\"number\">100000</span>;i++) f[i] = <span class=\"built_in\">ksm</span>(i,i<span class=\"number\">-2</span>,p);</span><br><span class=\"line\">\tjie[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">100000</span>;i++) jie[i] = jie[i<span class=\"number\">-1</span>]*i%p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\tvis[x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tl[cnt]++;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[v]) <span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)*(n+<span class=\"number\">100</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(l,<span class=\"number\">0</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)*(n+<span class=\"number\">100</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>)*(n+<span class=\"number\">100</span>));</span><br><span class=\"line\">\t\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(a[i],i);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(i,a[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\t\tcnt++;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">dfs</span>(i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>,num = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class=\"line\">\t\t\tans*=f[l[i]];</span><br><span class=\"line\">\t\t\tans%=p;</span><br><span class=\"line\">\t\t\tnum*=jie[l[i]<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t\tnum%=p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans*=jie[n-cnt]*<span class=\"built_in\">ksm</span>(num,p<span class=\"number\">-2</span>,p)%p;</span><br><span class=\"line\">\t\tans%=p;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["Knowledge","数学","组合数学"]},{"title":"P2261 余数求和 题解","url":"/2022/04/01/P2261-%E4%BD%99%E6%95%B0%E6%B1%82%E5%92%8C-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"p2261-余数求和-题解\">P2261 余数求和 题解</h1>\r\n<h2 id=\"前言\">前言</h2>\r\n<p>好像每次看到这个题都挺懵的，思路不太好想。</p>\r\n<h2 id=\"题目大意\">题目大意</h2>\r\n<p>给定<span class=\"math inline\">\\(n\\)</span>和<span\r\nclass=\"math inline\">\\(k\\)</span>，求出<span class=\"math inline\">\\(k \\\r\nmod \\ 1+k \\ mod \\ 2+ \\cdot \\cdot \\cdot k \\ mod \\ n\\)</span>。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<p>这个东西看上去就不太能直接求。</p>\r\n<p>我们既然不能一眼看出怎么求，那就多看几眼。</p>\r\n<p><span class=\"math inline\">\\(k \\ mod \\ i = k-\\lfloor k/i \\rfloor \\cdot\r\ni\\)</span></p>\r\n<p>这样，我们要求的东西就变成了：<span class=\"math inline\">\\(k \\cdot n -\r\n\\sum_{i=1}^{n} \\lfloor k/i \\rfloor \\cdot i\\)</span></p>\r\n<p>这个<span class=\"math inline\">\\(\\lfloor k/i\r\n\\rfloor\\)</span>显然在<span\r\nclass=\"math inline\">\\(i\\)</span>更大时变化的几率会越来越小，我们想一想怎么把它变化的规律找出来。</p>\r\n<p>（事实上，这个好像是数论分块里的内容，只能说：见多识广啊）</p>\r\n<p>我们凭空捏造一个函数<span class=\"math inline\">\\(g(x) = \\lfloor\r\nk/\\lfloor k/x \\rfloor \\rfloor\\)</span>。</p>\r\n<p><span class=\"math inline\">\\(f(x) =\r\nk/x\\)</span>是单调递减的，所以<span\r\nclass=\"math inline\">\\(g(x)\\geq\\lfloor k/(k/x) \\rfloor =\r\nx\\)</span>，所以<span class=\"math inline\">\\(\\lfloor k/g(x) \\rfloor \\leq\r\n\\lfloor k/x \\rfloor\\)</span>。</p>\r\n<p>又因为<span class=\"math inline\">\\(\\lfloor k/g(x) \\rfloor \\geq \\lfloor\r\nk/(k/\\lfloor k/x \\rfloor) \\rfloor = \\lfloor k/x\r\n\\rfloor\\)</span>，所以<span class=\"math inline\">\\(\\lfloor k/g(x) \\rfloor\r\n= \\lfloor k/x \\rfloor\\)</span>。</p>\r\n<p>所以，对于任意<span class=\"math inline\">\\(i \\in [x,\\lfloor k/ \\lfloor\r\nk/x \\rfloor \\rfloor]\\)</span>，<span class=\"math inline\">\\(\\lfloor k/i\r\n\\rfloor\\)</span>都相等。</p>\r\n<p>而且，每个数都必然属于所有区间中的一个，所以我们可以枚举左右端点，里面的<span\r\nclass=\"math inline\">\\(\\lfloor k/i \\rfloor \\cdot\r\ni\\)</span>就是等差数列求和。</p>\r\n<p>由于在<span class=\"math inline\">\\(\\sqrt{k}\\)</span>以内的<span\r\nclass=\"math inline\">\\(i\\)</span>，最多有<span\r\nclass=\"math inline\">\\(\\sqrt{k}\\)</span>个<span\r\nclass=\"math inline\">\\(\\lfloor k/i\r\n\\rfloor\\)</span>，所以这个式子的取值最多有<span\r\nclass=\"math inline\">\\(\\sqrt{k}\\)</span>种，而在<span\r\nclass=\"math inline\">\\(\\sqrt{k}\\)</span>以外的<span\r\nclass=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\(k/i\\leq\r\n\\sqrt{k}\\)</span>，所以这个式子最多也有<span\r\nclass=\"math inline\">\\(\\sqrt{k}\\)</span>种取值，那么对于所有的<span\r\nclass=\"math inline\">\\(i\\)</span>，最多只有<span\r\nclass=\"math inline\">\\(2\\sqrt{k}\\)</span>种取值，所以整个算法的时间复杂度为<span\r\nclass=\"math inline\">\\(O(\\sqrt{k})\\)</span>。</p>\r\n<p><span class=\"math inline\">\\(Code\\)</span>：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,k;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> r,ans = n*k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> l=<span class=\"number\">1</span>;l&lt;=n;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (k/l == <span class=\"number\">0</span>) r = n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = <span class=\"built_in\">min</span>(k/(k/l),n);</span><br><span class=\"line\">\t\tans-=(r-l+<span class=\"number\">1</span>)*(k/l*l+k/l*r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["Knowledge","数学"]},{"title":"P3959 宝藏 题解","url":"/2022/03/28/P3959-%E5%AE%9D%E8%97%8F-%E9%A2%98%E8%A7%A3/","content":"<h2 id=\"题目大意\">题目大意</h2>\r\n<p>给出一个<span class=\"math inline\">\\(n\\)</span>个节点，<span\r\nclass=\"math inline\">\\(m\\)</span>条边的图，你可以选定一个节点，从这个节点开始遍历整个图，其中每走到一条新的边，就要花费<span\r\nclass=\"math inline\">\\(l*k\\)</span>的代价，其中<span\r\nclass=\"math inline\">\\(l\\)</span>是这条边的边权，<span\r\nclass=\"math inline\">\\(k\\)</span>是从你选定的点到这条边的起点经过的宝藏屋的数量。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<h3 id=\"一些初步的想法\">一些初步的想法</h3>\r\n<p>没有啥思路就直接暴搜。</p>\r\n<p>首先要枚举选择的起点，还要枚举选择的边，形式化的说，给每个边都定一个访问顺序，如果不访问就设为<span\r\nclass=\"math inline\">\\(0\\)</span>，每个点都有<span\r\nclass=\"math inline\">\\(n+1\\)</span>种选择，复杂度大概是<span\r\nclass=\"math inline\">\\(O(m^n)\\)</span>的，啥都过不了。</p>\r\n<p>于是考虑优化。</p>\r\n<p>选定的边组成的必然是一棵树，这样才能使代价最小，而对于同一棵树而言，节点的选择顺序不会对答案有影响，所以我们可以枚举树，计算每个树的答案。枚举的过程是从<span\r\nclass=\"math inline\">\\(m\\)</span>条边中选择<span\r\nclass=\"math inline\">\\(n-1\\)</span>条，复杂度是<span\r\nclass=\"math inline\">\\(m\\cdot(m-1)\\cdot (m-2) \\cdot \\cdot \\cdot\r\n(m-n+1)\\)</span>，计算每个树的答案可以直接换根dp解决，复杂度是<span\r\nclass=\"math inline\">\\(O(n)\\)</span>的，这时，复杂度已经有了明显的改善。</p>\r\n<p>还有没有优化空间呢？有。</p>\r\n<p>因为我们是随便找出的<span\r\nclass=\"math inline\">\\(n-1\\)</span>条边，它们不一定能构成树，而且题目里面有重边，显然我们只用选一个长度最小的就行了，这样边最多是<span\r\nclass=\"math inline\">\\(66\\)</span>条，复杂度明显降低了。</p>\r\n<p>但是这里的<span class=\"math inline\">\\(n\\)</span>和<span\r\nclass=\"math inline\">\\(m\\)</span>依旧不是一个量级的，我们能不能用<span\r\nclass=\"math inline\">\\(n\\)</span>作为复杂度呢？</p>\r\n<p>我们直接搜索，重复状态很多，同一张图，选择不同的根，就会有<span\r\nclass=\"math inline\">\\(n\\)</span>种状态，而我们用这个图转移到下一个图，只用从其中最小的状态转移，这样就减少了很多重复计算。</p>\r\n<p>既然状态有很多重复的，但是状态空间并不大，我们可以考虑使用<strong>状压DP</strong>优化。</p>\r\n<h3 id=\"一种错误的解法\">一种错误的解法</h3>\r\n<p>设点<span class=\"math inline\">\\(i\\)</span>被选择为<span\r\nclass=\"math inline\">\\(1\\)</span>，不被选择为<span\r\nclass=\"math inline\">\\(0\\)</span>，这样我们可以表示在每个阶段中的状态。</p>\r\n<p>设<span\r\nclass=\"math inline\">\\(f[i]\\)</span>表示压缩后的点的选择情况，我们枚举每个没有被选择，且能从已经被选择的其中一个点到达的点，选择一条路径到达那个点，这样就可以计算出要转移到的状态和最小值，如果存在一个更优解，就从这个状态继续转移。</p>\r\n<p>但是，一定是在有更优解的时候才会转移吗？</p>\r\n<p>如果一个点的深度比较小，但是这个点连向下一个点的边权比较大，我们可能会因为它转移到下一个状态时不是最优解而不再转移，但是如果让它继续转移下去，下面的点之间的边权较小，就有可能因为它的深度获益，这样可能会达到一个更优的解。</p>\r\n<p>所以，我认为这样做是错误的。</p>\r\n<p>据cyh大佬说，这是因为在同一个状态<span\r\nclass=\"math inline\">\\(s\\)</span>中可能有一个点的深度不同，那么就不知道用哪个深度转移是最优的。</p>\r\n<h3 id=\"正确解法\">正确解法</h3>\r\n<p>上面算法的错误在于没有限定深度，导致不同深度的时候转移不完全，我们其实可以限定一个当前的最大深度，之后把所有位于最大深度的点转移。</p>\r\n<p>设<span class=\"math inline\">\\(f[i][j]\\)</span>表示在最大深度为<span\r\nclass=\"math inline\">\\(i\\)</span>，选择状态为<span\r\nclass=\"math inline\">\\(j\\)</span>时的最小花费，那么<span\r\nclass=\"math inline\">\\(f[i][j] = max(f[i][j],f[i-1][k]+(i-1)\\cdot\r\ncost(j,k))\\)</span>。</p>\r\n<p>我们先判断上一个状态的合法性：</p>\r\n<p>首先，这个状态要被转移过，否则转移它也没啥用，所以<span\r\nclass=\"math inline\">\\(f[i-1][k]\\)</span>不等于初始值。</p>\r\n<p>其次，这个状态要满足从<span\r\nclass=\"math inline\">\\(k\\)</span>能转移到<span\r\nclass=\"math inline\">\\(j\\)</span>，这时就要考虑两个限制：</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(k\\)</span>是<span\r\nclass=\"math inline\">\\(j\\)</span>的一个子集，因为状态转移，选择的点只增不减。</li>\r\n<li><span class=\"math inline\">\\(j\\)</span>是<span\r\nclass=\"math inline\">\\(expand(k)\\)</span>的一个子集，<span\r\nclass=\"math inline\">\\(expand(k)\\)</span>表示从<span\r\nclass=\"math inline\">\\(k\\)</span>中已经选择的所有点往深度为<span\r\nclass=\"math inline\">\\(i\\)</span>的点扩展，能够扩展到的所有点，则<span\r\nclass=\"math inline\">\\(j\\)</span>必然在能够扩展到的点集内。</li>\r\n</ol>\r\n<p>我们再考虑如何计算扩展所需的花费<span\r\nclass=\"math inline\">\\(cost(j,k)\\)</span>。</p>\r\n<p>先要找到所有被扩展的点，这个可以通过<span class=\"math inline\">\\(j\r\n\\oplus k\\)</span>计算出来。</p>\r\n<p>还要知道每个点被扩展所需的最小花费，由于每个<span\r\nclass=\"math inline\">\\(k\\)</span>中的点深度都为<span\r\nclass=\"math inline\">\\(i-1\\)</span>，所以到要扩展的点的经过的宝藏屋的数量是一样的，我们只用考虑路径长度就行了，而路径长度可以通过之前的<span\r\nclass=\"math inline\">\\(expand(k)\\)</span>计算，即将所有能连向要扩展的点的路径长度取min。</p>\r\n<p>这样我们就完成了最重要的一步<strong>状态转移</strong>。</p>\r\n<p>之后就是初始化了，对于所有<span class=\"math inline\">\\(x \\in\r\n[1,n]\\)</span>，<span class=\"math inline\">\\(f[1][(1&lt;&lt;x)] =\r\n0\\)</span>，因为是赞助商免费打通的，不需要费用，其他的都没有被转移，为了避免转移不合法的状态，其他的都设为<span\r\nclass=\"math inline\">\\(+ \\infty\\)</span>。</p>\r\n<p>但是这样做，复杂度还不是最优的，因为<span\r\nclass=\"math inline\">\\(expand\\)</span>和<span\r\nclass=\"math inline\">\\(cost\\)</span>函数都会被重复计算很多次，我们可以预处理出来。</p>\r\n<p>时间复杂度：<span class=\"math inline\">\\(O(n3^n+m2^n)\\)</span>。</p>\r\n<h2 id=\"code\">Code</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">25</span>,M = (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,edge[N][N],f[N][M],valid[M][M],cost[M][M],road[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">expand</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123; <span class=\"comment\">//复杂度为O(n^2) </span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> exp = i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p=<span class=\"number\">0</span>;p&lt;n;p++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;p)&amp;i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> q=<span class=\"number\">0</span>;q&lt;n;q++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (((<span class=\"number\">1</span>&lt;&lt;q)&amp;i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[p][q]&lt;=<span class=\"number\">10000000</span>)&#123;</span><br><span class=\"line\">\t\t\t\troad[q] = <span class=\"built_in\">min</span>(road[q],edge[p][q]);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;q)&amp;exp)) exp+=(<span class=\"number\">1</span>&lt;&lt;q);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> exp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//这里枚举顺序换一下会有优化效果，但是我喜欢在里面算exp，所以就不改了 </span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123; <span class=\"comment\">//之前的集合</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(road,<span class=\"number\">0x3f</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(road));</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> exp = <span class=\"built_in\">expand</span>(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;n);j++)&#123; <span class=\"comment\">//转移的集合</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((i&amp;j) == i &amp;&amp; (exp&amp;j) == j)&#123; <span class=\"comment\">//合法</span></span><br><span class=\"line\">\t\t\t\tvalid[i][j] = <span class=\"number\">1</span>; </span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p=<span class=\"number\">0</span>;p&lt;n;p++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ((j&amp;(<span class=\"number\">1</span>&lt;&lt;p)) &amp;&amp; !(i&amp;(<span class=\"number\">1</span>&lt;&lt;p))) cost[i][j]+=road[p];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(edge,<span class=\"number\">0x3f</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(edge));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\tx--;</span><br><span class=\"line\">\t\ty--;</span><br><span class=\"line\">\t\tedge[x][y] = <span class=\"built_in\">min</span>(edge[x][y],z);</span><br><span class=\"line\">\t\tedge[y][x] = <span class=\"built_in\">min</span>(edge[y][x],z);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(f));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) f[<span class=\"number\">1</span>][<span class=\"number\">1</span>&lt;&lt;i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123; <span class=\"comment\">//枚举深度 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;n);j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p=<span class=\"number\">0</span>;p&lt;(<span class=\"number\">1</span>&lt;&lt;n);p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (valid[j][p] &amp;&amp; f[i<span class=\"number\">-1</span>][j]&lt;=<span class=\"number\">100000000</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tf[i][p] = <span class=\"built_in\">min</span>(f[i][p],f[i<span class=\"number\">-1</span>][j]+(i<span class=\"number\">-1</span>)*cost[j][p]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Min = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) Min = <span class=\"built_in\">min</span>(Min,f[i][(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\tcout&lt;&lt;Min&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["Knowledge","DP"]},{"title":"P4662黑手党题解","url":"/2022/03/19/P4662%E9%BB%91%E6%89%8B%E5%85%9A%E9%A2%98%E8%A7%A3/","content":"<h2 id=\"题目大意\">题目大意</h2>\r\n<p>给一个有 <span class=\"math inline\">\\(n\\)</span> 个点和 <span\r\nclass=\"math inline\">\\(m\\)</span> 条边的图，现在给定一个源点 <span\r\nclass=\"math inline\">\\(a\\)</span> ，一个汇点 <span\r\nclass=\"math inline\">\\(b\\)</span>\r\n和去掉每个点所需的费用，求出需要去掉哪些点，使 <span\r\nclass=\"math inline\">\\(a\\)</span> 和 <span\r\nclass=\"math inline\">\\(b\\)</span> 不再连通的费用最小。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<p>我们发现，只要把点变成边，边权设为去掉这个点的费用，就变成了求一个网络的最小割，即最大流，于是考虑通过Dinic算法求出最大流。</p>\r\n<p>我们用拆点解决将点变成边的问题。首先，原来图中就有的边，是不允许去掉的，所以我们要保证它不会被割掉，将其边权设为正无穷。对于图中的点，我们可以把一个点拆成两个，一个称作入点，即有流量进入的点，一个称作出点，即流量流向别的地方的点，我们从入点向出点连边，边权设为费用，这样我们就将点转化为了边。而原来图中连的边，可以看作从一个点的出点连向另一个点的入点。</p>\r\n<p>之后，我们可以跑一遍Dinic求出最大流，这样我们就找到了最小割。<strong>需要注意的是，题目中说明源点\r\n<span class=\"math inline\">\\(a\\)</span> 和汇点 <span\r\nclass=\"math inline\">\\(b\\)</span> 也是可以去掉的，所以我们要从源点 <span\r\nclass=\"math inline\">\\(a\\)</span> 的入边到汇点 <span\r\nclass=\"math inline\">\\(b\\)</span> 的出边跑最大流，这样才能让源点 <span\r\nclass=\"math inline\">\\(a\\)</span> 和汇点 <span\r\nclass=\"math inline\">\\(b\\)</span> 都能被去掉</strong>。</p>\r\n<p>这一部分是比较常见的套路。</p>\r\n<p><strong>不太寻常的是题目中的输出，求的是构成最小割的一个方案。</strong></p>\r\n<p>我们再来思考最小割的意义：</p>\r\n<p>最小割，即去掉某些边后，网络的源点和汇点不再连通，且边权之和最小。</p>\r\n<p>显然，在求出最大流后的残量网络中，从源点一定无法到达汇点。</p>\r\n<p>也就是说，我们只要从源点 <span class=\"math inline\">\\(a\\)</span>\r\n开始走，走所能到达的点，一定会存在某一时刻走不动了，如下图所示：</p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/image-20220319170146094.png\" /></p>\r\n<p>此图中，从源点 <span class=\"math inline\">\\(a\\)</span>\r\n开始，一直走，直到走到了 <span\r\nclass=\"math inline\">\\(x\\)</span>，发现后面再走 <span\r\nclass=\"math inline\">\\(y\\)</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span> 的边权都为 <span\r\nclass=\"math inline\">\\(0\\)</span> ，不能继续走了，就说明如果将 <span\r\nclass=\"math inline\">\\(y\\)</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span> 割掉，源点途径 <span\r\nclass=\"math inline\">\\(x\\)</span>\r\n的路径就永远无法到达汇点，也就是说，所有满足这样，这条边指向的点（如\r\n<span class=\"math inline\">\\(x\\)</span> ）被访问，但是出发点（如 <span\r\nclass=\"math inline\">\\(y\\)</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span>\r\n）没有被访问的点，都是需要被去除的点，这样才能构成一个割。</p>\r\n<h2 id=\"code\">Code</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">6e2</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,dis[N],now[N],in[N],out[N],vis[N];</span><br><span class=\"line\">queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; an;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">e</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[M*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">    edge[++tot].to = y;</span><br><span class=\"line\">    edge[tot].next = head[x];</span><br><span class=\"line\">    edge[tot].w = w;</span><br><span class=\"line\">    head[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(dis));</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">    dis[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    now[s] = head[s];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">            y = edge[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !dis[y])&#123;</span><br><span class=\"line\">                dis[y] = dis[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                now[y] = head[y];</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> flow)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v,res = flow,use;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=now[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">        v = edge[i].to;</span><br><span class=\"line\">        now[u] = i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; dis[v] == dis[u]+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            use = <span class=\"built_in\">dfs</span>(v,<span class=\"built_in\">min</span>(edge[i].w,res));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!use) dis[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            edge[i].w-=use;</span><br><span class=\"line\">            edge[i^<span class=\"number\">1</span>].w+=use;</span><br><span class=\"line\">            res-=use;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!res) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> flow-res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    vis[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">        v = edge[i].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !vis[v]) <span class=\"built_in\">dfs2</span>(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"comment\">//算出入点和出点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        in[i] = i*<span class=\"number\">2</span><span class=\"number\">-1</span>;</span><br><span class=\"line\">        out[i] = i*<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = in[s];</span><br><span class=\"line\">    t = out[t];</span><br><span class=\"line\">    <span class=\"comment\">//读入与建图</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[i],out[i],x);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[i],in[i],<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[x],in[y],inf);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[y],out[x],<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[y],in[x],inf);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[x],out[y],<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//Dinic求出最小割</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flow,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (flow = <span class=\"built_in\">dfs</span>(s,inf)) ans+=flow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//求出一个方案使源点和汇点不连通</span></span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=tot;i+=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!vis[edge[i].to] &amp;&amp; vis[edge[i^<span class=\"number\">1</span>].to])&#123;</span><br><span class=\"line\">            an.<span class=\"built_in\">push_back</span>((edge[i^<span class=\"number\">1</span>].to+<span class=\"number\">1</span>)/<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(an.<span class=\"built_in\">begin</span>(),an.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sz = an.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;sz;i++) cout&lt;&lt;an[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["Knowledge","网络流"]},{"title":"Useless Thoughts(遐想)","url":"/2021/08/02/Useless-Thoughts-%E9%81%90%E6%83%B3/","content":"<p><strong>War, war never changes.</strong></p>\r\n<p><strong>But peace, peace changes everything.</strong></p>\r\n<p>犹记得曾经带领举国10个远古军团在《文明Ⅵ》中鲁莽地向自己的友邦瑞士开战，在军队突破阿拉伯的援兵，围在没有任何防御的日内瓦城的所有边界方格上，取得第一次压倒性胜利时的喜悦与狂热，对占领的渴望充斥着我的大脑。</p>\r\n<span id=\"more\"></span>\r\n<p>也记得被阿拉伯疯狂传教、在边境造城挑衅后愤然发起突袭战争，率领接近20个单位的远征大军朝着开罗进发时的意气风发；但谁能想到几回合后我就被困在防御工事内进退不得，只得在阿拉伯的现代化大军到来前从海上逃跑，而又是什么导致了这场战争呢？是对复仇的渴望。</p>\r\n<p>最近了解了伊拉克战争和阿富汗战争，对此更是深有同感。9.11事件成为了阿富汗战争的导火索，控制石油资源的诱惑则导致了伊拉克战争，反观历史上的重大战争，又有哪个不是基于利益和复仇的呢？</p>\r\n<p>但在战争的进程中，有一方的力量却被忽视了——士兵。在游戏中，他们被化为单调的数值；在国家之间的战争中，他们被作为实力较量的筹码；在军官心中，他们被作为任人摆布的棋子。哪位国家元首曾将他们与经济损失、基础建设修复、物资补给一起计算战争的代价？P社玩家之所以成为\"大恶人\"，还不是因为他们无视面板上增加的死亡人数，狂热的发动战争，丝毫没想过那些数字对于他们的家人，挚友意味着什么！战争永远不会是美好的，不会是地图上几条线共同导向的结果，更不会是按动鼠标上的左右键就能完全体会的，其中酿成了多少人间悲剧，造就了多少绝望的结局，我们又如何得知！</p>\r\n<p>但仔细思考一下，各种冲突才是导致战争的最大缘由：边境冲突，宗教冲突，政党冲突（省略）它们也许是人类永远无法避免的命运。但就像线段树一样，作为叶子节点的我们，如果更加平和、宽容待人，能从生活中一个完美的光影，一个样貌奇特的绿树，一个陌生人的有趣谈话中发现美好，不过于厌世，也不盲目服从，那样也许经过多次pushup操作，上层的祖先们就会更加和睦，做出宝贵的和平决定吧。</p>\r\n<p>（吹爆COD现代战争三部曲）</p>\r\n","tags":["Life"]},{"title":"WHK目录","url":"/2022/02/11/WHK%E7%9B%AE%E5%BD%95/","content":"<h1 id=\"目录\">目录：</h1>\r\n<span id=\"more\"></span>\r\n<h2 id=\"化学\">化学</h2>\r\n<h3 id=\"必修1\">必修1</h3>\r\n<h4 id=\"第一单元\">第一单元</h4>\r\n<h5 id=\"part-1物质的分类\">Part 1：<a\r\nhref=\"https://bowenone580.github.io/2022/02/11/物质的分类/\">物质的分类</a></h5>\r\n","tags":["Knowledge","WHK","Menu"]},{"title":"同余","url":"/2022/04/05/%E5%90%8C%E4%BD%99/","content":"<h1 id=\"同余\">同余</h1>\r\n<h2 id=\"定义\">定义</h2>\r\n<p>如果两个整数<span class=\"math inline\">\\(a,b\\)</span>除以<span\r\nclass=\"math inline\">\\(m\\)</span>的余数相等，则称<span\r\nclass=\"math inline\">\\(a,b\\)</span>模<span\r\nclass=\"math inline\">\\(m\\)</span>同余，记作<span\r\nclass=\"math inline\">\\(a\\equiv b(\\mod m)\\)</span>。</p>\r\n<p>一个在<span class=\"math inline\">\\([0,m-1]\\)</span>里面的数<span\r\nclass=\"math inline\">\\(a\\)</span>，它所属的集合<span\r\nclass=\"math inline\">\\(\\{a+km\\}\\)</span>里面的所有数和<span\r\nclass=\"math inline\">\\(m\\)</span>同余，则称这个集合为一个模<span\r\nclass=\"math inline\">\\(m\\)</span>的同余类。</p>\r\n<p><span class=\"math inline\">\\(1\\)</span>~<span\r\nclass=\"math inline\">\\(m\\)</span>中和<span\r\nclass=\"math inline\">\\(m\\)</span>互质的数代表的同余类共有<span\r\nclass=\"math inline\">\\(\\varphi(m)\\)</span>个，它们构成<span\r\nclass=\"math inline\">\\(m\\)</span>的简化剩余系。</p>\r\n<span id=\"more\"></span>\r\n<p>结论1：如果<span class=\"math inline\">\\(a,b\\)</span>都属于<span\r\nclass=\"math inline\">\\(m\\)</span>的简化剩余系，则<span\r\nclass=\"math inline\">\\(a\\cdot b \\mod m\\)</span>也属于<span\r\nclass=\"math inline\">\\(m\\)</span>的简化剩余系。</p>\r\n<p>证明：显然，<span class=\"math inline\">\\(a,b\\)</span>都和<span\r\nclass=\"math inline\">\\(m\\)</span>互质，则<span\r\nclass=\"math inline\">\\(a\\cdot b \\mod m\\)</span>一定和<span\r\nclass=\"math inline\">\\(m\\)</span>互质，必然属于<span\r\nclass=\"math inline\">\\(m\\)</span>的简化剩余系。</p>\r\n<h2 id=\"运算\">运算</h2>\r\n<p>模<span class=\"math inline\">\\(n\\)</span>意义下的运算</p>\r\n<ul>\r\n<li><p>加法</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(a+b = (a\\mod n+b\\mod n)\\mod\r\nn\\)</span></li>\r\n<li><span class=\"math inline\">\\(a\\equiv -b(\\mod n) \\iff a+b \\equiv\r\n0(\\mod\r\nn)\\)</span>（等式两边同时加上一个整数，模意义下等式仍然成立）</li>\r\n</ul></li>\r\n<li><p>减法</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(a-b = (a\\mod n-b\\mod n) \\mod\r\nn\\)</span></li>\r\n<li><span class=\"math inline\">\\(a\\equiv b(\\mod n) \\iff a-b\\equiv 0(\\mod\r\nn)\\)</span>（等式两边同时减去一个整数，模意义下等式仍然成立）</li>\r\n</ul></li>\r\n<li><p>乘法</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(a\\cdot b = (a \\mod n\\cdot b\\mod n)\\mod\r\nn\\)</span></li>\r\n<li><span class=\"math inline\">\\(a\\equiv b(\\mod n) \\iff a\\cdot k\\equiv\r\nb\\cdot k(\\mod\r\nn)\\)</span>（等式两边同时乘上一个整数，模意义下等式仍然成立）</li>\r\n</ul></li>\r\n<li><p>除法</p>\r\n<ul>\r\n<li><p>这个后面再说</p></li>\r\n<li><p><span class=\"math inline\">\\(a\\cdot k\\equiv b\\cdot k(\\mod n) \\iff\r\na\\equiv b(\\mod \\frac{n}{gcd(n,k)})\\)</span></p>\r\n<ul>\r\n<li><p>证明：<span class=\"math inline\">\\(a\\cdot k\\equiv b\\cdot k(\\mod n)\r\n\\iff (a-b)\\cdot k\\equiv 0(\\mod n)\\)</span>。</p>\r\n<p>感性理解一下，<span\r\nclass=\"math inline\">\\(k\\)</span>尽全力只能帮助<span\r\nclass=\"math inline\">\\(a-b\\)</span>拿下<span\r\nclass=\"math inline\">\\(gcd(n,k)\\)</span>，剩下的<span\r\nclass=\"math inline\">\\(\\frac{n}{gcd(n,k)}\\)</span>是<span\r\nclass=\"math inline\">\\(a-b\\)</span>必须要有的，所以<span\r\nclass=\"math inline\">\\(a-b\\equiv 0(\\mod\r\n\\frac{n}{gcd(n,k)})\\)</span>。</p></li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>乘方</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(a\\equiv b \\iff a^k\\equiv b^k(\\mod\r\nn)\\)</span></li>\r\n<li>证明：设<span class=\"math inline\">\\(a = k_1n+r,b =\r\nk_2n+r\\)</span>，则<span class=\"math inline\">\\(a^k = k_1\\cdot X+r^k,b^k\r\n= k_2\\cdot Y+r^k\\)</span>，所以原式等价于<span\r\nclass=\"math inline\">\\(r^k\\equiv r^k\\)</span>，显然成立。</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"定理\">定理</h2>\r\n<p><strong>费马小定理：若<span\r\nclass=\"math inline\">\\(p\\)</span>是质数，则对于任意正整数<span\r\nclass=\"math inline\">\\(a\\)</span>，有<span\r\nclass=\"math inline\">\\(a^p\\equiv a(\\mod p)\\)</span>。</strong></p>\r\n<p><strong>欧拉定理：若正整数<span\r\nclass=\"math inline\">\\(a,n\\)</span>互质，则<span\r\nclass=\"math inline\">\\(a^{\\varphi(n)}\\equiv 1(\\mod\r\nn)\\)</span>。</strong></p>\r\n<p>证明：对于<span\r\nclass=\"math inline\">\\(n\\)</span>的所有互质的数，我们将其从小到达排列为<span\r\nclass=\"math inline\">\\(a_1,a_2,\\cdots,a_{\\varphi(n)}\\)</span>。</p>\r\n<p>之后，我们把所有这些数都乘上<span\r\nclass=\"math inline\">\\(a\\)</span>，得到<span\r\nclass=\"math inline\">\\(aa_1,aa_2,\\cdots,aa_{\\varphi(n)}\\)</span>，又因为<span\r\nclass=\"math inline\">\\(a,n\\)</span>互质，所以得到的数都和<span\r\nclass=\"math inline\">\\(n\\)</span>互质。</p>\r\n<p>我们再证明这些数组成的集合正好是<span\r\nclass=\"math inline\">\\(n\\)</span>的简化剩余系：</p>\r\n<p>如果对于两个不同的<span\r\nclass=\"math inline\">\\(a_i,a_j\\)</span>来说，<span\r\nclass=\"math inline\">\\(aa_i\\equiv aa_j(\\mod\r\nn)\\)</span>，那么根据上面的运算性质，要么<span\r\nclass=\"math inline\">\\(a\\mid n\\)</span>，要么<span\r\nclass=\"math inline\">\\(a_i\\equiv a_j(\\mod n)\\)</span>，然而根据<span\r\nclass=\"math inline\">\\(a,n\\)</span>互质，第一个不成立，根据我们假设的<span\r\nclass=\"math inline\">\\(a_i\\neq\r\na_j\\)</span>，第二个也不成立，所以这个集合正好构成<span\r\nclass=\"math inline\">\\(n\\)</span>的简化剩余系。</p>\r\n<p>由此，<span class=\"math inline\">\\(aa_1\\cdot aa_2\\cdots\r\naa_{\\varphi(n)}\\equiv a_1\\cdot a_2 \\cdots a_{\\varphi(n)}(\\mod\r\nn)\\)</span>，所以<span class=\"math inline\">\\(a^{\\varphi(n)}\\equiv 1(\\mod\r\nn)\\)</span>。</p>\r\n<p>当<span class=\"math inline\">\\(n\\)</span>为质数时，<span\r\nclass=\"math inline\">\\(a^{\\varphi(n)}\\equiv1(\\mod n) = a^{n-1}\\equiv\r\n1(\\mod n) = a^n\\equiv a(\\mod n)\\)</span>。</p>\r\n<p>由此，费马小定理成立。</p>\r\n<h2 id=\"欧拉定理的推论\">欧拉定理的推论</h2>\r\n<ol type=\"1\">\r\n<li><p><strong>若<span\r\nclass=\"math inline\">\\(a,n\\)</span>互质，则对于任意正整数<span\r\nclass=\"math inline\">\\(b\\)</span>，有<span\r\nclass=\"math inline\">\\(a^b\\equiv a^{b\\mod \\varphi(n)}(\\mod\r\nn)\\)</span></strong>。</p>\r\n<p>证明：</p>\r\n<p>设<span class=\"math inline\">\\(b=k\\cdot \\varphi(n)+r\\)</span>，则<span\r\nclass=\"math inline\">\\(a^b = a^{k\\cdot \\varphi(n)+r} =\r\na^{\\varphi(n)^k}\\cdot a^r\\equiv 1^k\\cdot a^r\\equiv\r\na^r\\)</span>，所以原式仍旧成立。</p></li>\r\n<li><p><strong>若<span\r\nclass=\"math inline\">\\(a,n\\)</span>不互质，且对于正整数<span\r\nclass=\"math inline\">\\(b&lt;\\varphi(n)\\)</span>，有<span\r\nclass=\"math inline\">\\(a^b\\equiv a^b(\\mod n)\\)</span></strong>。</p>\r\n<p>证明：</p>\r\n<p>显然成立。</p></li>\r\n<li><p><strong>若<span\r\nclass=\"math inline\">\\(a,n\\)</span>不互质，且对于正整数<span\r\nclass=\"math inline\">\\(b\\geq \\varphi(n)\\)</span>，有<span\r\nclass=\"math inline\">\\(a^b\\equiv a^{b\\mod \\varphi(n)+\\varphi(n)}(\\mod\r\nn)\\)</span></strong>。</p>\r\n<p>证明：</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(a\\)</span>为质数，且<span\r\nclass=\"math inline\">\\(a\\mid n\\)</span>。</p>\r\n<p>设<span class=\"math inline\">\\(n=n&#39;a^r\\)</span>，则<span\r\nclass=\"math inline\">\\(a,n&#39;\\)</span>一定互质，根据欧拉定理，可得<span\r\nclass=\"math inline\">\\(a^{\\varphi(n&#39;)}\\equiv 1(\\mod\r\nn&#39;)\\)</span>。</p>\r\n<p>又因为<span class=\"math inline\">\\(a^r,n&#39;\\)</span>互质，所以<span\r\nclass=\"math inline\">\\(\\varphi(n) =\\varphi(n&#39;)\\cdot (a-1)\\cdot\r\na^{r-1}\\)</span>，即<span class=\"math inline\">\\(\\varphi(n&#39;)\\mid\r\n\\varphi(n)\\)</span>。</p>\r\n<p>所以根据<span class=\"math inline\">\\(a^{\\varphi(n&#39;)}\\equiv 1(\\mod\r\nn&#39;)\\)</span>，可以得到<span\r\nclass=\"math inline\">\\(a^{\\varphi(n)}\\equiv 1(\\mod n&#39;)\\)</span>。</p>\r\n<p>变换形式，可得<span class=\"math inline\">\\(a^{\\varphi(n)} =\r\nn&#39;k+1\\)</span>，即<span class=\"math inline\">\\(a^{\\varphi(n)+r} =\r\nnk+a^r\\)</span>。</p>\r\n<p>所以，<span class=\"math inline\">\\(a^{\\varphi(n)+r}\\equiv a^r(\\mod\r\nn)\\)</span>，即<span class=\"math inline\">\\(a^{k\\cdot\\varphi(n)+r}\\equiv\r\na^r(\\mod n)\\)</span>。</p>\r\n<p>设<span class=\"math inline\">\\(b =\r\nr+k\\cdot\\varphi(n)+t\\)</span>，则<span class=\"math inline\">\\(a^b =\r\na^{r+k\\cdot\\varphi(n)+t} = a^{r+t}\\)</span>。</p>\r\n<p>又因为<span class=\"math inline\">\\(t = b-r-k\\cdot\\varphi(n) =\r\n(b-r)\\mod \\varphi(n)\\)</span>，所以<span class=\"math inline\">\\(a^b =\r\na^{r+(b-r)\\mod \\varphi(n)}(\\mod n)\\)</span>。</p></li>\r\n<li><p><span class=\"math inline\">\\(a\\)</span>为质数的幂。</p>\r\n<p>剩下的看不懂了，有兴趣的直接看<a\r\nhref=\"https://blog.csdn.net/synapse7/article/details/19610361\">三个重要的同余式——威尔逊定理、费马小定理、欧拉定理\r\n+ 求幂大法的证明_synapse7的博客</a>。</p></li>\r\n</ol></li>\r\n</ol>\r\n<p>总之，这个式子可以降低幂次，使我们能用快速幂之类的东西简化计算。</p>\r\n<h2 id=\"扩展欧几里得\">扩展欧几里得</h2>\r\n<p>对于任意整数<span\r\nclass=\"math inline\">\\(a,b\\)</span>，存在一对整数<span\r\nclass=\"math inline\">\\(x,y\\)</span>，满足<span\r\nclass=\"math inline\">\\(ax+by = gcd(a,b)\\)</span>。</p>\r\n<p>在欧几里得算法的最后一步中，<span\r\nclass=\"math inline\">\\(b=0\\)</span>，我们可以得到一组解：<span\r\nclass=\"math inline\">\\(a\\cdot1+0\\cdot0 = gcd(a,0)\\)</span>。</p>\r\n<p>我们往回导一下，在<span\r\nclass=\"math inline\">\\(b&gt;0\\)</span>时，<span\r\nclass=\"math inline\">\\(gcd(a,b) = gcd(b,a\\mod\r\nb)\\)</span>，假设存在一对整数<span\r\nclass=\"math inline\">\\(x,y\\)</span>满足<span\r\nclass=\"math inline\">\\(bx+(a\\mod b)y=gcd(b,a \\mod b)\\)</span>，则<span\r\nclass=\"math inline\">\\(bx+(a-b\\cdot\\lfloor a/b\\rfloor)y=ay+ b(x-\\lfloor\r\na/b\\rfloor y)\\)</span>，我们只要令<span\r\nclass=\"math inline\">\\(x&#39;=y,y&#39;=x-\\lfloor a/b\\rfloor\r\ny\\)</span>，就可以求出另一组解，由于当<span\r\nclass=\"math inline\">\\(b=0\\)</span>时是有解的，所以我们归纳一下，可以得到任意时刻都有解。于是对于任意整数<span\r\nclass=\"math inline\">\\(a,b\\)</span>，都存在一组整数<span\r\nclass=\"math inline\">\\(x,y\\)</span>，满足<span\r\nclass=\"math inline\">\\(ax+by = gcd(a,b)\\)</span>。</p>\r\n<p>当然，这里求出的仅是一组特解，并不能代表所有的解。</p>\r\n<p>更一般的，对于<span class=\"math inline\">\\(ax+by =\r\nc\\)</span>，方程有解当且仅当<span class=\"math inline\">\\(gcd(a,b)\\mid\r\nc\\)</span>，且通解可表示为<span\r\nclass=\"math inline\">\\(x=\\frac{c}{gcd(a,b)}x_0+\\frac{kb}{gcd(a,b)},y =\r\n\\frac{c}{gcd(a,b)}y_0-\\frac{ka}{gcd(a,b)}\\)</span>。其中<span\r\nclass=\"math inline\">\\(x_0,y_0\\)</span>为<span\r\nclass=\"math inline\">\\(ax+by = gcd(a,b)\\)</span>的一组特解。</p>\r\n<p>证明：咕了。</p>\r\n<h2 id=\"乘法逆元\">乘法逆元</h2>\r\n<p>我们回到之前对于运算的处理，我们对加减乘和乘方运算都有较好的处理方式，但是除法中很可能会有小数，这时候再模就不知道是什么东西了，为了将结果限制在整数范围内，我们需要一种特殊的处理方式：乘法逆元。</p>\r\n<p>若整数<span class=\"math inline\">\\(b,m\\)</span>互质，且<span\r\nclass=\"math inline\">\\(b\\mid a\\)</span>，则存在一个整数<span\r\nclass=\"math inline\">\\(x\\)</span>，使得<span\r\nclass=\"math inline\">\\(a/b\\equiv ax(\\mod m)\\)</span>，称<span\r\nclass=\"math inline\">\\(x\\)</span>为<span\r\nclass=\"math inline\">\\(b\\)</span>的模<span\r\nclass=\"math inline\">\\(m\\)</span>乘法逆元，记为<span\r\nclass=\"math inline\">\\(b^{-1}(\\mod m)\\)</span>。</p>\r\n<p>因为<span class=\"math inline\">\\(a/b\\equiv a\\cdot b^{-1}\\equiv\r\na/b\\cdot b\\cdot b^{-1}(\\mod\r\nm)\\)</span>，所以根据上面的运算规律，我们可以得到<span\r\nclass=\"math inline\">\\(b\\cdot b^{-1}\\equiv 1(\\mod m)\\)</span>。</p>\r\n<p>那么，我们就是要找到<span\r\nclass=\"math inline\">\\(b^{-1}\\)</span>取啥比较合适。</p>\r\n<h3 id=\"模质数\">模质数</h3>\r\n<p>如果<span\r\nclass=\"math inline\">\\(m\\)</span>是质数，根据费马小定理，<span\r\nclass=\"math inline\">\\(b^m\\equiv b(\\mod m) \\iff b^{m-1}\\equiv 1(\\mod m)\r\n\\iff b\\cdot b^{m-2}\\equiv 1(\\mod m)\\)</span>，所以<span\r\nclass=\"math inline\">\\(b^{-1} = b^{m-2}\\)</span>是<span\r\nclass=\"math inline\">\\(b\\)</span>的乘法逆元。</p>\r\n<h3 id=\"线性求1n中所有数的逆元\">线性求1~n中所有数的逆元</h3>\r\n<p>还要说明一点，如果要求<span class=\"math inline\">\\(1\\)</span>~<span\r\nclass=\"math inline\">\\(n\\)</span>中所有数模质数<span\r\nclass=\"math inline\">\\(p\\)</span>的逆元，是可以线性求出的。</p>\r\n<p>具体来说，我们设<span class=\"math inline\">\\(p=k\\cdot\r\ni+r\\)</span>，其中<span class=\"math inline\">\\(0\\leq\r\nr&lt;i\\)</span>。</p>\r\n<p>于是，<span class=\"math inline\">\\(k\\cdot i+r\\equiv 0(\\mod\r\np)\\)</span>。</p>\r\n<p>两边同乘<span class=\"math inline\">\\(i^{-1}\\)</span>和<span\r\nclass=\"math inline\">\\(r^{-1}\\)</span>，得到<span\r\nclass=\"math inline\">\\(k\\cdot r^{-1}+i^{-1}\\equiv 0(\\mod\r\np)\\)</span>。</p>\r\n<p>移项，得<span class=\"math inline\">\\(i^{-1}\\equiv -k\\cdot r^{-1}(\\mod\r\np)\\)</span>，也就是说，<span class=\"math inline\">\\(i^{-1}\\equiv -\\lfloor\r\np/i\\rfloor\\cdot(p\\mod i)^{-1}(\\mod\r\np)\\)</span>，我们用的都是之前已经求出的逆元，可以线性求出所有的逆元。</p>\r\n<h3 id=\"线性求任意n个数的逆元\">线性求任意n个数的逆元</h3>\r\n<p>我们首先求出<span\r\nclass=\"math inline\">\\(n\\)</span>个数的前缀积，记为<span\r\nclass=\"math inline\">\\(s_i\\)</span>，之后求出<span\r\nclass=\"math inline\">\\(s_n\\)</span>的逆元<span\r\nclass=\"math inline\">\\(sv_n\\)</span>。</p>\r\n<p><span class=\"math inline\">\\(s_n=\\Pi_{i=1}^na_i\\)</span>，于是<span\r\nclass=\"math inline\">\\(sv_n=\\Pi_{i=1}^na_i^{-1}\\)</span>。</p>\r\n<p>我们从后往前，每次乘上<span\r\nclass=\"math inline\">\\(a_i\\)</span>，于是得到<span\r\nclass=\"math inline\">\\(s&#39;_i=\\Pi_{j=1}^ia_j^{-1}\\)</span>，那么<span\r\nclass=\"math inline\">\\(a_i^{-1} = s&#39;_i\\cdot s_{i-1}\\)</span>。</p>\r\n<p>这样，我们就用<span class=\"math inline\">\\(n+\\log\r\nm\\)</span>的时间求出了任意<span\r\nclass=\"math inline\">\\(n\\)</span>个数的逆元。</p>\r\n<h3 id=\"bm互质\">b,m互质</h3>\r\n<p>如果只保证<span\r\nclass=\"math inline\">\\(b,m\\)</span>互质，我们需要求解同余方程<span\r\nclass=\"math inline\">\\(bx\\equiv 1(\\mod m)\\)</span>。</p>\r\n<p>接下来，我们将讨论如何解决这个问题。</p>\r\n<h2 id=\"线性同余方程\">线性同余方程</h2>\r\n<p>形如<span class=\"math inline\">\\(ax\\equiv b(\\mod\r\nm)\\)</span>的方程叫做线性同余方程，因为其未知数<span\r\nclass=\"math inline\">\\(x\\)</span>的指数为1。</p>\r\n<p>我们将其变形，得<span class=\"math inline\">\\(ax-b\\equiv 0(\\mod\r\nm)\\)</span>，即<span class=\"math inline\">\\(ax-b=-ym\\)</span>。</p>\r\n<p>移项，得<span\r\nclass=\"math inline\">\\(ax+ym=b\\)</span>，这个东西可以用扩展欧几里得解决。</p>\r\n<p>我们先求出<span class=\"math inline\">\\(ax+ym =\r\ngcd(a,m)\\)</span>的一组解<span\r\nclass=\"math inline\">\\(x,y\\)</span>，之后乘<span\r\nclass=\"math inline\">\\(b/gcd(a,m)\\)</span>，就可以求出这个方程的一个特解<span\r\nclass=\"math inline\">\\(x_0\\)</span>。</p>\r\n<p>通解是所有模<span class=\"math inline\">\\(m/gcd(a,m)\\)</span>和<span\r\nclass=\"math inline\">\\(x_0\\)</span>同余的数，形象一点的说，通解是<span\r\nclass=\"math inline\">\\(x_0\\frac{b}{gcd(a,m)}+\\frac{tm}{gcd(a,m)}\\)</span>，这里的<span\r\nclass=\"math inline\">\\(t\\)</span>取遍整个整数集合。</p>\r\n<h2 id=\"中国剩余定理\">中国剩余定理</h2>\r\n<p>设<span class=\"math inline\">\\(m_1,m_2,\\cdots,m_n\\)</span>是<span\r\nclass=\"math inline\">\\(n\\)</span>个两两互质的整数，<span\r\nclass=\"math inline\">\\(m=\\Pi_{i=1}^nm_i\\)</span>，<span\r\nclass=\"math inline\">\\(M_i = m/m_i\\)</span>，<span\r\nclass=\"math inline\">\\(t_i\\)</span>是线性同余方程<span\r\nclass=\"math inline\">\\(M_it_i\\equiv 1(\\mod\r\nm_i)\\)</span>的一个解，则对于任意<span\r\nclass=\"math inline\">\\(n\\)</span>个整数<span\r\nclass=\"math inline\">\\(a_1,a_2\\cdots a_n\\)</span>，方程组</p>\r\n<p><span class=\"math inline\">\\(\\left\\{\\begin{aligned}x\\equiv a_1(\\mod\r\nm_1)\\\\x\\equiv a_2(\\mod m_2)\\\\\\cdots\\\\x\\equiv a_n(\\mod\r\nm_n)\\end{aligned}\\right.\\)</span></p>\r\n<p>有整数解，解为<span\r\nclass=\"math inline\">\\(x=\\sum_{i=1}^na_iM_it_i\\)</span>。</p>\r\n<p>证明：</p>\r\n<p>对于<span class=\"math inline\">\\(M_i\\neq m/m_i\\)</span>，有<span\r\nclass=\"math inline\">\\(m_i\\mid M_i\\)</span>，所以<span\r\nclass=\"math inline\">\\(a_iM_it_i\\equiv 0(\\mod m_i)\\)</span>。</p>\r\n<p>对于<span class=\"math inline\">\\(M_i=m/m_i\\)</span>，有<span\r\nclass=\"math inline\">\\(M_it_i\\equiv 1(\\mod m_i)\\)</span>，所以<span\r\nclass=\"math inline\">\\(a_iM_it_i\\equiv a_i(\\mod m_i)\\)</span>。</p>\r\n<p>所以这是原方程组的一个特解。</p>\r\n<p>通解就是<span class=\"math inline\">\\(x+km\\)</span>。</p>\r\n<p>证明：又咕了。</p>\r\n<h2 id=\"扩展中国剩余定理\">扩展中国剩余定理</h2>\r\n<p>虽然刚才的解确实非常妙，但是只有在<span\r\nclass=\"math inline\">\\(m_1,m_2\\cdots,m_n\\)</span>中所有数两两互质才能使用，这在题目中是非常罕见的限制条件，更多的是随便取一些数，让你解这个方程组，这时候我们应该怎么做呢？</p>\r\n<p>我们考虑用数学归纳法解决。</p>\r\n<p>显然，只有<span class=\"math inline\">\\(x\\equiv a_1(\\mod\r\nm_1)\\)</span>时，我们可以通过线性同余方程求出一个解，或判断其无解。</p>\r\n<p>假设现在已经求出了前<span\r\nclass=\"math inline\">\\(k-1\\)</span>个方程的解<span\r\nclass=\"math inline\">\\(x\\)</span>，设<span class=\"math inline\">\\(m =\r\nlcm(m_1,m_2\\cdots m_{k-1})\\)</span>，则<span\r\nclass=\"math inline\">\\(x+im\\)</span>是前<span\r\nclass=\"math inline\">\\(k-1\\)</span>个方程的一个通解，现在要求出一个整数<span\r\nclass=\"math inline\">\\(t\\)</span>，满足<span\r\nclass=\"math inline\">\\(x+tm\\equiv a_k(\\mod m_k)\\)</span>，即<span\r\nclass=\"math inline\">\\(tm\\equiv a_k-x(\\mod\r\nm_k)\\)</span>，这可以通过找出这个线性同余方程的一个解得到，或判断其无解。</p>\r\n<h2 id=\"高次同余方程\">高次同余方程</h2>\r\n<h3 id=\"bsgs算法\">BSGS算法</h3>\r\n<p>在<span class=\"math inline\">\\(a,p\\)</span>互质时，对于形如<span\r\nclass=\"math inline\">\\(a^x\\equiv b(\\mod\r\np)\\)</span>之类的问题，我们可以使用BSGS求解。</p>\r\n<p>这个<span class=\"math inline\">\\(x\\)</span>可以看成<span\r\nclass=\"math inline\">\\(it-j\\)</span>，其中<span class=\"math inline\">\\(t =\r\n\\lceil \\sqrt{p}\\rceil\\)</span>，这里的<span class=\"math inline\">\\(i\\in\r\n[1,t],j\\in[1,t]\\)</span>，这样可以取到<span\r\nclass=\"math inline\">\\([0,p-1]\\)</span>中的任何一个值。</p>\r\n<p>为什么不需要取更大的值呢？因为<span\r\nclass=\"math inline\">\\(a,p\\)</span>互质，所以我们可以使用欧拉定理，<span\r\nclass=\"math inline\">\\(a^{x+\\varphi(p)}\\equiv a^x\\cdot\r\na^{\\varphi(p)}\\equiv a^x\\cdot 1\\equiv a^x(\\mod p)\\)</span>。</p>\r\n<p>所以，<span class=\"math inline\">\\(x\\)</span>只要在<span\r\nclass=\"math inline\">\\([0,p-1]\\)</span>的范围内就行了。</p>\r\n<p>对这个式子进行变形，<span class=\"math inline\">\\(a^{it-j}\\equiv b \\iff\r\na^{it}\\equiv b\\cdot a^j(\\mod p)\\)</span>。</p>\r\n<p>我们从小到大枚举<span class=\"math inline\">\\(j\\)</span>，算出<span\r\nclass=\"math inline\">\\(b\\cdot\r\na^j\\)</span>的所有取值，当取值相等时，我们用较大的<span\r\nclass=\"math inline\">\\(j\\)</span>更新，这样可以保证我们得到的是最小非负整数解。</p>\r\n<p>之后，再从小到大枚举<span\r\nclass=\"math inline\">\\(i\\)</span>，直接求出<span\r\nclass=\"math inline\">\\(a^{it}\\)</span>的值，查找是否有对应的<span\r\nclass=\"math inline\">\\(j\\)</span>，使同余后结果相同，有就直接输出答案。</p>\r\n<p>这个答案为什么最小？我们考虑极端一点的情况，<span\r\nclass=\"math inline\">\\(it-1&lt;(i+1)t-t\\)</span>，所以就没啥问题了。</p>\r\n<p>查找相等的取值好像可以用hash做到<span\r\nclass=\"math inline\">\\(O(1)\\)</span>，但是我只会用<span\r\nclass=\"math inline\">\\(O(\\log n)\\)</span>的map。也许以后会再更一下。</p>\r\n<p>这个方程也有可能无解，就是在枚举完所有的可能之后都没有找出解来。</p>\r\n<p>这个算法的复杂度优化主要在用map将所有<span\r\nclass=\"math inline\">\\(b\\cdot\r\na^j\\)</span>的值都存起来，这样我们对于每个<span\r\nclass=\"math inline\">\\(i\\)</span>，就只用花费<span\r\nclass=\"math inline\">\\(O(\\log\r\nn)\\)</span>的时间进行查找了，于是总复杂度就是<span\r\nclass=\"math inline\">\\(O(\\sqrt{p}\\cdot \\log p)\\)</span>。这种分割<span\r\nclass=\"math inline\">\\(x\\)</span>的思想是非常具有启发性的。</p>\r\n<h3 id=\"扩展bsgs\">扩展BSGS</h3>\r\n<p>如果只有<span class=\"math inline\">\\(a^x\\equiv b(\\mod\r\np)\\)</span>，不保证<span\r\nclass=\"math inline\">\\(b,p\\)</span>互质，该如何做呢？</p>\r\n<p>我们取<span class=\"math inline\">\\(d =\r\ngcd(a,p)\\)</span>，将整个方程同时除以<span\r\nclass=\"math inline\">\\(d\\)</span>，得到<span\r\nclass=\"math inline\">\\(\\frac{a}{d}\\cdot a^{x-1}\\equiv \\frac{b}{d}(\\mod\r\n\\frac{p}{d})\\)</span>。</p>\r\n<p>为什么可以这样除呢？我们假设原来的方程为<span\r\nclass=\"math inline\">\\(a^x+kp=b\\)</span>，则整体除<span\r\nclass=\"math inline\">\\(d\\)</span>，得<span\r\nclass=\"math inline\">\\(\\frac{a}{d}\\cdot\r\na^{x-1}+k\\cdot\\frac{p}{d}=\\frac{b}{d}\\)</span>，这就相当于把模数也一起除<span\r\nclass=\"math inline\">\\(d\\)</span>。</p>\r\n<p>现在，<span class=\"math inline\">\\(\\frac{a}{d}\\)</span>和<span\r\nclass=\"math inline\">\\(\\frac{p}{d}\\)</span>显然是互质的，于是我们可以用乘法逆元把<span\r\nclass=\"math inline\">\\(\\frac{a}{d}\\)</span>除过去，得到<span\r\nclass=\"math inline\">\\(a^{x-1}\\equiv \\frac{b}{d}\\cdot\r\n(\\frac{a}{d})^{-1}(\\mod \\frac{p}{d})\\)</span>。</p>\r\n<p>我们一直这样除下去，设<span class=\"math inline\">\\(D =\r\n\\Pi_{i=1}^kd_i\\)</span>，直到左边的<span\r\nclass=\"math inline\">\\(a^{x-k}\\)</span>和<span\r\nclass=\"math inline\">\\(\\frac{p}{D}\\)</span>互质，这样我们就可以应用上面的BSGS来解决这个问题了。</p>\r\n<p>BSGS的时间复杂度为<span class=\"math inline\">\\(O(\\sqrt{p}\\cdot\\log\r\np)\\)</span>，每次求gcd的时间复杂度为<span class=\"math inline\">\\(O(\\log\r\np)\\)</span>，总的复杂度大概就是<span\r\nclass=\"math inline\">\\(O(\\sqrt{p}\\cdot \\log p)\\)</span>。</p>\r\n<h2 id=\"阶\">阶</h2>\r\n<p>对于两个互质的数<span class=\"math inline\">\\(a,m\\)</span>而言，<span\r\nclass=\"math inline\">\\(a^x\\equiv 1(\\mod m)\\)</span>，这个<span\r\nclass=\"math inline\">\\(n\\)</span>取最小时称作<span\r\nclass=\"math inline\">\\(a\\)</span>模<span\r\nclass=\"math inline\">\\(m\\)</span>的阶，记作<span\r\nclass=\"math inline\">\\(\\delta_m(a)\\)</span>。</p>\r\n<p>由欧拉定理可得，<span class=\"math inline\">\\(a^{\\varphi(m)}\\equiv\r\n1(\\mod m)\\)</span>，所以在<span\r\nclass=\"math inline\">\\(a,m\\)</span>互质时，<span\r\nclass=\"math inline\">\\(n\\)</span>一定存在。</p>\r\n","tags":["Knowledge","数学"]},{"title":"卡特兰数","url":"/2021/08/04/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","content":"<h2 id=\"更新记录\">更新记录</h2>\r\n<p>2021.9.22 将部分内容替换成了<span\r\nclass=\"math inline\">\\(LaTeX\\)</span>符号</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"前置知识\">前置知识</h2>\r\n<h3 id=\"排列数\">排列数</h3>\r\n<p><span class=\"math inline\">\\(A_n^m\\)</span> $ = $ <span\r\nclass=\"math inline\">\\(\\frac{n!}{(n-m)!}\\)</span> （从<span\r\nclass=\"math inline\">\\(n\\)</span>个数中选<span\r\nclass=\"math inline\">\\(m\\)</span>个来排列）<br />\r\n理解为第一位可以有<span\r\nclass=\"math inline\">\\(n\\)</span>种选择，第二位有<span\r\nclass=\"math inline\">\\(n-1\\)</span>种，最后一位（即第<span\r\nclass=\"math inline\">\\(m\\)</span>位）有<span\r\nclass=\"math inline\">\\(n-m+1\\)</span>种选择 故为<span\r\nclass=\"math inline\">\\(n\\)</span> <span\r\nclass=\"math inline\">\\(\\times\\)</span> <span\r\nclass=\"math inline\">\\((n-1)\\)</span> <span\r\nclass=\"math inline\">\\(\\times\\)</span> <span\r\nclass=\"math inline\">\\((n-2)\\)</span> <span\r\nclass=\"math inline\">\\(\\times\\)</span> … <span\r\nclass=\"math inline\">\\(\\times\\)</span> $(n-m+1) = $ <span\r\nclass=\"math inline\">\\(\\frac{n!}{(n-m)!}\\)</span> 全排列为<span\r\nclass=\"math inline\">\\(n!\\)</span></p>\r\n<h3 id=\"组合数\">组合数</h3>\r\n<p><span class=\"math inline\">\\(C_n^m\\)</span> <span\r\nclass=\"math inline\">\\(=\\)</span> <span\r\nclass=\"math inline\">\\(\\frac{n!}{(n-m)!*m!}\\)</span><br />\r\n理解为将<span\r\nclass=\"math inline\">\\(A_n^m\\)</span>的所有组合方式表示出来，也就是<span\r\nclass=\"math inline\">\\(m\\)</span>的全排列，为<span\r\nclass=\"math inline\">\\(m!\\)</span>，常将<span\r\nclass=\"math inline\">\\(n\\)</span>与<span\r\nclass=\"math inline\">\\(m\\)</span>写在一个括号里: <span\r\nclass=\"math inline\">\\(\\binom{m}{n}\\)</span><br />\r\n特别说明：<span class=\"math inline\">\\(A_n^m\\)</span> <span\r\nclass=\"math inline\">\\(= 0\\)</span>, <span\r\nclass=\"math inline\">\\(C_n^m\\)</span> <span class=\"math inline\">\\(=\r\n0\\)</span></p>\r\n<p><del>（写了这么多主要是因为看不懂将C写成括号后的表达方式）</del></p>\r\n<h2 id=\"卡特兰数的证明\">卡特兰数的证明</h2>\r\n<p>首先想一个<strong>简单一点</strong>的问题：<br />\r\n你有一个栈，<span\r\nclass=\"math inline\">\\(n\\)</span>个数，它们每一个都要进行一次入栈和出栈操作，请问共有多少种方式<br />\r\n可以将每次入栈操作看作 <span class=\"math inline\">\\(+1\\)</span>，出栈看作\r\n<span\r\nclass=\"math inline\">\\(-1\\)</span>，容易想到，合法的方案必须满足所有时刻的<strong>前缀和<span\r\nclass=\"math inline\">\\(&gt;=0\\)</span></strong><br />\r\n更形象地，将其转移到坐标系上，每次入栈将横坐标 <span\r\nclass=\"math inline\">\\(+1\\)</span>，每次出栈将纵坐标 <span\r\nclass=\"math inline\">\\(+1\\)</span>，则所有的合法情况满足<strong>横坐标值<span\r\nclass=\"math inline\">\\(&gt;=\\)</span>纵坐标值</strong>，所有的不合法情况满足<strong>纵坐标-横坐标<span\r\nclass=\"math inline\">\\(&gt;=1\\)</span></strong>，则所有不合法情况和函数<span\r\nclass=\"math inline\">\\(y=x+1\\)</span>必有大于等于1个交点，考虑将其转化为如下形式：</p>\r\n<p><img src=\"https://z3.ax1x.com/2021/09/05/hWt7gx.png\" /></p>\r\n<p>图中实线为不合法操作路径，将其与<span\r\nclass=\"math inline\">\\(y=x+1\\)</span>相交后的线段关于<span\r\nclass=\"math inline\">\\(y=x+1\\)</span>对称，得到的最终点是<span\r\nclass=\"math inline\">\\((n-1,n+1)\\)</span>，由于所有不合法路径必然经过<span\r\nclass=\"math inline\">\\(y=x+1\\)</span>，所以不合法的路径的情况转化为了从<span\r\nclass=\"math inline\">\\(0\\)</span>到<span\r\nclass=\"math inline\">\\((n-1,n+1)\\)</span>的路径总数之和，即<span\r\nclass=\"math inline\">\\(\\binom{n-1}{2n}\\)</span>或<span\r\nclass=\"math inline\">\\(\\binom{n+1}{2n}\\)</span>。<br />\r\n合法路径总数即为全部路径<span\r\nclass=\"math inline\">\\(-\\)</span>不合法路径，即<span\r\nclass=\"math inline\">\\(\\binom{n}{2n}\\)</span>-<span\r\nclass=\"math inline\">\\(\\binom{n-1}{2n}\\)</span>或<span\r\nclass=\"math inline\">\\(\\binom{n}{2n}\\)</span>-<span\r\nclass=\"math inline\">\\(\\binom{n+1}{2n}\\)</span></p>\r\n<figure>\r\n<img src=\"https://z3.ax1x.com/2021/09/05/hWtHv6.md.png\"\r\nalt=\"代码示例\" />\r\n<figcaption aria-hidden=\"true\">代码示例</figcaption>\r\n</figure>\r\n","tags":["Knowledge","组合数学"]},{"title":"树屋阶梯 题解","url":"/2022/04/12/%E6%A0%91%E5%B1%8B%E9%98%B6%E6%A2%AF-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"树屋阶梯-题解\">树屋阶梯 题解</h1>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<p>最开始，没有任何思路。</p>\r\n<p>于是看了两眼样例，猜了一些结论，发现这个有可能是对的。</p>\r\n<p>结论1：每个长度为<span\r\nclass=\"math inline\">\\(n\\)</span>的阶梯都至少需要<span\r\nclass=\"math inline\">\\(n\\)</span>个钢板。</p>\r\n<p>使用数学归纳法证明：</p>\r\n<span id=\"more\"></span>\r\n<p>当<span class=\"math inline\">\\(n=1\\)</span>时，需要一个钢板。</p>\r\n<p>假设这个结论在<span\r\nclass=\"math inline\">\\([0,n-1]\\)</span>都成立，我们需要钢板的数量最少，就需要搭建长度为<span\r\nclass=\"math inline\">\\(n-1\\)</span>的阶梯的最小钢板数量，即<span\r\nclass=\"math inline\">\\(n-1\\)</span>个，而新增的<span\r\nclass=\"math inline\">\\(n\\)</span>的这个钢板最上面的一个方格是不可能被之前的任何一个钢板覆盖的，所以这个地方必须要有一个钢板。其他地方的钢板可以直接让长度为<span\r\nclass=\"math inline\">\\(n-1\\)</span>的阶梯的钢板延伸过来，于是只用<span\r\nclass=\"math inline\">\\(n\\)</span>个钢板的方案一定存在。</p>\r\n<p>结论2：我们从右往左看，每次都能在竖直范围内找到一个新的钢板。且这个钢板必然覆盖嘴上面的一块。</p>\r\n<p>由结论1易得。</p>\r\n<p>必然有一块钢板覆盖左下角这个点，而它必然覆盖了一个顶点，我们枚举这个钢板覆盖的位置，发现它正好把这个阶梯分成另外两个部分，于是这就变成了求解子问题。</p>\r\n<p><span class=\"math inline\">\\(f[i] = \\sum_{j=0}^{i-1}f[j]\\cdot\r\nf[i-j-1]\\)</span>。</p>\r\n<p>这个东西打个表可以发现，跟卡特兰数一模一样，在oi-wiki上也有这个公式的介绍。</p>\r\n<p>于是，我们的目标就是求第<span\r\nclass=\"math inline\">\\(n\\)</span>项卡特兰数。</p>\r\n<h2 id=\"code\"><span class=\"math inline\">\\(Code\\)</span>：</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>())</span><br><span class=\"line\"><span class=\"built_in\">sum</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">int</span>(a)+<span class=\"number\">1</span>,<span class=\"built_in\">int</span>(a)*<span class=\"number\">2</span>+<span class=\"number\">1</span>,<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>*i</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span> (<span class=\"number\">1</span>,<span class=\"built_in\">int</span>(a)+<span class=\"number\">1</span>,<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>/i</span><br><span class=\"line\"><span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>/(<span class=\"built_in\">int</span>(a)+<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(<span class=\"built_in\">sum</span>))</span><br></pre></td></tr></table></figure>\r\n<p>（实在不想写高精啊）</p>\r\n","tags":["Knowledge","数学","组合数学"]},{"title":"糖果传递 题解","url":"/2022/04/12/%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"糖果传递-题解\">糖果传递 题解</h1>\r\n<h2 id=\"前言\">前言</h2>\r\n<p>一切都是推式子。</p>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<p>每个人都要补前面人的差值，补自己的差值。</p>\r\n<p>设<span class=\"math inline\">\\(x_i\\)</span>表示第<span\r\nclass=\"math inline\">\\(i\\)</span>个人从第<span\r\nclass=\"math inline\">\\(i+1\\)</span>个人那里拿了多少张牌，为正则是拿，为负则是送。</p>\r\n<p>于是，设第<span class=\"math inline\">\\(i\\)</span>个人的牌数是<span\r\nclass=\"math inline\">\\(s_i\\)</span>，则一定满足式子<span\r\nclass=\"math inline\">\\(s_i+x_i-x_{i-1} = avg\\)</span>。</p>\r\n<span id=\"more\"></span>\r\n<p>把所有人的式子都列出来：</p>\r\n<p><span class=\"math inline\">\\(s_1+x_1-x_n = avg\\\\s_2+x_2-x_1 =\r\navg\\\\\\cdots\\\\s_n+x_n-x_{n-1} = avg\\)</span></p>\r\n<p>我们花费的代价是<span\r\nclass=\"math inline\">\\(|x_1|+|x_2|+\\cdots+|x_n|\\)</span>，现在要使这个东西最小。</p>\r\n<p>这个东西直接凑不太好凑，我们考虑把它们都化为<span\r\nclass=\"math inline\">\\(x_1\\)</span>的形式。</p>\r\n<p><span class=\"math inline\">\\(x_2 = avg-s_2+x_1\\\\x_3 =\r\navg-s_3+avg-s_2+x_1 = 2avg-s_2-s_3+x_1\\\\x_4 = avg-s_4+2avg-s_2-s_3+x_1 =\r\n3avg-s_2-s_3-s_4+x_1\\)</span></p>\r\n<p>于是，这个式子就变成了<span\r\nclass=\"math inline\">\\(|x_1|+|x_1+avg-s_2|+|x_1+2avg-s_2-s_3|+\\cdots\r\n+|x_1+(n-1)avg-(s_2+s_3+\\cdots +s_n)|\\)</span>。</p>\r\n<p>显然，每个绝对值后面的数都是定值，这个可以直接预处理出来，我们不妨设每个绝对值后面的数为<span\r\nclass=\"math inline\">\\(f_i\\)</span>。</p>\r\n<p>则，式子可以化为<span\r\nclass=\"math inline\">\\(|x_1+f_1|+|x_1+f_2|+\\cdots+|x_1+f_n|\\)</span>。</p>\r\n<p>当<span\r\nclass=\"math inline\">\\(n\\)</span>为偶数时，根据初中学习的绝对值相关知识，画个数轴出来，可以发现，当<span\r\nclass=\"math inline\">\\(x_1\\)</span>在排序后的<span\r\nclass=\"math inline\">\\(f\\)</span>数组中的<span\r\nclass=\"math inline\">\\(-f_{n/2}\\)</span>和<span\r\nclass=\"math inline\">\\(-f_{n/2+1}\\)</span>之间时，值最小。</p>\r\n<p>当<span class=\"math inline\">\\(n\\)</span>为奇数时，<span\r\nclass=\"math inline\">\\(x_1\\)</span>在<span\r\nclass=\"math inline\">\\(-f_{(n+1)/2}\\)</span>时，值最小。</p>\r\n<p>于是，我们先把<span\r\nclass=\"math inline\">\\(f_i\\)</span>的值都算出来，再取<span\r\nclass=\"math inline\">\\(-f_{(n+1)/2}\\)</span>，就是<span\r\nclass=\"math inline\">\\(x_1\\)</span>的取值，把结果算一下就行了。</p>\r\n<h2 id=\"code\"><span class=\"math inline\">\\(Code\\)</span>：</h2>\r\n<p>注意long long</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,a[N],f[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> avg = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tavg+=a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tavg/=n;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tsum+=a[i];</span><br><span class=\"line\">\t\tf[i] = avg*(i<span class=\"number\">-1</span>)-sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(f+<span class=\"number\">1</span>,f+<span class=\"number\">1</span>+n);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x = f[(n+<span class=\"number\">1</span>)/<span class=\"number\">2</span>],ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans+=<span class=\"built_in\">abs</span>(x-f[i]);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["Knowledge","贪心"]},{"title":"浅谈随机数据生成与对拍","url":"/2021/10/12/%E6%B5%85%E8%B0%88%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E4%B8%8E%E5%AF%B9%E6%8B%8D/","content":"<h2 id=\"背景\">背景</h2>\r\n<p>最近写了一个对拍器，自认为对于对拍有一定见解，但今天<span\r\nclass=\"math inline\">\\(cjf\\)</span>说如果用<span\r\nclass=\"math inline\">\\(srand(time(0))\\)</span>，在卑微的Windows系统下一秒钟实际上只对了一组数据，因为<span\r\nclass=\"math inline\">\\(time(0)\\)</span>在一秒钟内不会变化，写了个程序\r\n试了一下，确实如此 <span id=\"more\"></span> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;test.in&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,stdout);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>,las = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (a==las)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">\t\ta = <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!las) las = a;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\ncnt统计的是和最先一次rand出来的数相同的数的个数</p>\r\n<p>cnt大概有1e7-2e7，可见数据生成器生成数据的不随机性（除非你的程序用时太久，不能在1s内跑完生成的数据）</p>\r\n<p><strong>显然，这会对对拍的效率产生严重影响，那么应该如何生成完全随机的数据呢？</strong></p>\r\n<h2 id=\"方法\">方法</h2>\r\n<p>先用<span\r\nclass=\"math inline\">\\(srand\\)</span>生成10个左右的随机数，然后就可以得到10个随机种子，再用它们生成随机数，同时运行程序，就可以得到真正的随机数了。</p>\r\n<p>但这样有一个问题：生成的随机数都是5位数，所以在对拍几万个数据后，种子就是重复的了，那样就没有意义了，所以考虑生成更大的种子。</p>\r\n<p>在这里给出一种方法：用两个<span\r\nclass=\"math inline\">\\(for\\)</span>把种子乘起来当作种子，这样种子大概率就不同了。</p>\r\n<p>具体传种子的方法读者可以自己实现，在这里给出一种方式：<span\r\nclass=\"math inline\">\\(freopen\\)</span> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sed;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;seed.in&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">    cin&gt;&gt;sed;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>((<span class=\"keyword\">unsigned</span>)sed);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    your code here</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n具体生成随机数的方法： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> rs[<span class=\"number\">15</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">             rs[i] = <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=<span class=\"number\">10</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\">ofstream <span class=\"title\">output</span><span class=\"params\">(<span class=\"string\">&quot;seed.in&quot;</span>)</span></span>;</span><br><span class=\"line\">\t\t\t\toutput&lt;&lt;rs[i]*rs[j]&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;1.exe&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n其实一般只随机10个数也可以，重复周期较长</p>\r\n<h2 id=\"附录\">附录</h2>\r\n<p>貌似不生成数据，单独使用<span\r\nclass=\"math inline\">\\(fc\\)</span>比较文件很慢？（请读者自行测试100000行以上数据，本机测得<span\r\nclass=\"math inline\">\\(fc\\)</span>比字符比较慢很多） <img\r\nsrc=\"https://z3.ax1x.com/2021/10/12/5nzKv8.md.png\" alt=\"实测结果\" /></p>\r\n","tags":["Knowledge","Misc"]},{"title":"物质的分类","url":"/2022/02/11/%E7%89%A9%E8%B4%A8%E7%9A%84%E5%88%86%E7%B1%BB/","content":"<h2 id=\"物质的分类-分散系-氧化物分类\">物质的分类（ 分散系\r\n氧化物分类）</h2>\r\n<span id=\"more\"></span>\r\n<h3 id=\"制备feoh_3胶体的实验\">制备<span\r\nclass=\"math inline\">\\(Fe(OH)_3\\)</span>胶体的实验</h3>\r\n<p><span class=\"math inline\">\\(FeCl_3+3H_2O \\frac{\\Delta}{=}\r\nFe(OH)_3（胶体）+3HCl\\)</span><br />\r\n（原谅这丑陋的方程式）</p>\r\n<h5 id=\"要点\">要点：</h5>\r\n<p><strong>反应条件</strong>：加热<br />\r\n要在<span class=\"math inline\">\\(Fe(OH)_3\\)</span>后面<strong>加上胶体\r\n</strong> 不要和<span\r\nclass=\"math inline\">\\(NaOH\\)</span>反应去了，这样会直接生成沉淀<br />\r\n要用<strong>煮沸</strong>的<strong>蒸馏水</strong>，而且是将<span\r\nclass=\"math inline\">\\(FeCl_3\\)</span>加入蒸馏水中，颜色变成<strong>红褐色</strong>时<strong>立即</strong>停止加热<br />\r\n不能用<strong>玻璃棒搅拌</strong>，要<strong>振荡烧杯</strong><br />\r\n淀粉溶液是<strong>胶体</strong>！</p>\r\n<h5 id=\"扩展\">扩展：</h5>\r\n<p>虽然反应是这样进行的，但是如果再加入适量<span\r\nclass=\"math inline\">\\(HCl\\)</span>，会发生以下反应：<span\r\nclass=\"math inline\">\\(Fe(OH)_3+3HCl = FeCl_3+3H_2O\\)</span><br />\r\n我的理解是因为胶体微粒带电，似乎从某种程度上阻止了反应的进行，但是加入<span\r\nclass=\"math inline\">\\(HCl\\)</span>到一定程度后，两边的电荷逐渐失衡，反应才开始进行，为了电荷的再次平衡</p>\r\n<h4 id=\"胶体的性质\">胶体的性质</h4>\r\n<ul>\r\n<li>粒子大小介于<span class=\"math inline\">\\(1nm\\)</span>~<span\r\nclass=\"math inline\">\\(100nm\\)</span>之间，不能透过半透膜<br />\r\n</li>\r\n<li>光学性质：丁达尔效应。实际上就是拿个激光笔照射之后有通路，就一定是胶体<br />\r\n</li>\r\n<li>运动学性质：布朗运动。解释是做无规则运动，好像也是因为这个性质具有介稳性<br />\r\n</li>\r\n<li>电学性质：电泳现象。通俗点说就是往哪边跑，极性就与哪边相反，异性相吸嘛\r\n<ul>\r\n<li>应用：工厂静电除尘（尘是胶体）</li>\r\n<li>注意：胶体是电中性的，只有胶粒才带电</li>\r\n</ul></li>\r\n<li>热力学性质：胶体的聚沉。貌似并不知道原理是什么\r\n<ul>\r\n<li>方法1：加入[[电解质]]（之后会讲）</li>\r\n<li>方法2：加入与胶粒带相反电荷的胶体（见<span\r\nclass=\"math inline\">\\(\\downarrow\\)</span>的扩展）</li>\r\n<li>方法3：加热（实验中可能会考加热过度，现象是有红褐色固体生成）</li>\r\n<li>应用：三角洲形成，明矾净水，盐卤制豆腐</li>\r\n</ul></li>\r\n</ul>\r\n<h5 id=\"扩展-1\">扩展：</h5>\r\n<ol type=\"1\">\r\n<li>胶体的正负电荷 正电荷：金属氢氧化物（<span\r\nclass=\"math inline\">\\(Fe(OH)_3\\)</span>），金属氧化物（<span\r\nclass=\"math inline\">\\(Fe_2O_3\\)</span>）<br />\r\n负电荷：非金属氧化物（<span\r\nclass=\"math inline\">\\(As_2O_3\\)</span>），金属硫化物（好像没看见？），但看见了金属（<span\r\nclass=\"math inline\">\\(Au\\)</span>）<br />\r\n</li>\r\n<li>不同物态的胶体 气溶胶：烟、雾<br />\r\n液溶胶：<span\r\nclass=\"math inline\">\\(Fe(OH)_3\\)</span>胶体、豆浆、淀粉<strong>溶液</strong><br />\r\n固溶胶：有色玻璃，烟水晶（?）</li>\r\n</ol>\r\n<h4 id=\"氧化物的分类\">氧化物的分类</h4>\r\n<p>碱性氧化物：能和酸反应生成盐和水的氧化物，如<span\r\nclass=\"math inline\">\\(CuO\\)</span><br />\r\n酸性氧化物：能和碱反应生成盐和水的氧化物，如<span\r\nclass=\"math inline\">\\(CO_2, SO_3\\)</span><br />\r\n两性氧化物：酸碱特性皆具备，称为两性氧化物，如<span\r\nclass=\"math inline\">\\(Al_2O_3\\)</span><br />\r\n不成盐氧化物：两个特性都不具备的氧化物，如<span\r\nclass=\"math inline\">\\(NO,CO\\)</span><br />\r\n<strong>特殊氧化物</strong>：好像只提到了<span\r\nclass=\"math inline\">\\(Fe_3O_4\\)</span>和<span\r\nclass=\"math inline\">\\(Na_2O_2\\)</span>这两个</p>\r\n<h5 id=\"大体观点\">大体观点：</h5>\r\n<p><strong>碱性氧化物</strong> <strong>一定</strong>是\r\n<strong>金属氧化物</strong> <strong>没有反例！ </strong>\r\n<strong>酸性氧化物</strong> 大部分是 <strong>非金属氧化物</strong>\r\n反例：<span class=\"math inline\">\\(Mn_2O_7\\)</span><br />\r\n<strong>金属氧化物</strong> 不一定是 <strong>碱性氧化物</strong>\r\n反例：<span\r\nclass=\"math inline\">\\(Mn_2O_7\\)</span>（这个好像真的很好用），<span\r\nclass=\"math inline\">\\(Al_2O_3\\)</span>（两性氧化物）<br />\r\n<strong>非金属氧化物</strong> 不一定是 <strong>酸性氧化物</strong>\r\n反例：<span class=\"math inline\">\\(CO\\)</span>（不成盐氧化物）<br />\r\n<strong>酸性氧化物</strong> 大多可以和水反应生成相应的酸 反例：<span\r\nclass=\"math inline\">\\(SiO_2\\)</span><br />\r\n<strong>碱性氧化物</strong> 大多不能和水反应生成相应的碱 反例：<span\r\nclass=\"math inline\">\\(Na_2O\\)</span>，<span\r\nclass=\"math inline\">\\(CaO\\)</span></p>\r\n<h4 id=\"补充错题\">补充错题：</h4>\r\n","tags":["Knowledge","WHK"]},{"title":"约数","url":"/2022/04/02/%E7%BA%A6%E6%95%B0/","content":"<h1 id=\"约数\">约数</h1>\r\n<h2 id=\"算数基本定理的推论\">算数基本定理的推论</h2>\r\n<p>一个正整数<span class=\"math inline\">\\(n\\)</span>被唯一分解为<span\r\nclass=\"math inline\">\\(n = p_1^{c_1}p_2^{c_2}\\cdot \\cdot \\cdot\r\np_m^{c_m}\\)</span>，其中<span\r\nclass=\"math inline\">\\(c_i\\)</span>都是正整数，<span\r\nclass=\"math inline\">\\(p_i\\)</span>都是质数，且满足<span\r\nclass=\"math inline\">\\(p_1&lt;p_2&lt;\\cdot \\cdot \\cdot p_m\\)</span>。</p>\r\n<p>则<span class=\"math inline\">\\(n\\)</span>的正约数个数为<span\r\nclass=\"math inline\">\\((c_1+1)(c_2+1)\\cdot\\cdot\\cdot\r\n(c_m+1)\\)</span>，可以看作每个质因子上面的幂都有<span\r\nclass=\"math inline\">\\(c_i+1\\)</span>种选择。</p>\r\n<p><span class=\"math inline\">\\(n\\)</span>的约数和为<span\r\nclass=\"math inline\">\\((1+p_1+p_1^2+\\cdot\\cdot\\cdot+p_1^{c_1})\\cdot\\cdot\\cdot(1+p_m+p_m^2+\\cdot\\cdot\\cdot+p_m^{c_m})\\)</span>，这可以看作每一个质因子不同幂次的不同结果相加，再乘起来就涵盖了每一种可能，也就是约数和。</p>\r\n<span id=\"more\"></span>\r\n<p>如果学了等比数列的可以快速计算这个式子：</p>\r\n<p><span class=\"math inline\">\\(1+p_i+p_i^2+\\cdot\\cdot\\cdot+p_i^{c_i} =\r\n\\frac{p_i^{c_i+1}-1}{p_i-1}\\)</span></p>\r\n<p>这样只需要<span class=\"math inline\">\\(O(\\log\r\nn)\\)</span>的时间就能计算约数和。</p>\r\n<h2 id=\"求一个数的约数集合\">求一个数的约数集合</h2>\r\n<p>我们采用试除法，如前面所说，<span\r\nclass=\"math inline\">\\(n\\)</span>如果能表示为<span\r\nclass=\"math inline\">\\(n = a*b\\)</span>，那么<span\r\nclass=\"math inline\">\\(a\\)</span>和<span\r\nclass=\"math inline\">\\(b\\)</span>中必然有一个数小于等于<span\r\nclass=\"math inline\">\\(\\sqrt{n}\\)</span>。</p>\r\n<p>所以我们只用找到所有小于等于<span\r\nclass=\"math inline\">\\(\\sqrt{n}\\)</span>的约数，就能得到<span\r\nclass=\"math inline\">\\(n\\)</span>所有的约数。</p>\r\n<p><span class=\"math inline\">\\(Code\\)</span>：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (n%i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (n/i!=i) a.<span class=\"built_in\">push_back</span>(n/i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a.<span class=\"built_in\">begin</span>(),a.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sz = a.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;sz;i++) cout&lt;&lt;a[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>此算法的时间复杂度为<span\r\nclass=\"math inline\">\\(O(\\sqrt{n})\\)</span></p>\r\n<h2 id=\"求1n中所有数的约数集合\">求1~n中所有数的约数集合</h2>\r\n<p>这时，如果使用简单的试除法，就太慢了，时间复杂度为<span\r\nclass=\"math inline\">\\(O(n\\sqrt{n})\\)</span>。</p>\r\n<p>我们发现，对于一个数<span\r\nclass=\"math inline\">\\(d\\)</span>，它的所有倍数都一定有<span\r\nclass=\"math inline\">\\(d\\)</span>这一个约数，所以我们只要枚举约数，标记这个约数的所有倍数就可以在<span\r\nclass=\"math inline\">\\(O(n\\log n)\\)</span>的时间内完成。</p>\r\n<p>推论：1~n中每个数约数的总和为<span class=\"math inline\">\\(O(n\\log\r\nn)\\)</span>个，每个数平均有<span class=\"math inline\">\\(\\log\r\nn\\)</span>个约数。</p>\r\n<p><span class=\"math inline\">\\(Code\\)</span>：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; a[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=n/i;j++)&#123;</span><br><span class=\"line\">\t\t\ta[i*j].<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(a[i].<span class=\"built_in\">begin</span>(),a[i].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sz = a[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;sz;j++) cout&lt;&lt;a[i][j]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>练习：</p>\r\n<p><a href=\"https://www.luogu.com.cn/problem/U198025\">U198025</a></p>\r\n<p><a href=\"https://www.luogu.com.cn/problem/P1463\">P1463</a></p>\r\n<h2 id=\"最大公约数\">最大公约数</h2>\r\n<p>两个数的约数中，最大的公共的约数叫做最大公约数。</p>\r\n<p>结论1：<span class=\"math inline\">\\(gcd(a,b)\\cdot lcm(a,b) = a\\cdot\r\nb\\)</span>。</p>\r\n<p>证明：<span class=\"math inline\">\\(lcm(a,b)\\)</span>中，<span\r\nclass=\"math inline\">\\(a,b\\)</span>不共同拥有的质因数一定存在，<span\r\nclass=\"math inline\">\\(a,b\\)</span>共同拥有的质因数只要达到最大的一个即可，所以除掉公共的因数，就是<span\r\nclass=\"math inline\">\\(lcm(a,b)\\)</span>。</p>\r\n<h3 id=\"求最大公约数\">求最大公约数</h3>\r\n<p><span class=\"math inline\">\\(gcd(a,b) = gcd(b,a\\ mod \\\r\nb)\\)</span>。</p>\r\n<p>证明：</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(a\\leq b\\)</span>，<span\r\nclass=\"math inline\">\\(gcd(a,b) = gcd(b,a \\ mod \\ b) =\r\ngcd(b,a)\\)</span>。</li>\r\n<li><span class=\"math inline\">\\(a&gt;b\\)</span>，<span\r\nclass=\"math inline\">\\(gcd(a,b) = gcd(b,a \\ mod \\ b) = gcd(b,a-k\\cdot\r\nb)\\)</span>，如果最大公约数<span\r\nclass=\"math inline\">\\(d|a\\)</span>，<span\r\nclass=\"math inline\">\\(d|b\\)</span>，那么<span\r\nclass=\"math inline\">\\(d|k\\cdot b\\)</span>，则<span\r\nclass=\"math inline\">\\(d|a-k\\cdot b\\)</span>。</li>\r\n</ol>\r\n<h2 id=\"互质\">互质</h2>\r\n<p>如果<span class=\"math inline\">\\(gcd(a,b) = 1\\)</span>，那么<span\r\nclass=\"math inline\">\\(a\\)</span>和<span\r\nclass=\"math inline\">\\(b\\)</span>就互质。</p>\r\n<p>对于3个数或更多数的情况，我们把<span class=\"math inline\">\\(gcd(a,b,c)\r\n= 1\\)</span>称为<span class=\"math inline\">\\(a\\)</span>、<span\r\nclass=\"math inline\">\\(b\\)</span>和<span\r\nclass=\"math inline\">\\(c\\)</span>这3个数互质。</p>\r\n<h2 id=\"欧拉函数\">欧拉函数</h2>\r\n<p>1~n中和n互质的数的个数叫做欧拉函数，记为<span\r\nclass=\"math inline\">\\(\\varphi(n)\\)</span></p>\r\n<p>怎么计算这个东西呢？</p>\r\n<p>我们考虑哪些数和n互质，所有n的质因子的倍数都和n互质，而且仅有这些数和n互质，所以我们需要把这些数都找出来。</p>\r\n<p>对于n的一个质因子p，有<span\r\nclass=\"math inline\">\\(n/p\\)</span>个p的倍数，对于n的另一个质因子q，有<span\r\nclass=\"math inline\">\\(n/q\\)</span>个q的倍数，把这些都减掉之后，还要加上既是p的倍数，又是q的倍数的数，于是要加上<span\r\nclass=\"math inline\">\\(n/pq\\)</span>，这样，对于只含有两个质因子p、q的n来说，<span\r\nclass=\"math inline\">\\(\\varphi(n) = n-n/p-n/q+n/pq =(n-n/p)-1/q(n-n/p) =\r\nn(1-1/q)(1-1/p)\\)</span>。</p>\r\n<p>把这个性质推广到<span class=\"math inline\">\\(n =\r\np_1^{c_1}p_2^{c_2}\\cdot \\cdot \\cdot p_m^{c_m}\\)</span>，可以得到：</p>\r\n<p>性质1：<span class=\"math inline\">\\(\\varphi(n) =\r\nn(1-\\frac{1}{p_1})\\cdot\\cdot\\cdot (1-\\frac{1}{p_m})\\)</span>。</p>\r\n<p>性质2：当<span\r\nclass=\"math inline\">\\(n&gt;1\\)</span>时，与n互质的数的和为<span\r\nclass=\"math inline\">\\(n/2\\cdot\\varphi(n)\\)</span>。</p>\r\n<p>证明：若c是n的约数，那么n-c也是n的约数，所以与n不互质的数成对出现，和都为n，那么平均值就是<span\r\nclass=\"math inline\">\\(n/2\\)</span>，所以和n互质的数的平均值也是<span\r\nclass=\"math inline\">\\(n/2\\)</span>，于是与n互质的数的和就是<span\r\nclass=\"math inline\">\\(n/2\\cdot\\varphi(n)\\)</span>。</p>\r\n<p>性质3：若<span class=\"math inline\">\\(a,b\\)</span>互质，那么<span\r\nclass=\"math inline\">\\(\\varphi(ab) =\r\n\\varphi(a)\\cdot\\varphi(b)\\)</span>。</p>\r\n<p>证明：直接按定义式计算即可。</p>\r\n<p>虽然这个性质看上去比较显然，但是由此我们可以引出一个重要的东西：积性函数。</p>\r\n<p>如果当a和b互质时，有<span class=\"math inline\">\\(f(ab) = f(a)\\cdot\r\nf(b)\\)</span>，那么称函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>为积性函数。</p>\r\n<p>性质4：对于所有积性函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>，<span class=\"math inline\">\\(f(n) =\r\n\\Pi_{i=1}^mf(p_i^{c_i})\\)</span>，此处<span\r\nclass=\"math inline\">\\(p_i\\)</span>和<span\r\nclass=\"math inline\">\\(c_i\\)</span>是n按照算数基本定理分解出来的质因数和对应的幂。</p>\r\n<p>证明：因为对于任意两个不相同的<span\r\nclass=\"math inline\">\\(p_i\\)</span>来说，它们肯定互质，所以可以按照积性函数的性质乘起来，之后就得到了n。</p>\r\n<p>性质5：若<span class=\"math inline\">\\(p|n\\)</span>且<span\r\nclass=\"math inline\">\\(p^2|n\\)</span>，则<span\r\nclass=\"math inline\">\\(\\varphi(n) = \\varphi(n/p)\\cdot\r\np\\)</span>，这个可以由定义得到。</p>\r\n<p>性质6：若<span class=\"math inline\">\\(p|n\\)</span>且<span\r\nclass=\"math inline\">\\(p^2\\nmid n\\)</span>，则<span\r\nclass=\"math inline\">\\(\\varphi(n) = \\varphi(n/p)\\cdot p\\cdot\r\n\\frac{p-1}{p} = \\varphi(n)\\cdot(p-1)\\)</span>。</p>\r\n<p>性质7：<span class=\"math inline\">\\(\\sum_{d\\mid n}\\varphi(d) =\r\nn\\)</span>。</p>\r\n<p>证明：好像还不会证。。。</p>\r\n","tags":["Knowledge","数学"]},{"title":"网络流初步","url":"/2022/03/07/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E6%AD%A5/","content":"<h2 id=\"求解最大流\">求解最大流</h2>\r\n<h3 id=\"edmond-karp算法ek算法\">Edmond Karp算法（EK算法）</h3>\r\n<p>这种算法不是很常用，但是比较好理解，没有什么分层图之类的优化技巧，可以直接感性理解求解网络流问题的基本思想。此算法复杂度为<span\r\nclass=\"math inline\">\\(O(nm^2)\\)</span>，虽说很多时候卡不满，但是和SPFA一样，<strong>有被不经意间（刻意）卡掉的风险</strong>。</p>\r\n<span id=\"more\"></span>\r\n<p>首先，我们要知道什么是一个<strong>网络</strong>。其实是给你一张图，其中有一个<strong>源点</strong><span\r\nclass=\"math inline\">\\(s\\)</span>，一个<strong>汇点</strong><span\r\nclass=\"math inline\">\\(t\\)</span>，源点负责发放流量，汇点负责收集流量，网络中的边都有<strong>流量限制</strong>，也就是说经过这条边的流量不能超过这个限制。我们要的是到达汇点的流量最大。其中源点供应的流量是无限的。</p>\r\n<p>遍历整个图，每次尝试寻找一条<strong>增广路</strong>（一条从<span\r\nclass=\"math inline\">\\(s\\)</span>到<span\r\nclass=\"math inline\">\\(t\\)</span>的路径，其中所有边的剩余流量都大于<span\r\nclass=\"math inline\">\\(0\\)</span>），在找不到增广路时就找到了<strong>最大流</strong>。每找到一条增广路，我们就把这条路的所有边的剩余容量减少，表示有流从这里经过。</p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/flow1.png\" /></p>\r\n<p>我们先走<span class=\"math inline\">\\(4 \\rightarrow 2\r\n\\rightarrow3\\)</span>，这样有20的流量从<span\r\nclass=\"math inline\">\\(2\\)</span>到达<span\r\nclass=\"math inline\">\\(3\\)</span>，我们将<span\r\nclass=\"math inline\">\\(4\\rightarrow2\\rightarrow3\\)</span>这条增广路的剩余流量修改一下，<span\r\nclass=\"math inline\">\\(4\\rightarrow2\\)</span>变成<span\r\nclass=\"math inline\">\\(10\\)</span>，<span\r\nclass=\"math inline\">\\(2\\rightarrow3\\)</span>变成<span\r\nclass=\"math inline\">\\(0\\)</span>，这样我们就得到了一个<strong>残量网络</strong>（即已经有部分流量被占用了）。再走<span\r\nclass=\"math inline\">\\(4\\rightarrow3\\)</span>，<span\r\nclass=\"math inline\">\\(4\\rightarrow3\\)</span>修改为<span\r\nclass=\"math inline\">\\(0\\)</span>。走<span\r\nclass=\"math inline\">\\(4\\rightarrow2\\rightarrow1\\rightarrow3\\)</span>，由于最小的边是<span\r\nclass=\"math inline\">\\(4\\rightarrow2\\)</span>，所以只有<span\r\nclass=\"math inline\">\\(10\\)</span>的流量流到<span\r\nclass=\"math inline\">\\(3\\)</span>。</p>\r\n<p>于是，我们就得到了这个网络的最大流量：<span\r\nclass=\"math inline\">\\(50\\)</span>。</p>\r\n<p>但是，随便找一条增广路就是最优的吗，显然不是：</p>\r\n<p><img\r\nsrc=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/1.png\" /></p>\r\n<p>如上图，每条边的容量都是<span\r\nclass=\"math inline\">\\(1\\)</span>，那么我们随便选一个增广路：<span\r\nclass=\"math inline\">\\(s\\rightarrow1\\rightarrow2\\rightarrow\r\nt\\)</span>，这样我们就得到了<span\r\nclass=\"math inline\">\\(1\\)</span>的流量，但是<span\r\nclass=\"math inline\">\\(s\\rightarrow2\\)</span>和<span\r\nclass=\"math inline\">\\(1\\rightarrow t\\)</span>都流不了任何东西了。</p>\r\n<p>换一种选法：<span class=\"math inline\">\\(s\\rightarrow1\\rightarrow\r\nt\\)</span>和<span class=\"math inline\">\\(s\\rightarrow2\\rightarrow\r\nt\\)</span>，这样我们就可以得到<span\r\nclass=\"math inline\">\\(2\\)</span>的流量，比之前瞎选的优。</p>\r\n<p>如果不能瞎选，该如何解决这种问题呢？</p>\r\n<p>由于网络有很多种，我们显然不能针对每种情况都设计一个算法，使得每次选择的路径都是最优的，更好的方法是不断尝试，逐渐把不优的替换掉，而这种替换需要一个反悔的工具：<strong>反向边</strong>。</p>\r\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/2.png\" style=\"zoom:67%;\" /></p>\r\n<p>我们再次从<span\r\nclass=\"math inline\">\\(s\\)</span>开始寻找增广路，可以从<span\r\nclass=\"math inline\">\\(s\\rightarrow2\\rightarrow1\\rightarrow\r\nt\\)</span>，这样就可以得到最大流量<span\r\nclass=\"math inline\">\\(2\\)</span>了。</p>\r\n<p>但这样为什么是对的呢？</p>\r\n<p>这一次走了从<span\r\nclass=\"math inline\">\\(2\\rightarrow1\\)</span>的反向边，可以看作<span\r\nclass=\"math inline\">\\(1\\)</span>原来流到<span\r\nclass=\"math inline\">\\(2\\)</span>的流回去了（反向边相当于把流送回去），再流向之后走的<span\r\nclass=\"math inline\">\\(1\\rightarrow t\\)</span>，而原来流向<span\r\nclass=\"math inline\">\\(2\\rightarrow t\\)</span>的流量由<span\r\nclass=\"math inline\">\\(s\\rightarrow2\\)</span>提供，这样就可以得到一条增广路了。当没有增广路时，说明我们找到了最大流（虽然我并不会证明这个的正确性）。</p>\r\n<p>时间复杂度简易证明：</p>\r\n<p>假设网络上有<span class=\"math inline\">\\(n\\)</span>个点，<span\r\nclass=\"math inline\">\\(m\\)</span>条边。</p>\r\n<p>第一个结论：在EK算法中，<span class=\"math inline\">\\(t\\)</span>和<span\r\nclass=\"math inline\">\\(s\\)</span>间的最短路长度一定是不降的，因为每次增广一个路径，这个路径按照<span\r\nclass=\"math inline\">\\(BFS\\)</span>是最短的路径，所以每次必然减少一个最短路径，我们考虑最坏的情况，变成一个二分图之类的东西，最短路的长度都为<span\r\nclass=\"math inline\">\\(3\\)</span>，这时需要增广<span\r\nclass=\"math inline\">\\(m\\)</span>次，也就是说最短路的长度不变时，最多增广<span\r\nclass=\"math inline\">\\(m\\)</span>次。</p>\r\n<p>第二个结论：每次<span\r\nclass=\"math inline\">\\(BFS\\)</span>的时间复杂度为<span\r\nclass=\"math inline\">\\(O(m)\\)</span>。</p>\r\n<p>第三个结论：每次增广中必然出现一个边，其剩余流量被完全占用，这条边要再有流量，需要反向边被增广，也就是说它再有剩余流量时，肯定是<span\r\nclass=\"math inline\">\\(t\\)</span>和<span\r\nclass=\"math inline\">\\(s\\)</span>之间的最短距离增加<span\r\nclass=\"math inline\">\\(2\\)</span>时，才能被再次增广。由于一共只有<span\r\nclass=\"math inline\">\\(n\\)</span>个点，最短路的长度最大是<span\r\nclass=\"math inline\">\\(n\\)</span>，改变次数最多为<span\r\nclass=\"math inline\">\\(n/2\\)</span>次。</p>\r\n<p>综合一、三结论，可得增广复杂度最多为<span\r\nclass=\"math inline\">\\(O(nm)\\)</span>，而每次增广的复杂度最多时<span\r\nclass=\"math inline\">\\(O(m)\\)</span>，所以EK算法的时间复杂度是<span\r\nclass=\"math inline\">\\(O(nm^2)\\)</span>。</p>\r\n<p><span class=\"math inline\">\\(Code\\)</span>：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,tim = <span class=\"number\">1</span>,vis[N],inc[N],pre[N],Max;</span><br><span class=\"line\">queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">e</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\tq.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\tvis[s] = tim;</span><br><span class=\"line\">\tinc[s] = inf;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; vis[y]!=tim)&#123;</span><br><span class=\"line\">\t\t\t\tinc[y] = <span class=\"built_in\">min</span>(inc[x],edge[i].w);</span><br><span class=\"line\">\t\t\t\tpre[y] = i;</span><br><span class=\"line\">\t\t\t\tvis[y] = tim;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> now = t,incf = inc[t];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (now!=s)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = pre[now];</span><br><span class=\"line\">\t\tedge[i].w-=incf;</span><br><span class=\"line\">\t\tedge[i^<span class=\"number\">1</span>].w+=incf;</span><br><span class=\"line\">\t\tnow = edge[i^<span class=\"number\">1</span>].to;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tMax+=incf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x,y,w;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,w);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">\t\ttim++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;Max&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"dinic算法\">Dinic算法</h3>\r\n<p>主要思想：</p>\r\n<p>先做一次BFS将图按到<span\r\nclass=\"math inline\">\\(s\\)</span>的最短路长度分层，之后做一次DFS（每次增广时可以多路增广），每次只向最短路长度比它大<span\r\nclass=\"math inline\">\\(1\\)</span>的点输出流量，这样找下去，直到<span\r\nclass=\"math inline\">\\(t\\)</span>到<span\r\nclass=\"math inline\">\\(s\\)</span>没有路径，说明没有增广路了，也就是找到了最大流。</p>\r\n<p>时间复杂度证明：</p>\r\n<p>第一个结论：每次增广，必然把所有能够增广的都增广了，也就是说<span\r\nclass=\"math inline\">\\(t\\)</span>到<span\r\nclass=\"math inline\">\\(s\\)</span>的最短路的长度至少增加<span\r\nclass=\"math inline\">\\(1\\)</span>，最多增加<span\r\nclass=\"math inline\">\\(n\\)</span>次</p>\r\n<p>第二个结论：每次<span\r\nclass=\"math inline\">\\(BFS\\)</span>，时间复杂度为<span\r\nclass=\"math inline\">\\(O(m)\\)</span>，每次<span\r\nclass=\"math inline\">\\(DFS\\)</span>，我们都要维护一个当前弧，也就是说当前弧最多变化<span\r\nclass=\"math inline\">\\(nm\\)</span>次，于是单次增广的时间复杂度最大为<span\r\nclass=\"math inline\">\\(O(nm)\\)</span></p>\r\n<p>综合一、二结论，Dinic算法的时间复杂度最大为<span\r\nclass=\"math inline\">\\(O(n^2m)\\)</span></p>\r\n<p>也就是说，它适合处理稠密图，但在<span\r\nclass=\"math inline\">\\(n\\)</span>是<span\r\nclass=\"math inline\">\\(1e3\\)</span>级别，<span\r\nclass=\"math inline\">\\(m\\)</span>是<span\r\nclass=\"math inline\">\\(1e5\\)</span>级别，Dinic算法可能无法在给定时间内处理所有情况，这时就需要用到HLPP了。</p>\r\n<p><span class=\"math inline\">\\(Code\\)</span>：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,d[N],now[N];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\">queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">e</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(d,<span class=\"number\">0</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(d));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\td[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tnow[s] = head[s];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !d[y])&#123;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t\t\td[y] = d[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tnow[y] = head[y];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> flow)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> v,use,res = flow,i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=now[u];i &amp;&amp; res;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\tnow[u] = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; d[v] == d[u]+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tuse = <span class=\"built_in\">dfs</span>(v,<span class=\"built_in\">min</span>(edge[i].w,res));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!use) d[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tedge[i].w-=use;</span><br><span class=\"line\">\t\t\tedge[i^<span class=\"number\">1</span>].w+=use;</span><br><span class=\"line\">\t\t\tres-=use;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> flow-res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x,y,w;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,w);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> flow;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tflow = <span class=\"built_in\">dfs</span>(s,inf);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!flow) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tans+=flow;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n","tags":["Knowledge","网络流"]},{"title":"背包问题浅析","url":"/2022/02/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/","content":"<h2 id=\"最基础的背包01背包\">最基础的背包——01背包</h2>\r\n<p>问题：</p>\r\n<p>给定一个容量为<span class=\"math inline\">\\(w\\)</span>的背包，有<span\r\nclass=\"math inline\">\\(n\\)</span>件物品，每件物品都有一个价值<span\r\nclass=\"math inline\">\\(v\\)</span>和一个体积<span\r\nclass=\"math inline\">\\(c\\)</span>，问背包能装下的物品的最大价值和</p>\r\n<p>思路：</p>\r\n<p>每件物品都有选或不选(0或1)两种状态，考虑用此作为<span\r\nclass=\"math inline\">\\(dp\\)</span>的一个维度，对于特定容量的价值，是从之前的容量的价值递推出来的，故可以用此作为<span\r\nclass=\"math inline\">\\(dp\\)</span>的第二个维度，于是就有了<span\r\nclass=\"math inline\">\\(dp\\)</span>数组<span\r\nclass=\"math inline\">\\(f[i][j]\\)</span>表示考虑了前<span\r\nclass=\"math inline\">\\(i\\)</span>个物品，容量为<span\r\nclass=\"math inline\">\\(j\\)</span>时的最大价值</p>\r\n<p>如何转移呢？</p>\r\n<span id=\"more\"></span>\r\n<p>对<span\r\nclass=\"math inline\">\\(f\\)</span>数组的修改必然涉及到一个变量：价值<span\r\nclass=\"math inline\">\\(v\\)</span>，所以需要<span\r\nclass=\"math inline\">\\(v\\)</span>参与<span\r\nclass=\"math inline\">\\(dp\\)</span>的转移方程，稍加考虑即可推出一个简明的方程：</p>\r\n<p><span class=\"math inline\">\\(f[i][j] =\r\nmax(f[i-1][j],f[i-1][j-c[i]]+v[i])\\)</span></p>\r\n<p><span\r\nclass=\"math inline\">\\(max\\)</span>的第一项表示不选择这个物品，直接使用<span\r\nclass=\"math inline\">\\(i-1\\)</span>个物品的最大价值；第二项表示选择这个物品，所获得的价值是不放这个物品的背包的最大价值加上这个物品的价值</p>\r\n<p>可以发现，这个方程只和第<span\r\nclass=\"math inline\">\\(i\\)</span>项和第<span\r\nclass=\"math inline\">\\(i-1\\)</span>项有关，所以可以使用滚动数组做空间优化，即<span\r\nclass=\"math inline\">\\(f[j] = max(f[j],f[j-c[i]]+v[i])\\)</span></p>\r\n<p>但是，需要注意此处可能对<span\r\nclass=\"math inline\">\\(f[j]\\)</span>进行修改，但是我们需要用的是修改之前的值，所以需要倒序修改<span\r\nclass=\"math inline\">\\(f[j]\\)</span>，防止<span\r\nclass=\"math inline\">\\(f[j-c[i]]\\)</span>变成了现在的价值，而不是在放入<span\r\nclass=\"math inline\">\\(i-1\\)</span>个物品的价值</p>\r\n<p>时间复杂度：<span class=\"math inline\">\\(O(nw)\\)</span></p>\r\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1048\">P1048\r\n采药</a></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">int</span> w,n,v[<span class=\"number\">105</span>],c[<span class=\"number\">105</span>],f[<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;w&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;c[i]&gt;&gt;v[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=w;j&gt;=c[i];j--) f[j] = <span class=\"built_in\">max</span>(f[j],f[j-c[i]]+v[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[w]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"背包的变形完全背包\">01背包的变形——完全背包</h2>\r\n<p>问题：</p>\r\n<p>给定一个容量为<span class=\"math inline\">\\(w\\)</span>的背包，有<span\r\nclass=\"math inline\">\\(n\\)</span><strong>种</strong>物品，每<strong>种</strong>物品都有一个价值<span\r\nclass=\"math inline\">\\(v\\)</span>和一个体积<span\r\nclass=\"math inline\">\\(c\\)</span>，<strong>且数量无限</strong>，问背包能装下的物品的最大价值和</p>\r\n<p>思路：</p>\r\n<p>还是考虑原来的<span class=\"math inline\">\\(dp\\)</span>方程：</p>\r\n<p><span class=\"math inline\">\\(f[j] =\r\nmax(f[j],f[j-c[i]]+v[i])\\)</span></p>\r\n<p>把修改顺序变为正序修改，思考一下<span\r\nclass=\"math inline\">\\(f[j]\\)</span>的意义</p>\r\n<p>当<span class=\"math inline\">\\(j&#39; = j+c[i]\\)</span>时，<span\r\nclass=\"math inline\">\\(f[j&#39;] = f[j]+v[i]\\)</span>，此时的<span\r\nclass=\"math inline\">\\(f[j]\\)</span>表示的是考虑<strong>前<span\r\nclass=\"math inline\">\\(i\\)</span>个</strong>物品的最大值，显然当前物品放入的情况也被考虑进去了，所以此时正序递推正好满足题目要求</p>\r\n<p>时间复杂度：<span class=\"math inline\">\\(O(nw)\\)</span></p>\r\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1616\">P1616\r\n疯狂的采药</a></p>\r\n<p><strong>注意：</strong></p>\r\n<p>1.数据范围更改了</p>\r\n<p>2.由于<span class=\"math inline\">\\(w\\)</span>可能到<span\r\nclass=\"math inline\">\\(1e7\\)</span>，而且每种物品的价值可能到<span\r\nclass=\"math inline\">\\(1e4\\)</span>，如果一件物品，它的价值是<span\r\nclass=\"math inline\">\\(1e4\\)</span>，体积是<span\r\nclass=\"math inline\">\\(1\\)</span>，那么结果可能会到<span\r\nclass=\"math inline\">\\(1e11\\)</span>，需要开<span\r\nclass=\"math inline\">\\(long\\ long\\)</span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">int</span> w,n,v[<span class=\"number\">10005</span>],c[<span class=\"number\">10005</span>];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> f[<span class=\"number\">10000005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;w&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;c[i]&gt;&gt;v[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=c[i];j&lt;=w;j++) f[j] = <span class=\"built_in\">max</span>(f[j],f[j-c[i]]+v[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[w]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"优化后的01背包多重背包\">优化后的01背包——多重背包</h2>\r\n<p>问题：</p>\r\n<p>给定一个容量为<span class=\"math inline\">\\(w\\)</span>的背包，有<span\r\nclass=\"math inline\">\\(n\\)</span>种物品，每种物品都有一个价值<span\r\nclass=\"math inline\">\\(v\\)</span>和一个体积<span\r\nclass=\"math inline\">\\(c\\)</span>，<strong>且数量为<span\r\nclass=\"math inline\">\\(m\\)</span>个</strong>，问背包能装下的物品的最大价值和</p>\r\n<p>因为每种物品数量有限，所以无法用完全背包求解（可能会使用多于<span\r\nclass=\"math inline\">\\(m\\)</span>个物品），考虑将其转化为01背包</p>\r\n<p>最朴素的想法是把每种物品拆成<span\r\nclass=\"math inline\">\\(m\\)</span>个单独的物品，把所有的物品都单独拿出来，这样就变成了01背包问题</p>\r\n<p>但是，这样做的复杂度是<span\r\nclass=\"math inline\">\\(O(nmw)\\)</span>的，在<span class=\"math inline\">\\(n\r\n\\geq 1000\\)</span>时就跑不过了，所以要考虑优化</p>\r\n<p>由于二进制的很多特殊性质，以及对<span\r\nclass=\"math inline\">\\(log\\)</span>的谜之追求，出现了一种优化方法：二进制拆分</p>\r\n<p><del>众所周知，任何一个数都可以被表示为二进制形式</del></p>\r\n<p>例如：$ 42 = (101010)_2$</p>\r\n<p>所以，我们把这<span\r\nclass=\"math inline\">\\(m\\)</span>个物品拆成一堆二进制，例如上面的<span\r\nclass=\"math inline\">\\(42\\)</span>可以拆成<span\r\nclass=\"math inline\">\\((1)_2=1\\)</span>,<span\r\nclass=\"math inline\">\\((10)_2=2\\)</span>,<span\r\nclass=\"math inline\">\\((100)_2=4\\)</span>,<span\r\nclass=\"math inline\">\\((1000)_2=8\\)</span>,<span\r\nclass=\"math inline\">\\((10000)_2=16\\)</span>,最后剩下来一个<span\r\nclass=\"math inline\">\\(11\\)</span>。</p>\r\n<p>不难看出，前面<span\r\nclass=\"math inline\">\\(5\\)</span>个二进制可以组成<span\r\nclass=\"math inline\">\\(0 \\sim 31\\)</span>中的任何一个数，而其中的<span\r\nclass=\"math inline\">\\(32 \\sim 42\\)</span>中的所有数都可以由<span\r\nclass=\"math inline\">\\(21 \\sim 31\\)</span>加上<span\r\nclass=\"math inline\">\\(11\\)</span>得到，所以<span class=\"math inline\">\\(0\r\n\\sim 42\\)</span>中的所有数都可以由这些拆出来的数组合得到</p>\r\n<p>这样，我们可以把每个背包拆成这些物品，之后当作01背包求解，于是复杂度就降低到了<span\r\nclass=\"math inline\">\\(O(n \\log mw)\\)</span></p>\r\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P6567\">P6567\r\n买表</a></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">4e2</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,k[N],a[N],t,f[<span class=\"number\">500010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;k[i]&gt;&gt;a[i];</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> bas = k[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">30</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[i]&lt;(<span class=\"number\">1</span>&lt;&lt;j)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p=<span class=\"number\">500005</span>;p&gt;=bas;p--) <span class=\"keyword\">if</span> (f[p-bas]) f[p] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tbas&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\ta[i]-=(<span class=\"number\">1</span>&lt;&lt;j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[i])&#123;</span><br><span class=\"line\">\t\t\tbas = a[i]*k[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">500005</span>;j&gt;=bas;j--) <span class=\"keyword\">if</span> (f[j-bas]) f[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;t;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (f[t]) cout&lt;&lt;<span class=\"string\">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"融合的01背包分组背包\">融合的01背包——分组背包</h2>\r\n<p>问题：</p>\r\n<p>给你<span\r\nclass=\"math inline\">\\(n\\)</span>个物品，每个物品属于一个组，同一组中只能选择一个物品，问容量为<span\r\nclass=\"math inline\">\\(m\\)</span>的背包的最大价值</p>\r\n<p>思路：</p>\r\n<p>同一组中的所有物品都只能选一次，我们通过01背包来限制选择的次数</p>\r\n<p>同一组中的所有物品只能选一个，我们通过同一价值来避免一个组中选择多个物品</p>\r\n<p>时间复杂度：<span class=\"math inline\">\\(O(nm)\\)</span></p>\r\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1757\">P1757\r\n通天之分组背包</a></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,f[N];</span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; v[N],w[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\tw[z].<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">\t\tv[z].<span class=\"built_in\">push_back</span>(y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sz = w[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=m;j&gt;=<span class=\"number\">0</span>;j--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p=<span class=\"number\">0</span>;p&lt;sz;p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (j&gt;=w[i][p])&#123;</span><br><span class=\"line\">\t\t\t\t\tf[j] = <span class=\"built_in\">max</span>(f[j],f[j-w[i][p]]+v[i][p]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n","tags":["Knowledge","DP"]},{"title":"自建题目目录与解答","url":"/2022/01/15/%E8%87%AA%E5%BB%BA%E9%A2%98%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%8E%E8%A7%A3%E7%AD%94/","content":"<h2 id=\"tri\"><a\r\nhref=\"https://www.luogu.com.cn/problem/U198025\">Tri</a></h2>\r\n<p>首先考虑最暴力的做法，只用把所有的三角形数都枚举一遍，再看看因数数量即可，但是，假设判断了<span\r\nclass=\"math inline\">\\(q\\)</span>个三角形数，其中每个数为<span\r\nclass=\"math inline\">\\(m\\)</span>，如果<span class=\"math inline\">\\(\\sqrt\r\nm\\)</span>判断因数是否符合条件，会让总复杂度达到<span\r\nclass=\"math inline\">\\(q \\sqrt m\\)</span>级别的，这显然是无法接受的</p>\r\n<p>于是想到一个定理：</p>\r\n<p>如果一个数<span class=\"math inline\">\\(p\\)</span>能够被表示为<span\r\nclass=\"math inline\">\\(p =\r\n{a_1}^{k1}+{a_2}^{k2}+...+{a_n}^{k_n}\\)</span>，那么<span\r\nclass=\"math inline\">\\(p\\)</span>的因数个数即为<span\r\nclass=\"math inline\">\\((k_1+1)*(k_2+1)*...*(k_n+1)\\)</span>，这代表我们只需要知道一个数的所有质因数，就可以知道它的约数个数，于是总时间复杂度就被降低到了<span\r\nclass=\"math inline\">\\(O(q\\log m)\\)</span>级别的，有了很可观的改善</p>\r\n<span id=\"more\"></span>\r\n<p><span class=\"math inline\">\\(Sample \\ Code:\\)</span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1e6</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">1e6</span>,k,vis[N*<span class=\"number\">2</span>],pri[N],tot;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&gt;N || vis[i]&lt;pri[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>,coun;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot &amp;&amp; x;i++)&#123;</span><br><span class=\"line\">\t\tcoun = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%pri[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcoun++;</span><br><span class=\"line\">\t\t\tx/=pri[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt*=coun;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cnt&gt;k) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tsum+=i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">chk</span>(sum)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;sum&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>但是对于<span class=\"math inline\">\\(n\\geq\r\n1200\\)</span>，这种算法也无法在<span\r\nclass=\"math inline\">\\(1.5s\\)</span>的时限内跑完，所以还需要优化</p>\r\n<p>如何优化呢？</p>\r\n<p>因为三角形数是形为<span\r\nclass=\"math inline\">\\(p*(p+1)/2\\)</span>的数，所以这个<span\r\nclass=\"math inline\">\\(p\\)</span>必然是根号级别的，可以从这里下手</p>\r\n<p>而且易证<span class=\"math inline\">\\(p\\)</span>和<span\r\nclass=\"math inline\">\\(p+1\\)</span>是互质的，其中包含的质因数必然完全不同，所以三角形数的因数可以由<span\r\nclass=\"math inline\">\\(p\\)</span>的因数和<span\r\nclass=\"math inline\">\\(p+1\\)</span>的因数相乘得到</p>\r\n<p>可以先把一定范围内的数的因数预处理出来，之后判断时直接调用即可</p>\r\n<p>这里采用了与上一份代码类似的因数个数计算方法</p>\r\n<p><span class=\"math inline\">\\(Sample \\ Code:\\)</span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1.5e5</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">1e5</span>,k,vis[N*<span class=\"number\">2</span>],pri[N],tot,v[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&gt;N || vis[i]&lt;pri[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>,coun;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\tcoun = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%pri[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcoun++;</span><br><span class=\"line\">\t\t\tx/=pri[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt*=coun;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++) v[i] = <span class=\"built_in\">get</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i%<span class=\"number\">2</span>) ans = v[i]*v[(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = v[i/<span class=\"number\">2</span>]*v[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans&gt;k)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">1ll</span>*i*(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;Set n to a bigger value&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>但是，对于更大的<span\r\nclass=\"math inline\">\\(n\\)</span>，这种算法却出奇的慢，原因就在于<span\r\nclass=\"math inline\">\\(get\\)</span>函数中大量使用取模和除法操作，而且判断了很多不能整除的质数，最后可能还没有最简单的加法来得快</p>\r\n<p>而且一个一个累加，虽然看上去很慢，但是每一个因数都累加到了，绝无重复操作和无用操作，极大的提高了算法的效率</p>\r\n<p>这里采用尝试法，把所有因数都试出来，虽然看上去接近于<span\r\nclass=\"math inline\">\\(O(n^2)\\)</span>，但是由于每个数的平均质因数在<span\r\nclass=\"math inline\">\\(log\\)</span>级别，所以其实是接近<span\r\nclass=\"math inline\">\\(O(n*\\log n)\\)</span>再带一个大常数的（前<span\r\nclass=\"math inline\">\\(1e7\\)</span>个数的因数计算花费<span\r\nclass=\"math inline\">\\(2s\\)</span>）</p>\r\n<p><span class=\"math inline\">\\(Sample \\ Code:\\)</span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2.8e6</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">2.5e6</span>,k,v[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=i;j&lt;=N;j+=i) v[j]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&amp;<span class=\"number\">1</span>) ans = v[i]*v[(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = v[i/<span class=\"number\">2</span>]*v[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans&gt;k)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">1ll</span>*i*(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;Set n to a bigger value&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>于是，这个简短的代码就是这道题目前的最优解了，题解愉快的结束了！</p>\r\n<p>为了防止不必要的卡常，已把本题时限开到<span\r\nclass=\"math inline\">\\(2s\\)</span>，默认开启<span\r\nclass=\"math inline\">\\(O2\\)</span>优化，即使你的<span\r\nclass=\"math inline\">\\(N\\)</span>设置的不是那么微妙，也是可以轻松通过的</p>\r\n","tags":["Knowledge","Misc"]},{"title":"超能粒子炮 题解","url":"/2022/04/12/%E8%B6%85%E8%83%BD%E7%B2%92%E5%AD%90%E7%82%AE-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"超能粒子炮-题解\">超能粒子炮 题解</h1>\r\n<h2 id=\"题目大意\">题目大意</h2>\r\n<p>让你求<span class=\"math inline\">\\((\\sum_{i=0}^kC_n^i \\mod 2333) \\mod\r\n2333\\)</span>。</p>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<p>题目中没有明确说明<span class=\"math inline\">\\(k\\)</span>和<span\r\nclass=\"math inline\">\\(n\\)</span>的关系，如果<span\r\nclass=\"math inline\">\\(k\\geq n\\)</span>，那么答案就是<span\r\nclass=\"math inline\">\\(2^n\\mod 2333\\)</span>。</p>\r\n<p>现在，我们只用考虑<span\r\nclass=\"math inline\">\\(k&lt;n\\)</span>的情况了。</p>\r\n<p><span class=\"math inline\">\\(k\\)</span>最大可以到<span\r\nclass=\"math inline\">\\(1e18\\)</span>，显然无法直接计算。</p>\r\n<span id=\"more\"></span>\r\n<p>但是这个模数较小，于是我们想到了Lucas定理，这样我们所有计算的东西都在2333以内了。</p>\r\n<p>手动模拟一下，当<span\r\nclass=\"math inline\">\\(i\\geq2333\\)</span>时，我们使用Lucas定理将式子变成<span\r\nclass=\"math inline\">\\(C_{n\\mod 2333}^{i\\mod 2333}\\cdot\r\nC_{n/2333}^{i/2333}\\)</span>。</p>\r\n<p>当<span class=\"math inline\">\\(2333\\leq i&lt;\r\n4666\\)</span>时，后面的东西没有变化，前面的就是<span\r\nclass=\"math inline\">\\(2^{n\\mod\r\n2333}-1\\)</span>。这启示我们这个式子中存在很多一样的东西，我们可以把它们捆绑在一起来降低复杂度。</p>\r\n<p>前面的东西就是一直循环的，我们现在需要计算后面的东西，而后面的东西也可以用Lucas定理化简：</p>\r\n<p><span class=\"math inline\">\\(C_{n/2333}^{i/2333} = C_{n/2333\\mod\r\n2333}^{i/2333\\mod 2333}\\cdot C_{n/{2333^2}}^{i/{2333^2}}\\)</span>。</p>\r\n<p>前面的东西每2333个数变化一次，后面的又可以重复计算，这不就可以用递归解决吗？</p>\r\n<p>设<span class=\"math inline\">\\(f(x,n)\\)</span>表示计算<span\r\nclass=\"math inline\">\\(\\sum_{i=0}^x\r\nC_{n}^i\\)</span>。这个式子可以简化成<span\r\nclass=\"math inline\">\\(\\sum_{i=0}^{x/p-1}C_{n/2333}^i\\cdot\r\n(\\sum_{j=0}^{2332}C_{n\\mod 2333}^j)+C_{n/2333}^{x/2333}\\cdot\r\n\\sum_{i=0}^{x\\mod 2333}C_{n\\mod 2333}^i\\)</span>。</p>\r\n<p>前面的一坨显然可以化为<span\r\nclass=\"math inline\">\\(f(k/p-1,n/2333)\\)</span>，这样就可以递归解决这个问题了。</p>\r\n<p>先花<span\r\nclass=\"math inline\">\\(2333^2\\)</span>的时间预处理出组合数和前缀和，之后用<span\r\nclass=\"math inline\">\\(T\\log^2 p\\)</span>的时间解决问题（有一个<span\r\nclass=\"math inline\">\\(\\log\\)</span>花在求<span\r\nclass=\"math inline\">\\(C_{n/2333}^{k/2333}\\)</span>上）。</p>\r\n<h2 id=\"code\"><span class=\"math inline\">\\(Code\\)</span>：</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">3e3</span>+<span class=\"number\">10</span>,p = <span class=\"number\">2333</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> t,n,k,c[N][N],sum[N][N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tc[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;p;j++) sum[<span class=\"number\">0</span>][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;p;i++)&#123;</span><br><span class=\"line\">\t\tc[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=i;j++) c[i][j] = (c[i<span class=\"number\">-1</span>][j]+c[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>])%p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;p;j++) sum[i][j] = sum[i][j<span class=\"number\">-1</span>]+c[i][j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lucas</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!x) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c[y%p][x%p]*<span class=\"built_in\">lucas</span>(x/p,y/p)%p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"built_in\">f</span>(x/p<span class=\"number\">-1</span>,n/p)*sum[n%<span class=\"number\">2333</span>][p<span class=\"number\">-1</span>]%p+<span class=\"built_in\">lucas</span>(x/p,n/p)*sum[n%<span class=\"number\">2333</span>][x%<span class=\"number\">2333</span>]%p)%p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"built_in\">f</span>(k,n)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["Knowledge","数学","组合数学"]},{"title":"莫队算法初步","url":"/2022/02/09/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/","content":"<h2 id=\"莫队的基本思想\">莫队的基本思想</h2>\r\n<p>简单的莫队是针对这样一种题目：给定很多离线的询问，没有修改，而且数据范围根号算法能过。</p>\r\n<p>一般的算法都是对单次查询过程进行优化，但莫队对询问进行了优化：</p>\r\n<span id=\"more\"></span>\r\n<p>把询问可能出现的区间分成<span class=\"math inline\">\\(\\sqrt\r\nn\\)</span>个块，再将询问排序，具体规则是先对左端点所在的块排序，如果左端点在同一块中，就对右端点升序排序。</p>\r\n<p>这样，我们把排序好的询问一个个计算，定义<span\r\nclass=\"math inline\">\\(L\\)</span>为当前左端点，<span\r\nclass=\"math inline\">\\(R\\)</span>为当前右端点，处理每个询问时把左端点和右端点都移动到当前询问的左、右端点处，移动时用<span\r\nclass=\"math inline\">\\(O(1)\\)</span>或接近的时间复杂度维护<span\r\nclass=\"math inline\">\\(L\\)</span>和<span\r\nclass=\"math inline\">\\(R\\)</span>之间的答案，移动好时，这个询问对应的答案就成了<span\r\nclass=\"math inline\">\\(L\\)</span>和<span\r\nclass=\"math inline\">\\(R\\)</span>之间的答案。</p>\r\n<p>但是莫队为什么快呢？因为对于每个块中的询问，左端点都是在这个块中活动<span\r\nclass=\"math inline\">\\(q\\)</span>次询问可能会卡成<span\r\nclass=\"math inline\">\\(q \\times \\sqrt\r\nn\\)</span>，假设每个询问都倍卡，左端点移动的复杂度最大就是<span\r\nclass=\"math inline\">\\(O(q \\times \\sqrt\r\nn)\\)</span>。再看右端点，如果每个块中右端点都从这个块的起点移动到了最后一个块的终点，右端点移动的复杂度最大就是<span\r\nclass=\"math inline\">\\(O(n \\times \\sqrt n)\\)</span>。如果<span\r\nclass=\"math inline\">\\(L\\)</span>和<span\r\nclass=\"math inline\">\\(R\\)</span>移动的代价为<span\r\nclass=\"math inline\">\\(w\\)</span>，总共的复杂度最大就是<span\r\nclass=\"math inline\">\\(O(w \\times (n+q) \\times \\sqrt n)\\)</span>。</p>\r\n<h3 id=\"例题\">例题</h3>\r\n<p><a href=\"https://www.luogu.com.cn/problem/P2709\">P2709\r\n小B的询问</a></p>\r\n<p><a href=\"http://zhengruioi.com/contest/966/problem/1992\">ZROI\r\n奇数</a></p>\r\n<p><a href=\"https://www.luogu.com.cn/problem/SP3267\">SP3267\r\nDQUERY</a></p>\r\n<p><a href=\"https://www.luogu.com.cn/problem/CF86D\">CF86D Powerful\r\narray</a></p>\r\n<p>To be added.</p>\r\n<h2 id=\"带修莫队\">带修莫队</h2>\r\n","tags":["Knowledge","分块"]},{"title":"质数","url":"/2022/04/01/%E8%B4%A8%E6%95%B0/","content":"<h1 id=\"质数\">质数</h1>\r\n<h2 id=\"定义\">定义</h2>\r\n<p>每个所有因数只有自己和1的数叫做<strong>质数</strong>，而其他不符合这个条件的数叫做<strong>合数</strong>。</p>\r\n<h2 id=\"筛出质数\">筛出质数</h2>\r\n<ul>\r\n<li>暴力筛法\r\n<ul>\r\n<li>每次取出所有小于它的不是1的数，判断是否为它的因数，如果全都不是，那么这个数就是质数。</li>\r\n<li>时间复杂度<span class=\"math inline\">\\(O(n)\\)</span>。</li>\r\n</ul></li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<ul>\r\n<li>优化过的暴力筛法\r\n<ul>\r\n<li>每次取出所有小于等于根号它的数，判断是否为它的因数，如果全都不是，那么这个数就是质数。</li>\r\n<li>正确性：每个合数必然有一个小于等于根号它的因数，可以用反证法证明。</li>\r\n<li>时间复杂度<span class=\"math inline\">\\(O(\\sqrt{n})\\)</span></li>\r\n</ul></li>\r\n<li>埃氏筛\r\n<ul>\r\n<li>每一个是质数的数都标记它的倍数为合数，所有没有被标记的就是质数。</li>\r\n<li>正确性：每个合数必然有至少一个质因子，而每个质数的质因子只有它本身。</li>\r\n<li>时间复杂度<span class=\"math inline\">\\(O(n\\log \\log\r\nn)\\)</span>。（反正接近线性，应该也没人会特意卡这个）</li>\r\n</ul></li>\r\n<li>欧式筛\r\n<ul>\r\n<li>我们模拟一下，可以发现埃氏筛中，有些数会被筛很多次，如12即被2筛过，也被3筛过，这样会浪费大量时间，如果我们规定每个数只能被它的最小质因子筛，那就不会重复筛一个数了。</li>\r\n<li>正确性：一个数的质因子之间有大小关系，我们只要让这个数被最小的质因子筛，顺序就是唯一的。</li>\r\n<li>时间复杂度<span\r\nclass=\"math inline\">\\(O(n)\\)</span>。比较推荐使用这种筛法，因为它还可以筛一些积性函数。</li>\r\n</ul></li>\r\n</ul>\r\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P3383\">P3383</a></p>\r\n<p><span class=\"math inline\">\\(Code\\)</span>：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e8</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,vis[N],pri[N],tot,lim;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123; <span class=\"comment\">//是质数 </span></span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (pri[j]&gt;vis[i] || <span class=\"number\">1ll</span>*pri[j]*i&gt;lim) <span class=\"keyword\">break</span>; <span class=\"comment\">//只能由最小的因数筛掉 </span></span><br><span class=\"line\">\t\t\tvis[pri[j]*i] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;lim&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\tcout&lt;&lt;pri[x]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"质因数分解\">质因数分解</h2>\r\n<p>从2~<span\r\nclass=\"math inline\">\\(\\sqrt{n}\\)</span>里面枚举因数，一直除，直到这个数不含有此因数为止。</p>\r\n<p>有没有可能除了一个合数呢？不可能。</p>\r\n<p>因为每个合数必然由比它小的质数组成，而我们把所有组成它的质数都除掉了，所以不可能出现合数。</p>\r\n<p>时间复杂度为<span\r\nclass=\"math inline\">\\(O(\\sqrt{n})\\)</span>，你大可无视里面不断除的过程，这个过程在long\r\nlong范围内也不会超过64次。</p>\r\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P2043\">P2043</a></p>\r\n<p><span class=\"math inline\">\\(Code\\)</span>：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,cnt[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">work</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k = <span class=\"built_in\">sqrt</span>(x);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tx/=i;</span><br><span class=\"line\">\t\t\tcnt[i]++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&gt;<span class=\"number\">1</span>) cnt[x]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++) <span class=\"built_in\">work</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">if</span> (cnt[i]) cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>当<span\r\nclass=\"math inline\">\\(n\\)</span>更大时，可以配合埃氏筛，先把所有质数筛出来，1~<span\r\nclass=\"math inline\">\\(n\\)</span>中是质数和质数的任意次方的倍数的数都对质因子有贡献。时间复杂度为<span\r\nclass=\"math inline\">\\(O(n\\log n)\\)</span>。（虽然埃氏筛要带两<span\r\nclass=\"math inline\">\\(\\log\\)</span>，但是这里就忽略不计了，你也可以用线性筛实现）</p>\r\n<p><span class=\"math inline\">\\(Code\\)</span>：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,cnt[N],vis[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> las = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=n/i;j++)&#123;</span><br><span class=\"line\">\t\t\t\tvis[i*j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (j/las == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tcnt[i]+=<span class=\"number\">1ll</span>*n/j/i;</span><br><span class=\"line\">\t\t\t\t\tlas*=i;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">if</span> (cnt[i]) cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"fun-facts\">Fun Facts</h2>\r\n<p>1~1000中有168个质数</p>\r\n<p>1~10000中有1229个质数</p>\r\n<p>1~100000中有9592个质数</p>\r\n<p>1~1000000中有78498个质数</p>\r\n<p>1~<span class=\"math inline\">\\(2^{32}\\)</span>中有203280221个质数</p>\r\n<p>在<span\r\nclass=\"math inline\">\\(10^{18}\\)</span>内的最大质数间隙不超过1500</p>\r\n","tags":["Knowledge","数学"]},{"title":"题解 UVA323 Jury Compromise","url":"/2022/03/19/%E9%A2%98%E8%A7%A3-UVA323-Jury-Compromise/","content":"<h1 id=\"题解-uva323-jury-compromise\">题解 UVA323 Jury Compromise</h1>\r\n<h2 id=\"题目大意\">题目大意</h2>\r\n<p>有 <span class=\"math inline\">\\(n\\)</span> 个人，从中选出<span\r\nclass=\"math inline\">\\(m\\)</span>个人，每个人有两个得分值<span\r\nclass=\"math inline\">\\(a\\)</span>和<span\r\nclass=\"math inline\">\\(b\\)</span>，我们要使<span\r\nclass=\"math inline\">\\(|\\sum^{m}_{i=1}a[i]-\\sum^{m}_{i=1}b[i]|\\)</span>最小，如果有多种情况满足，选择其中<span\r\nclass=\"math inline\">\\(\\sum^{m}_{i=1}a[i]+\\sum^{m}_{i=1}b[i]\\)</span>最大的一个。输出最大分值和选择的方案。</p>\r\n<p><span class=\"math inline\">\\(n\\leq200\\)</span></p>\r\n<p><span class=\"math inline\">\\(m\\leq20\\)</span></p>\r\n<p><span class=\"math inline\">\\(0\\leq a,b\\leq20\\)</span></p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<h3 id=\"o2n算法\"><span class=\"math inline\">\\(O(2^n)\\)</span>算法</h3>\r\n<p>第一眼看上去，好像没有任何思路，贪心也不太可行。</p>\r\n<p>于是考虑暴力。。。</p>\r\n<p>最暴力的想法是枚举选的人，求出最值。注意到，题目中的分值范围很小，所有人分差最大也只是<span\r\nclass=\"math inline\">\\(400\\)</span>，所以这<span\r\nclass=\"math inline\">\\(2^{200}\\)</span>种选择里面，必然有很多种选择，它们的分差是一样的，这就导致了很多重复计算，我们不如枚举分差。</p>\r\n<p>枚举分差，显然不能直接搜索，而DP可以很好地解决这个问题。</p>\r\n<h3 id=\"onm2错误算法\"><span\r\nclass=\"math inline\">\\(O(nm^2)\\)</span>错误算法</h3>\r\n<p>我们初步的想法是设<span\r\nclass=\"math inline\">\\(f[i]\\)</span>表示分差为<span\r\nclass=\"math inline\">\\(i\\)</span>时，能够取到的最大分值，每次加入一个人时，我们枚举分差，更新数组即可。</p>\r\n<p>第<span class=\"math inline\">\\(j\\)</span>个人加入后得到<span\r\nclass=\"math inline\">\\(i\\)</span>的分差的转移方程：<span\r\nclass=\"math inline\">\\(f[i] =\r\nmax(f[i],f[i-a[j]+b[j]]+a[j]+b[j])\\)</span></p>\r\n<p>但是，这样做会有后效性，在<span\r\nclass=\"math inline\">\\(j\\)</span>不变时，我们可能先改动了<span\r\nclass=\"math inline\">\\(f[i-a[j]+b[j]]\\)</span>的值，导致这里的<span\r\nclass=\"math inline\">\\(f[i-a[j]+b[j]]\\)</span>不是上一次的值，导致使用多次第<span\r\nclass=\"math inline\">\\(j\\)</span>个人。</p>\r\n<p>如果判断<span\r\nclass=\"math inline\">\\(a[j]-b[j]\\)</span>的正负来确定枚举顺序的确可以解决这个问题，但是这样不好处理之后的输出方案问题，于是我们索性多开一个维度。</p>\r\n<h3 id=\"onm2正确算法\"><span\r\nclass=\"math inline\">\\(O(nm^2)\\)</span>正确算法</h3>\r\n<p>设<span class=\"math inline\">\\(f[i][j]\\)</span>表示选择了<span\r\nclass=\"math inline\">\\(i\\)</span>个人，分差为<span\r\nclass=\"math inline\">\\(j\\)</span>的方案数。</p>\r\n<p>第<span class=\"math inline\">\\(p\\)</span>个人加入后得到<span\r\nclass=\"math inline\">\\(j\\)</span>的分差的转移方程：<span\r\nclass=\"math inline\">\\(f[i][j] =\r\nmax(f[i][j],f[i-1][j-a[p]+b[p]]+a[p]+b[p])\\)</span></p>\r\n<p>由于下标不能出现负数，我们把所有的分差都加上<span\r\nclass=\"math inline\">\\(400\\)</span>，这样就没有负数了。</p>\r\n<p>初始化时，将所有数都设为负无穷，<span class=\"math inline\">\\(f[0][400]\r\n= 0\\)</span>，这样可以保证不会从不合法的状态转移。</p>\r\n<p>输出时我们找到一个和<span\r\nclass=\"math inline\">\\(400\\)</span>最近的，值最大且大于<span\r\nclass=\"math inline\">\\(0\\)</span>的就行了。</p>\r\n<h3 id=\"剩下的输出\">剩下的输出</h3>\r\n<p>我们不仅要输出最大值，还要输出选择的方案，我们考虑用一个数组记录转移的情况。</p>\r\n<p>设<span class=\"math inline\">\\(d[i][j][p]\\)</span>表示前<span\r\nclass=\"math inline\">\\(i\\)</span>个人中，选择了<span\r\nclass=\"math inline\">\\(j\\)</span>个人，得到<span\r\nclass=\"math inline\">\\(p\\)</span>的分差，最后选择的是哪个人。</p>\r\n<p>转移时先把上一次的照搬过来，对应不选第<span\r\nclass=\"math inline\">\\(i\\)</span>个人的情况，之后如果这一次能够让<span\r\nclass=\"math inline\">\\(f[j][p]\\)</span>更大，就更新<span\r\nclass=\"math inline\">\\(d[i][j][p]\\)</span>。</p>\r\n<p>输出方案时，我们从<span\r\nclass=\"math inline\">\\(d[n][m][Min]\\)</span>开始输出，每次<span\r\nclass=\"math inline\">\\(Min-=a[d[n[m][Min]]]-b[d[n][m][Min]]\\)</span>，<span\r\nclass=\"math inline\">\\(m-=1\\)</span>，<span\r\nclass=\"math inline\">\\(n\\)</span>转移到<span\r\nclass=\"math inline\">\\(d[n][m][Min]-1\\)</span>，一直到<span\r\nclass=\"math inline\">\\(m=0\\)</span>时结束。</p>\r\n<p>之后倒序输出就行了</p>\r\n<h3 id=\"总结\">总结</h3>\r\n<p>前面的DP应该不是很难想到，但是各种细节需要注意：</p>\r\n<ol type=\"1\">\r\n<li>数组下标不能为负数，要加一个基准值</li>\r\n<li>转移时记录转移情况，方便输出方案</li>\r\n<li>数组要初始化为负无穷，避免从不合法的情况转移</li>\r\n<li>多测要清空</li>\r\n</ol>\r\n<p>本题实际上是将每个人视为一个物品，做了一次01背包。考察了背包和输出方案。</p>\r\n<h2 id=\"code\">Code</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">1e3</span>+<span class=\"number\">10</span>,M = <span class=\"number\">25</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,f[M][N],p[N],q[N],d[<span class=\"number\">205</span>][M][N],totp,totq,per[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> now = m,nnow = n;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (now)&#123;</span><br><span class=\"line\">\t\tnnow = d[nnow][now][x];</span><br><span class=\"line\">\t\tper[now] = nnow;</span><br><span class=\"line\">\t\ttotp+=p[nnow];</span><br><span class=\"line\">\t\ttotq+=q[nnow];</span><br><span class=\"line\">\t\tx = x-p[nnow]+q[nnow];</span><br><span class=\"line\">\t\tnnow--;</span><br><span class=\"line\">\t\tnow--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!n &amp;&amp; !m) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\tnow++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">-0x3f</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(f));</span><br><span class=\"line\">\t\ttotp = totq = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;p[i]&gt;&gt;q[i];</span><br><span class=\"line\">\t\tf[<span class=\"number\">0</span>][<span class=\"number\">400</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> p1=<span class=\"number\">1</span>;p1&lt;=n;p1++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">800</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\td[p1][i][j] = d[p1<span class=\"number\">-1</span>][i][j];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=m;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">800</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ((j-p[p1]+q[p1])&lt;<span class=\"number\">0</span> || (j-p[p1]+q[p1])&gt;<span class=\"number\">800</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (f[i][j]&lt;f[i<span class=\"number\">-1</span>][j-(p[p1]-q[p1])]+p[p1]+q[p1])&#123;</span><br><span class=\"line\">\t\t\t\t\t\tf[i][j] = f[i<span class=\"number\">-1</span>][j-(p[p1]-q[p1])]+p[p1]+q[p1];</span><br><span class=\"line\">\t\t\t\t\t\td[p1][i][j] = p1;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> Min = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">800</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (f[m][i]&gt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(Min<span class=\"number\">-400</span>) == <span class=\"built_in\">abs</span>(i<span class=\"number\">-400</span>))&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (f[m][i]&gt;=f[m][Min]) Min = i;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(Min<span class=\"number\">-400</span>)&gt;<span class=\"built_in\">abs</span>(i<span class=\"number\">-400</span>)) Min = i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">get</span>(Min);</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Jury #&quot;</span>&lt;&lt;now&lt;&lt;endl;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Best jury has value &quot;</span>&lt;&lt;totp&lt;&lt;<span class=\"string\">&quot; for prosecution and value &quot;</span>&lt;&lt;totq&lt;&lt;<span class=\"string\">&quot; for defence:&quot;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(per+<span class=\"number\">1</span>,per+<span class=\"number\">1</span>+m);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cout&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;per[i];</span><br><span class=\"line\">\t\tcout&lt;&lt;endl&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["Knowledge","DP"]}]