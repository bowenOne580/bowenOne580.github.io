[{"title":"ABC248 E 题解","url":"/2022/04/16/ABC248-E-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"ABC248-E-题解\"><a href=\"#ABC248-E-题解\" class=\"headerlink\" title=\"ABC248 E 题解\"></a>ABC248 E 题解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>计算几何用向量，把初中的知识扔到垃圾桶里面！</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"赛时错解\"><a href=\"#赛时错解\" class=\"headerlink\" title=\"赛时错解\"></a>赛时错解</h3><p>赛时的时候大概想的是把任意两点之间的直线方程写出来，之后计算有多少个相同的直线方程就可以了。</p>\n<p>这样看上去是不是很对？而且复杂度也是恰到好处的$O(n^3\\log n)$。</p>\n<span id=\"more\"></span>\n<p>随便造一组数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">3 2</span><br><span class=\"line\">-1000000000 -1000000000</span><br><span class=\"line\">1000000000 -999999999</span><br><span class=\"line\">1000000000 -999999998</span><br></pre></td></tr></table></figure>\n<p>可以发现在这样的精度下，结果精确到了小数点后第10位，这时，如果坐标比较随机，这样我们拿一个点的$(x,y)$通过$x\\cdot k+b-y=0$来判断是否在一条直线上，精度误差会非常大，就可能得到不在这条直线上的结论。</p>\n<p>什么意思呢？看这组数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">3 2</span><br><span class=\"line\">526541302 530345686</span><br><span class=\"line\">658662535 384363763</span><br><span class=\"line\">362264287 332982928</span><br></pre></td></tr></table></figure>\n<p>这个斜率我们是拿除法算出来的，但是当我们再乘回去时，就损失了非常大的精度（至少9位，如果除法非常准确的话），这就导致一个点的$x\\cdot k+b-y=0.000000000058208$，比我设定的精度$1e-12$大，所以得到了错误的结果（赛时我还一直在想如何增加精度，但是这样只是增加了小数点的位数，除法损失的精度依然不能弥补）。</p>\n<p>所以，我们最好在答案要求保留几位小数或值域不大时使用初中的方法。</p>\n<p>但是，这道题值域为$[-1e9,1e9]$，明摆着不放long double过，我们需要使用更高级的方法判断共线——向量。</p>\n<h3 id=\"向量正解\"><a href=\"#向量正解\" class=\"headerlink\" title=\"向量正解\"></a>向量正解</h3><p>还记得这个公式吗：若$\\overrightarrow {AB} = k\\cdot\\overrightarrow{AC}$，则$A,B,C$三点共线。</p>\n<p>于是，设$A = (x_1,y_1),B = (x_2,y_2),C = (x_3,y_3)$，则$(x_1-x_2)\\cdot(y_1-y_3) = (x_1-x_3)\\cdot (y_1-y_2)$。</p>\n<p>我们可以用乘法判断三点是否共线，只要枚举两点，再看和它们共线的点有多少个就行了。</p>\n<p>至于重复，由于这个$n$很小，可以直接用$vis[i][j]$表示是否访问过第$i$个点和第$j$个点组成的直线。</p>\n<p>总时间复杂度$O(n^3)$。</p>\n<p>（这貌似是我第一次用向量解决OI问题）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e3</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,vis[N][N],ans;</span><br><span class=\"line\">__int128 x[N],y[N];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">read</span><span class=\"params\">(__int128 &amp;x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp;</span><br><span class=\"line\">\tcin&gt;&gt;tmp;</span><br><span class=\"line\">\tx = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Infinity&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">read</span>(x[i]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">read</span>(y[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">push_back</span>(j);</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> cnt = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">1</span>;p&lt;=n;p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (p == i || p == j || vis[p][i] || vis[p][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((x[i]-x[j])*(y[i]-y[p]) == (y[i]-y[j])*(x[i]-x[p]))&#123;</span><br><span class=\"line\">\t\t\t\t\tcnt++;</span><br><span class=\"line\">\t\t\t\t\ta.<span class=\"built_in\">push_back</span>(p);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x:a)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> y:a)&#123;</span><br><span class=\"line\">\t\t\t\t\tvis[x][y] = vis[y][x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tans+=(cnt&gt;=k);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","数学","计算几何"]},{"title":"ABC 254 D 题解","url":"/2022/06/07/ABC-254-D-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"ABC-254-D-题解\"><a href=\"#ABC-254-D-题解\" class=\"headerlink\" title=\"ABC 254 D 题解\"></a>ABC 254 D 题解</h1><p>考虑一个数$x$的分解：</p>\n<p>$x = p_1^{c_1}\\cdot p_2^{c_2}\\cdots p_n^{c_n}$</p>\n<p>显然，只有当两个数乘起来时，所有质因数的指数都是$2$的倍数时才能是一个平方数。</p>\n<h2 id=\"自己想的\"><a href=\"#自己想的\" class=\"headerlink\" title=\"自己想的\"></a>自己想的</h2><p>发现两个数能否凑成一对和指数有关，但是和指数具体是多少没有很大关系，只用知道指数的奇偶性就行了。</p>\n<p>$200000$里面大概有$20000$个质数，我们把每个数的指数看成一个长度为$20000$的串，其中指数是奇数的为$1$，偶数为$0$，最后就是求有多少个和它相同的数。</p>\n<p>可以直接把这些数扔进map里面，每次查询和它相同的数的个数，可以用$O(n\\log n)$的时间解决这个问题。</p>\n<p>之后就是怎么把一个数的分解算出来。直接$O(\\sqrt n)$分解必然超时，由于这里都是连续的数，所以想到筛子。</p>\n<p>线性筛太快了，我不会在上面做改动，于是大概可以通过魔改埃氏筛达到接近$O(21\\cdot n \\log n)$的复杂度。</p>\n<p>（以上为纯口胡，到埃氏筛的时候就觉得这个算法不对劲，因为写起来一定很长，不符合ABC的风格）</p>\n<p>所以看了眼题解。。。</p>\n<h2 id=\"题解说的\"><a href=\"#题解说的\" class=\"headerlink\" title=\"题解说的\"></a>题解说的</h2><p>设$f(i)$表示$i$中最大的平方因子，也就是说，$\\frac{i}{f(i)}$就是$i$中所有指数为奇数的质因子的乘积。</p>\n<p>先$O(n)$预处理出所有平方因子，再通过这些平方因子$O(n\\log n)$预处理出所有$f(i)$。</p>\n<p>之后就是求对于一个$i$，所有$\\frac{i\\cdot j}{f(i)\\cdot f(j)}$为平方因子的$j$的数量。</p>\n<p>然后因为所有$\\frac{i}{f(i)}$质因子的指数都是1，所以只用找所有$\\frac{i}{f(i)} = \\frac{j}{f(j)}$的数就行了。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">4e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,f[N];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> cnt[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(n+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = i*i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=x;j&lt;=n;j+=x) f[j] = <span class=\"built_in\">min</span>(f[j],j/x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cnt[f[i]]++;</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans+=cnt[f[i]];</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实这两个算法殊途同归，但是实现上却有明显的差异，究其原因，大概是对性质的挖掘还不够深，不知道把求每个数的分解转化为求每个数指数$\\mod 2$之后的形式会更快，更好写。</p>\n<p>也许，这就是思维的重要性吧。</p>\n","tags":["数学","Editorial"]},{"title":"Announcement","url":"/2022/08/03/Announcement/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"1b64bf7b245062cd795b6e1ba0ad4a7fd614692947cba116051dc132ce85db3a\">1175ba61b191a60c3cf2c2c851ae0aed93d0282311d2614a472a1718e5a2d224ba8f51bf00f89deae52e95801de009802c2d714e40e0dceaca91cb87fc9af2586daaab52a3a21bdd5a2530c6a882817f26ec3a978e5b8d98289317b030fced188d8bd0dc733a058e95423c0e274fc724ba0b1656e434edb6683447dffb80cd5369eba31a3308d61fc19cb05e23ed9a4586d17ced200d4e5741a72de762519c3b60fd70b97f80f8d4161bd75b748f714da178981a854fefcdfaa9fce13321e98aa9676a275f23c8841bfc137b411df936ad93230919c45b069d5286b26d986e43e36f65f46baf26c645ef3de54f2b0a76d337f88ebaf24bd759132b1ff0fe78b78a12e06a130bfafcdf5664329ec2f54d9d059f30ae4f9c5897406aef1a91f9a4defeed88f02a170459133bcc2f7287e47210094960dfa2bd88874ff9bb402c0dee7d26c9109f8ed36ece27994e53a2eb52362cb6aa86daf99c47934b3f29fbf871e4164905771ac47b47c004338a7da3f29f52f180cbd09063f195fcd6b369cd05b19ed87ee5b4f49dccd0dfe559924002b8a10de56b3d361a352c6bc45f4a2f2739767e84cad4bcafa53d8c0b30ebb4b3ed2de00c39104d8513009e2f1c903f7970d73387b70d941e764976378ed3e42749898ad8531352180ca6a185a8782d1d9c8b03738a733d11f7f62b58460f97bb40b2d1b5cc63cc1230a22d0fdff1d61dcbb48b3548f9f0837ea8e5c30b8d3ca6d8706f99a987552e1bd8cf9142e53c98db3553ee431cb13e8d0817d1008eeec7e1457879da79bc01c0fdd61ce9a76235b1fb1f7715457e39dab5de4521b935c6bbd03ed5e7c6a11d1abf3bacc6e728c21972ff4eaee30c2835e5549b107f954a2d950af1e65c542a903fae55b56b50f3954d7621ebecda7c316e32208313c6c928a517d03358a9e7502caa99c29c95532e89bf58db668bbd0f07bb4ed0c6879fad17c95b0d1145f2814825e1f56f8e779d96166fa6132ae4f0f3e6d94e2b08d3d8823674a1cfd55700ba69ce30ae2b73633ba2d72d7486f8e9a17b1d38d31992258898d7fbb7e39d34ec6d9a925c4e177401b72ec691af65a5374f0a9a4baad4774a68a402ffef253bf27f11dc8010abe3f9cbd952d56debd7633d5d2d7185379dfc06113dc271449a90477edd685c03c9b110ed828a832b3f6e640459ee546b47c6e4f50e25500f3b440fb852d4ca7eb6d239856a29998bcc6b06f67cc6d67ff3f06fd8b60051ba5c0277bdf2313dfaf7e369ecc35dc9f1fef1e71ba87b5baa507dfe5b76faf05335f19d6db652d9aa3b8d0cebab3f750167969cfc59adfadd403dd52adcb487e924e575847296a21e28fe6a1de0e6b9fe49014b8dd125f2bebd6e36bed4caab8e5368c1b90cb9cf7a43121de073f90f8e42c7c0d6aae5ae59971a1b69c822ef7ea533be7f9a5424f005f137a81888c9d112a91bd7cbf2610d9b82222f82504fc794fe793df9c88bf0c381fcdc1d2efed947fa6097285c22c83c4f26ab255e8acea209f13ec503bad903fad2a4bb48a9a295f5ea7302da6b4c1e7e7ff84f7669085e7175dccd95510a02dad3f989b194deaaaf110e61d97f8591093e376ea4f45d1b8b847531d6c8c53919d1fc4c3098f3b429d342af6c63775fd13b94086067949cc93795e54ba1b131eecd9ffe7702f65e9457466c8127ff2cff66b319dbb72de85387897341c113145c1304a69e0db8fe5a731fea56ab656bd46ad1404a29ccea42dba5c3c9d5354ea0ef2a862361acc2ed6ab3cc2fec55020f9e5ffc71345900994a231b187e8513aa339e348591fc2b1ea65c889b2e1085bb2b20809d77bd9dc25fa4d6e60a074d61a10a3387a6fbcef00608d7b3a142eb1c767c07162992f6c9ba47d037ff8291755b7c95bdf4fa85aa5b285efd8a3674e34ac2f52fda809b75b595910f23035a6fbff5d71de06ce544c2902f65c802b5a52dfa5ac89d7db924d32a6a0a9c508ee3a20387350ee298ad8ffd7a3a50d0ae11a311aee6b1ff83e1bb97478985bb86ef9dbacbf77ed18255ffece70311994fbffc64f90f98186c655f74058f120678f2382129c1a796a3a17e5cb3759d87a1485cf795451227ba8458e66d2230b87c9b05982db8e7eb773472c0e8a2a7cb8d520d435c699fd1f5b0ba990bf37f21b9a722dbb0b15eacc448a448161fc7c125757d70c170b79431a13ed584ec2bf7fe94b562489a95b5429c254e5d9b493cd560e1d207eccd5831e222b2ed25cb402695e89aef3b44563cfe9c0e66f8d70694434906eb57494d502f0257238525f92a883eb7c24f50c83131c9adb671e58acdd348f580411b3cecf780bb1bd3381ba0f5251de4436f23244765ddfdd2a13c353c321509ec19a0285282efe983d6b0ddbd2077729dbfd8cb9cebbece4e92e50db33654032f19423429fcb72b08ffff2951837aa2933cbfcee346f20a3121834f073060d8310ff75acb9def3649481017a4b2d1ffbceec6b8e794f39ea73f</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">Enter Your Password Here</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","tags":["Secret"]},{"title":"Crash的数字表格 题解","url":"/2022/05/26/Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Crash的数字表格-题解\"><a href=\"#Crash的数字表格-题解\" class=\"headerlink\" title=\"Crash的数字表格 题解\"></a>Crash的数字表格 题解</h1><p>$\\sum_{i=1}^n\\sum_{j=1}^mlcm(i,j)$</p>\n<p>把$lcm$写成$\\gcd$的形式：</p>\n<p>$\\sum_{i=1}^n\\sum_{j=1}^m\\frac{ij}{\\gcd(i,j)}$</p>\n<p>枚举$\\gcd$：</p>\n<p>$\\sum_{d=1}^{min(n,m)}\\sum_{i=1}^n\\sum_{j=1}^m\\frac{ij}{d}[\\gcd(i/d,j/d) = 1]$</p>\n<span id=\"more\"></span>\n<p>设$i’=i/d$,$j’=j/d$，代入：</p>\n<p>$\\sum_{d=1}^{min(n,m)}\\sum_{i’=1}^{n/d}\\sum_{j’=1}^{m/d}i’j’d[gcd(i’,j’) = 1]$</p>\n<p>把$\\gcd$变成$\\mu$：</p>\n<p>$\\sum_{d=1}^{min(n,m)}d\\sum_{i’=1}^{n/d}\\sum_{j’=1}^{m/d}i’j’\\sum_{k|\\gcd(i’,j’)}\\mu(k)$</p>\n<p>枚举$k$：</p>\n<p>$\\sum_{d=1}^{min(n,m)}d\\sum_{k=1}^{min(n/d,m/d)}\\mu(k)k^2\\sum_{i’=1}^{n/kd}i’\\sum_{j’=1}^{m/kd}j’$</p>\n<p>后面的东西可以用等差数列优化：</p>\n<p>$\\sum_{d=1}^{min(n,m)}d\\sum_{k=1}^{min(n/d,m/d)}\\mu(k)k^2XY$</p>\n<p>前面的东西也可以用前缀和直接求出：</p>\n<p>$\\sum_{d=1}^{min(n,m)}d\\sum_{k=1}^{min(n/d,m/d)}Z\\frac{(1+\\frac{n}{kd})\\frac{n}{kd}}{2}\\cdot \\frac{(1+\\frac{m}{kd})\\cdot \\frac{m}{kd}}{2}$</p>\n<p>预处理出$\\mu$值和前缀和时间复杂度为$O(n)$，这个式子可以用两次数论分块，第一次分$n/d$和$m/d$相等，第二次分$n/kd$和$m/kd$相等，之后直接计算即可。总时间复杂度为$O(n)$。</p>\n","tags":["Knowledge","数论","莫比乌斯反演"]},{"title":"Blog is open now!","url":"/2022/01/24/Blog-is-open-now/","content":"<h2 id=\"博客迁移已完成，之后的东西大概都在这里写了\"><a href=\"#博客迁移已完成，之后的东西大概都在这里写了\" class=\"headerlink\" title=\"博客迁移已完成，之后的东西大概都在这里写了\"></a>博客迁移已完成，之后的东西大概都在这里写了</h2><p>由于多重原因，洛谷博客据说要没了，昨晚考虑把博客迁移到这里来，经过一中午和一下午的努力，博客迁移工作终于完成了，之后的东西就都在这里写吧。</p>\n<p><a href=\"https://imgtu.com/i/7TSqln\"><img src=\"https://s4.ax1x.com/2022/01/24/7TSqln.png\" alt=\"截图\"></a></p>\n","tags":["Life"]},{"title":"Counting Swaps 题解","url":"/2022/04/11/Counting-Swaps-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Counting-Swaps-题解\"><a href=\"#Counting-Swaps-题解\" class=\"headerlink\" title=\"Counting Swaps 题解\"></a>Counting Swaps 题解</h1><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我们得到的序列是$p_1,p_2\\cdots p_n$，如果从每个$i$向$p_j=i$的$j$连一条边，那么我们的目标就是使这个图中存在$n$个自环。</p>\n<h3 id=\"观察题目，得到猜想\"><a href=\"#观察题目，得到猜想\" class=\"headerlink\" title=\"观察题目，得到猜想\"></a>观察题目，得到猜想</h3><span id=\"more\"></span>\n<p><strong>结论1：这个图必然由若干个环构成。</strong></p>\n<p>由于点$i$连向$p_j=i$的$j$和$p_i$，所以每个点必然连接着两条边。如果图中有不是环的东西，那么必然存在一个点，其只有一条出边，这与每个点都连接两条边矛盾，所以原命题成立。</p>\n<p><strong>思考1：交换$p_i$和$p_j$会对原图产生什么影响？</strong></p>\n<p>之前连向$p_i$的是$p_q=i$的$q$和编号为$p_i$的点。</p>\n<p>显然，根据连边的规则，从编号为$p_i$的点连向$j$的边不会改变，但是另一条边变成了从$p_{q’}=j$连向$p_i$的边。</p>\n<p>另一个点连接的两个点分别是编号为$p_j$和$p_{q’’}=i$。</p>\n<p>其实手动模拟一下可能会更清晰。</p>\n<p>这样，这两个点就交换了各自的一条边，形成了两个环。</p>\n<p>形式化的说，如果原来的环是$v_1\\rightarrow v_2\\cdots v_n\\to v_1$，交换$i,j$（令$i&lt;j$）之后的环就变成了$v_i\\to v_{i+1}\\cdots v_j\\to v_i$和$v_1\\to v_2\\cdots v_i\\to v_{j+1}\\cdots v_n\\to v_1$。</p>\n<p>得到结论：在一个长度为$n$的环内交换$i,j$，会变成两个长度为$j-i$和$n-j+i$的环。</p>\n<p><strong>结论2：将一个包含$m$个点的环拆成$m$个自环，最少需要$m-1$次操作。</strong></p>\n<p>用数学归纳法证明。</p>\n<p>在$m=1$时，自己本身就是自环了，不用拆，需要$1-1 = 0$次操作。</p>\n<p>假设对于任意$i\\in [1,m-1]$，都只需要$m-1$次操作，那么对于一个长度为$m$的环，我们可以</p>\n<p>任取两个点$i,j$，交换它们，根据思考1，环将变成$j-i$和$m-j+i$两个环。</p>\n<p>而将这两个环拆成自环需要$j-i-1+m-j+i-1 = m-2$次操作，加上交换$i,j$这一次操作，总共需要$m-1$次操作。</p>\n<p>于是，原命题成立。</p>\n<h3 id=\"进一步思考\"><a href=\"#进一步思考\" class=\"headerlink\" title=\"进一步思考\"></a>进一步思考</h3><p>现在，我们已经知道了最小的次数是$n-$环的个数，要求总共有多少种交换的方法能够达到这个次数。</p>\n<p>设$F_n$表示用最少的次数将一个长度为$n$的环变为$n$个自环的方案数，根据思考1和结论2，我们可以把这个环拆成大小为$x$和$y$的两个环，设$T_(x,y)$表示有多少种方法拆成大小为$x$和$y$的两个环：</p>\n<p>当$x=y$时，$T(x,y) = n/2$，从$i$和$i+x$切没有区别。</p>\n<p>当$x\\neq y$时，$T(x,y) = n$，在任意一个点$i$切都是不同的方案。</p>\n<p>于是，$F_n = \\sum T(x,y)\\cdot F_x\\cdot F_y\\cdot \\frac{(n-2)!}{(x-1)!\\cdot (y-1)!}$。</p>\n<p>最后乘的那个东西可以看作有$x$个0和$y$个1的排列数，直接用多重集的排列数计算即可。</p>\n<p>至于为啥$x$个0都是相同的，因为区分操作的情况在计算$F_x$的时候就已经计算过了，所以这里可以把它们当成相同的。</p>\n<p>因为每个自环计算方案是独立的，所以我们要把所有的方案数乘起来，再像上面一样乘一个多重集的排列数：</p>\n<p>$ans = F_{l_1}\\cdot F_{l_2}\\cdots F_{l_k}\\cdot \\frac{(n-k)!}{(l_1-1)!\\cdot (l_2-1)! \\cdots (l_k-1)!}$。</p>\n<p>这样，我们可以$O(n^2)$推出所有我们需要的$F_i$值，之后乘起来，加个乘法逆元，总复杂度为$O(n^2\\log n)$。</p>\n<p>之后好像就没法优化了，除非你把$F_i$的前几项放到OEIS上去。。。</p>\n<p>于是，我们借助网络得到$F_i$的通向公式：$F_i = i^{i-2}$，这样复杂度就变成了$O(n\\log n)$。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总之，这是一道非常不错（毒瘤）的组合入门题（至少<a href=\"https://www.luogu.com.cn/discuss/53018\">小粉兔是这么说的</a>），考察了对加法原理和乘法原理的理解、数学归纳法的使用、多重集的排列数的了解，需要一定的猜测和证明能力，组合数学的基础才能完全理解。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code$\"></a>$Code$</h2><p>要在处理所有询问之前把$F_i$和阶乘预处理出来，这样复杂度才是对的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,p = <span class=\"number\">1e9</span>+<span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,a[N],head[N],tot,l[N],cnt,vis[N],jie[N],f[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> p)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ans = ans*bas%p;</span><br><span class=\"line\">\t\tbas = bas*bas%p;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tf[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=<span class=\"number\">100000</span>;i++) f[i] = <span class=\"built_in\">ksm</span>(i,i<span class=\"number\">-2</span>,p);</span><br><span class=\"line\">\tjie[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">100000</span>;i++) jie[i] = jie[i<span class=\"number\">-1</span>]*i%p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\tvis[x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tl[cnt]++;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[v]) <span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">long</span> <span class=\"type\">long</span>)*(n+<span class=\"number\">100</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(l,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">long</span> <span class=\"type\">long</span>)*(n+<span class=\"number\">100</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">long</span> <span class=\"type\">long</span>)*(n+<span class=\"number\">100</span>));</span><br><span class=\"line\">\t\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(a[i],i);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(i,a[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\t\tcnt++;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">dfs</span>(i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">1</span>,num = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class=\"line\">\t\t\tans*=f[l[i]];</span><br><span class=\"line\">\t\t\tans%=p;</span><br><span class=\"line\">\t\t\tnum*=jie[l[i]<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t\tnum%=p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans*=jie[n-cnt]*<span class=\"built_in\">ksm</span>(num,p<span class=\"number\">-2</span>,p)%p;</span><br><span class=\"line\">\t\tans%=p;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","数学","组合数学"]},{"title":"Global Round 23 D 题解","url":"/2022/10/23/Global-Round-23-D-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Global-Round-23-D-题解\"><a href=\"#Global-Round-23-D-题解\" class=\"headerlink\" title=\"Global Round 23 D 题解\"></a>Global Round 23 D 题解</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>观察到，如果确定了一个点经过的次数，那它的儿子的次数基本确定了，且只受这个点的控制。</p>\n<p>所以这道题大概是个子树类 dp。</p>\n<p>具体来说，假设一个点经过了 $num$ 次，它有 $k$ 个儿子，考虑儿子走的次数。</p>\n<p>由于任意两个儿子之间的次数差不超过 $1$，所以所有儿子必然至少走过 $\\lfloor \\frac{num}{k}\\rfloor$ 次，还要选择 $num\\mod k$ 个儿子再走一次。</p>\n<span id=\"more\"></span>\n<p>题目要求答案最大，所以可以直接贪心，选择儿子中贡献最大的 $num\\mod k$ 个。</p>\n<p>可以考虑每次对每个儿子 $dfs$ 两遍，分别代表走 $\\lfloor \\frac{num}{k}\\rfloor$ 和 $\\lfloor \\frac{num}{k}\\rfloor+1$ 次，选择两者差值最大的 $num\\mod k$ 个。</p>\n<p>这里一定要以你要走的次数去 $dfs$，而不能仅仅依靠 $dfs(v,1)$ 来判断谁更优，因为次数不同，方案可能截然不同。</p>\n<p>而且，也不能选择走 $\\lfloor \\frac{num}{k}\\rfloor+1$ 次中最大的几个，因为在加上它的贡献的同时，还要减去走 $\\lfloor \\frac{num}{k}\\rfloor$ 次的贡献。</p>\n<p>由于是树形 dp，所以复杂度是经典的 $O(n\\log n)$。</p>\n<p>但是，这样写会有大常数，因为每次要 $dfs$ 两遍。建议还是对每一次求出的值记忆化一下，容易证明这样做只会有 $n$ 个状态，所以就是严格的 $O(n\\log n)$ 了。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,k,head[N],tot,s[N],cnt[N];</span><br><span class=\"line\">ll f[N],tmp[N];</span><br><span class=\"line\">map&lt;pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;,ll&gt; mp;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mp.<span class=\"built_in\">count</span>(<span class=\"built_in\">make_pair</span>(u,num))) <span class=\"keyword\">return</span> mp[<span class=\"built_in\">make_pair</span>(u,num)];</span><br><span class=\"line\">\t<span class=\"type\">int</span> v,bas = <span class=\"number\">0</span>,lim = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tf[u] = <span class=\"number\">1ll</span>*num*s[u];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt[u]) bas = num/cnt[u],lim = num%cnt[u];</span><br><span class=\"line\">\tll tmp1,tmp2;</span><br><span class=\"line\">\tvector&lt;ll&gt; tmp;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;ll&gt;().<span class=\"built_in\">swap</span>(tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\ttmp1 = <span class=\"built_in\">dfs</span>(v,bas);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lim) tmp2 = <span class=\"built_in\">dfs</span>(v,bas+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tf[u]+=tmp1;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lim) tmp.<span class=\"built_in\">pb</span>(tmp2-tmp1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (lim)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(tmp.<span class=\"built_in\">begin</span>(),tmp.<span class=\"built_in\">end</span>(),<span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;());</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;lim;i++) f[u]+=tmp[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmp[<span class=\"built_in\">make_pair</span>(u,num)] = f[u];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f[u];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(n+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(cnt,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(n+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\tmp.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(x,i),cnt[x]++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;s[i];</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,k)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","Editorial","动态规划","树形dp"]},{"title":"DIVCNT2 题解","url":"/2022/06/25/DIVCNT2-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"DIVCNT2-题解\"><a href=\"#DIVCNT2-题解\" class=\"headerlink\" title=\"DIVCNT2 题解\"></a>DIVCNT2 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>求$\\sum_{i=1}^n\\sigma(i^2)$，此处$\\sigma(i)$表示$i$的约数个数。</p>\n<p>$n\\leq 10^{12}$</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先考虑化简 $\\sigma(x^2)$：</p>\n<p>设 $x = p_1^{c_1}\\cdot p_2^{c_2}\\cdots p_k^{c_k}$，则 $x^2 = p_1^{2c_1}\\cdot p_2^{2c_2}\\cdots p_k^{2c_k}$。</p>\n<p>$\\sigma(x^2) = (2c_1+1)\\cdot (2c_2+1)\\cdots (2c_k+1)$</p>\n<p>好像化不下去了。（不过题解第一篇好像就是这样化的，有时间研究一下）</p>\n<p>换一种化法：</p>\n<p>$\\sum_{i=1}^n\\sum_{j|i}\\sum_{k|i}[\\gcd(j,k) = 1]$</p>\n<p>提出 $j$、$k$：</p>\n<p>$\\sum_{j=1}^n\\sum_{k=1}^n[\\gcd(j,k) = 1]\\sum_{j|i,k|i}1$</p>\n<p>由于只有 $\\gcd(j,k) = 1$ 时才有贡献，所以：</p>\n<p>$\\sum_{j=1}^n\\sum_{k=1}^n[\\gcd(j,k) = 1]\\sum_{jk|i}1$</p>\n<p>后面的东西可以化简：</p>\n<p>$\\sum_{j=1}^n\\sum_{k=1}^n[\\gcd(j,k) = 1]\\frac{n}{jk}$</p>\n<p>之后，令 $T = dk$：</p>\n<p>$\\sum_{T=1}^n\\frac{n}{T}\\sum_{j|T}[\\gcd(j,\\frac{T}{j}) = 1]$</p>\n<p>反演：</p>\n<p>$\\sum_{T=1}^n\\frac{n}{T}\\sum_{j|T}\\sum_{d|\\gcd(j,\\frac{T}{j})}\\mu(d)$</p>\n<p>枚举 $d$：</p>\n<p>$\\sum_{d=1}^n\\mu(d)\\sum_{T=1}^{n}\\frac{n}{T}\\sum_{j|T,d|\\frac{T}{j}}1$</p>\n<p>发现 $j$、$\\frac{T}{j}$ 都要满足是 $d$ 的倍数，就先给 $T$ 两个 $d$ ，之后就只用计算 $T$ 的约数个数就行了（此处的 $\\sigma(T)$ 和题目中意思相同）：</p>\n<p>$\\sum_{d=1}^{n}\\mu(d)\\sum_{T=1}^{\\frac{n}{d^2}}\\frac{n}{Td^2}\\sigma(T)$</p>\n<p>整除分块后，前面的 $\\mu$ 最大不超过 $10^6$，故可以直接预处理出来，只用考虑后面的东西怎么求就行了：</p>\n<p>$\\sum_{i=1}^n\\frac{n}{i}\\sigma(i)$</p>\n<p>对前面的系数整除分块，后面的 $\\sigma$ 很大的时候可以使用整除分块求解，加一个记忆化就是杜教筛的复杂度了（我不会分析，但是看上去长得就差不多嘛）。</p>\n<p>由于这个 $\\frac{n}{d^2}$ 非常小，所以复杂度不会太离谱。</p>\n<p>总时间复杂度为 $O(n^{\\frac{2}{3}})$，有亿点卡常。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ull;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">8e7</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e6</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,vis[N],pri[N/<span class=\"number\">10</span>],tot,mu[M+<span class=\"number\">10</span>],lim;</span><br><span class=\"line\">ll a[<span class=\"number\">10005</span>];</span><br><span class=\"line\">ull d[N];</span><br><span class=\"line\">map&lt;ll,ull&gt; mp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\td[<span class=\"number\">1</span>] = mu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;=M) mu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\td[i] = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&lt;=M &amp;&amp; vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i%pri[j]) d[i*pri[j]] = (d[i]&lt;&lt;<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> d[i*pri[j]] = (d[i]&lt;&lt;<span class=\"number\">1</span>)-d[i/pri[j]]; <span class=\"comment\">//每个数都被它的最小质因子筛一次 </span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) d[i]+=d[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ull <span class=\"title\">getdd</span><span class=\"params\">(ull x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;=lim) <span class=\"keyword\">return</span> d[x];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mp.<span class=\"built_in\">count</span>(x)) <span class=\"keyword\">return</span> mp[x];</span><br><span class=\"line\">\tull ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (ull l = <span class=\"number\">1</span>,r;l&lt;=x;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tr = x/(x/l);</span><br><span class=\"line\">\t\tans+=(r-l+<span class=\"number\">1</span>)*(x/l);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mp[x] = ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ull <span class=\"title\">getd</span><span class=\"params\">(ull x)</span></span>&#123;</span><br><span class=\"line\">\tull ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (ull l=<span class=\"number\">1</span>,r;l&lt;=x;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tr = x/(x/l);</span><br><span class=\"line\">\t\tans+=(<span class=\"built_in\">getdd</span>(r)-<span class=\"built_in\">getdd</span>(l<span class=\"number\">-1</span>))*(x/l);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\tll Max = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=t;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tMax = <span class=\"built_in\">max</span>(Max,a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Max&lt;=<span class=\"number\">100000</span>) lim = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Max&lt;=<span class=\"number\">1000000000ll</span>) lim = <span class=\"number\">5000000</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">else</span> lim = <span class=\"number\">80000000</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tull ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=t;i++)&#123;</span><br><span class=\"line\">\t\tans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;<span class=\"number\">1ll</span>*j*j&lt;=a[i];j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!mu[j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tans+=<span class=\"built_in\">getd</span>(a[i]/j/j)*mu[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>莫比乌斯反演中考的无非就是约数啊，$\\gcd$ 啊，约数个数啊，这要求你对它们的性质了如指掌。</p>\n<p>比如这道题中，第一步的变形就是约数个数和中的常见套路，之后的不断更换求和指标也是常用技巧。</p>\n<p>当出现 $i\\cdot j$ 时，要用 $T$ 把它代替，这样才能有更多限制。</p>\n<p>不要遗漏式子中任何重要的信息，即使是小小的 $\\gcd(i,j) = 1$ 也包含 $i$、$j$ 互质这一重要条件。</p>\n<p>推式子时要想清楚式子的意义，在推不通时想更多的思路，更换更好的求和指标，最后才能到达成功的彼岸。</p>\n<p>式子即哲学，结果即真理。</p>\n","tags":["Editorial","数论","莫比乌斯反演","杜教筛"]},{"title":"NOIP2021 Journal","url":"/2021/11/20/NOIP2021-Journal/","content":"<p>人生中第一场NOIP，就这样落幕了</p>\n<h1 id=\"Day-1\"><a href=\"#Day-1\" class=\"headerlink\" title=\"Day -1\"></a>Day -1</h1><p>随便打了几个板子，发现没有什么需要复习的，因为所学实在太少，心态也十分放松，大概是知道自己状态不好，在短时间内也无法挽救，不会的知识实在太多，而能熟练运用的又太少，感觉再做什么也无济于事了。</p>\n<p><del>于是看了Person Of Interest Season 4，突然很想写一个能和我对话、保护我、洞悉世事的程序</del></p>\n<p>是的，考试的前一天就这样平凡地过去了  </p>\n<span id=\"more\"></span>\n<h1 id=\"Day-1-1\"><a href=\"#Day-1-1\" class=\"headerlink\" title=\"Day 1\"></a>Day 1</h1><p>大概7：50就进了考场，找到自己的座位，却发现电脑没开。于是自行打开，却发现有两个Windows10？等了一会，老师说用第二个，于是不那么顺利地进入了系统。</p>\n<p>先把缺省源打了，之后打了个对拍器，发现没关同步，于是加了两行代码到缺省源里，设置了编译选项，准备工作完成。</p>\n<p>大概在打完后不就，发现试卷的密码在大屏幕上，好像是IronHeart之类的（<del>钢铁雄心？？？</del>），难道出题人是Paradox玩家？但是没时间想那么多了，解压完成后就立刻打开了试题。</p>\n<p>照例先开第一题，发现题目说的东西很奇怪，而且数据范围也并非线性：$1e7$，这$O(nlogn)$都有点悬，不会要$O(n)$吧，但是这样也小了个七八倍，反正就很奇怪。</p>\n<p>之后仔细看了下题，发现只要把每一个符合条件的数的倍数都标记一遍就行了？（好像这便是著名的$O(nlogn)$算法）</p>\n<p>但是我觉得题目肯定不会这么简单，这样写肯定是要被卡的，于是研究了很久的性质，发现只要标记一个符合条件的数的质数倍就行了，因为合数肯定可以表示为若干个质数的乘积。</p>\n<p>但是即使这样写，也可能有TLE的风险，因为这样筛并不是绝对线性的，例如<strong>宇宙所有问题的终极答案$42$</strong>，它既可以表示成$14\\times3 = 7\\times2\\times3$，也可以表示成$21\\times2 = 7\\times3\\times2$，这样数$42$就被标记了两次，显然还有更多这样的数，所以这样做就不是线性的</p>\n<p>如何让每个数只被标记一次呢？其实也很显然：只要一个数的倍数被分解为的质因数中最小的数小于等于要乘的质数，就行了，因为满足倍数被分解为若干个不降的质数的情况只有一种。很好，这样就是完全线性的了！</p>\n<p>但是我没想到的是，由于还要用一遍$Euler$筛筛出所有的质数，所以复杂度是两个$O(n)$的，实测跑的比广为流传的$O(nlogn)$算法还要慢。。。</p>\n<p>由于各种意想不到的$bug$，过了$1.5h$才打完T1且开拍了</p>\n<p>算了，反正T1写完了，按理说要看T2了，于是我就看了。</p>\n<p>第一眼是一个以$m+1$为指数的暴力，开心地在$30min$左右写完了，发现样例2要跑$11s$？感觉再优化也没什么希望了，就暂时放下了，开T3</p>\n<p>T3一看，就想到了ZROI上的一道题，然而看了好久，发现其本质不是一个东西，拿前缀和推也没啥性质，而且这个序列可能可以无限操作下去，很难有重复的情况，推了一堆没有用的东西，发现只剩下$1.5h$左右了，以我的水平顶多打几个暴力走人，于是看了眼T4，发现没啥希望，跟斗地主一样恶心，就回去看T2了</p>\n<p>突然发现这样搜索搜到了很多重复的情况，很明显是不优的，如果改成枚举每一位选了多少个，就可以用排列乘出所有的情况，复杂度有了小小的改善，于是开写</p>\n<p>写完之后，发现乘那个权值时<strong>int128爆了，于是开始写高精，发现不会$log$的取模，于是把写了$45min$的高精代码删了，又改成</strong>int128，感觉没啥希望了，于是写T3的暴力</p>\n<p>T3由于不知道要操作多少次，就找了一个有可能过$n&lt;=10$的点且不超时的$9$次放进去了，发现第二个样例都过不了，此时离考试结束只有$30min$不到了，于是把考生须知填了，之后开始打坐。</p>\n<p>所有程序的文件名检查完之后，又看了一眼题面，试图找到一点思路，突然发现T2说的是小于等于$k$，草！</p>\n<p>于是疯狂改，再边乘边取模，最后竟然过了样例2？很满意</p>\n<p>打铃，收卷，结束。</p>\n<p>是的，我的第一场NOIP就这样结束了，内心毫无波澜的提交了文件夹，看见人均200+，虽有失望，可是并没有为此懊恼，因为有那么多没学的，有那么多不会的$trick$，这也很公平。</p>\n<p>停课结束后，又要投入到紧张的$whk$学习中，虽然有那么多不会的，那又如何呢，总是要补的。</p>\n<p>其实，生活中许多不如意，是你欠你自己的，付出与回报不会成正比，但是要回报，必须付出些什么，而最不必的便是为这些付出懊恼，你欠的，总是要还回来的嘛。</p>\n<blockquote>\n<p>This is my final fit</p>\n<p>My final bellyache with</p>\n<p>No alarms and no surprises</p>\n<p>No alarms and no surprises please</p>\n</blockquote>\n","tags":["Life"]},{"title":"LCM SUM 题解","url":"/2022/05/26/LCM-SUM-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"LCM-SUM-题解\"><a href=\"#LCM-SUM-题解\" class=\"headerlink\" title=\"LCM SUM 题解\"></a>LCM SUM 题解</h1><h2 id=\"推式子\"><a href=\"#推式子\" class=\"headerlink\" title=\"推式子\"></a>推式子</h2><p>$\\sum_{i=1}^n lcm(i,n)$</p>\n<p>把$lcm$变为$\\gcd$：</p>\n<p>$\\sum_{i=1}^n\\frac{i\\cdot n}{\\gcd(i,n)}$</p>\n<p>枚举$\\gcd$：</p>\n<p>$\\sum_{d|n}\\sum_{i=1}^n\\frac{i\\cdot n}{d}[gcd(\\frac{i}{d},\\frac{n}{d}) = 1]$</p>\n<span id=\"more\"></span>\n<p>设$t = \\frac{i}{d}$：</p>\n<p>$\\sum_{d|n}\\sum_{t=1}^{\\frac{n}{d}}tn[\\gcd(t,\\frac{n}{d}) = 1]$</p>\n<p>这里的$\\frac{n}{d}$看着很不爽，且这里都是约数，所以可以直接用$d$替换$\\frac{n}{d}$：</p>\n<p>$n\\sum_{d|n}\\sum_{t=1}^{d}t[\\gcd(t,d) = 1]$</p>\n<h2 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h2><p>这不就是求和$d$互质的数的和吗？</p>\n<p>因为$gcd(a,b) = gcd(a,b-a)$，所以不互质的数成对出现，平均值为$\\frac{n}{2}$，所以和$d$互质的数的和为$\\frac{d\\cdot \\varphi(d)}{2}$。</p>\n<p>注意当$d=1$时，这个值为$1$。</p>\n<p>预处理的时间复杂度为$O(n)$，每组数据求约数的时间复杂度为$O(\\sqrt n)$，后面的查询是$O(1)$的。</p>\n<p>总时间复杂度为$O(n+T\\sqrt n)$。</p>\n<h2 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h2><p>可以用莫比乌斯反演吗？</p>\n<p>把$\\gcd$用$\\mu$替换掉：</p>\n<p>$n\\sum_{d|n}\\sum_{t=1}^dt\\sum_{k|gcd(t,d)}\\mu(k)$</p>\n<p>枚举$k$：</p>\n<p>$n\\sum_{k=1}^n\\mu(k)\\sum_{d|n,k|d}\\sum_{t=1}^{d}t$</p>\n<p>注意到$k$为$d$的约数，$d$为$n$的约数，即$k$为$n$的约数，所以可以缩小$k$的枚举范围：</p>\n<p>$n\\sum_{k|n}\\mu(k)\\sum_{d|n,k|d}\\frac{d^2+d}{2}$</p>\n<p>之后，设$d’ = \\frac{d}{k}$，代入式中：</p>\n<p>$n\\sum_{k|n}\\mu(k)\\sum_{d’|\\frac{n}{k}}k\\frac{d’^2+d’}{2}$</p>\n<p>把$k$提出去：</p>\n<p>$n\\sum_{k|n}\\mu(k)k\\sum_{d’|\\frac{n}{k}}\\frac{d’^2+d’}{2}$</p>\n<p>我们只对后面的进行分析，前面的直接$O(\\sqrt n)$暴力求解：</p>\n<p>$\\sum_{d’|\\frac{n}{k}}\\frac{d’^2+d’}{2}$</p>\n<p>枚举$d’$，对它的所有倍数贡献$\\frac{d’^2+d’}{2}$，把所有$\\frac{n}{k}$的和都预处理出来，每次查询可以做到$O(1)$。</p>\n<p>预处理$\\mu$和$sum[\\frac{n}{k}]$的时间复杂度为$O(n+n\\log n)$，每组数据枚举$k$的时间复杂度为$O(\\sqrt n)$，求和时间复杂度为$O(1)$。</p>\n<p>于是，算法的总时间复杂度为$O(n\\log n+T\\sqrt n)$。</p>\n","tags":["Knowledge","数论","莫比乌斯反演"]},{"title":"P2261 余数求和 题解","url":"/2022/04/01/P2261-%E4%BD%99%E6%95%B0%E6%B1%82%E5%92%8C-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"P2261-余数求和-题解\"><a href=\"#P2261-余数求和-题解\" class=\"headerlink\" title=\"P2261 余数求和 题解\"></a>P2261 余数求和 题解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>好像每次看到这个题都挺懵的，思路不太好想。</p>\n<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给定$n$和$k$，求出$k \\ mod \\ 1+k \\ mod \\ 2+ \\cdot \\cdot \\cdot k \\ mod \\ n$。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>这个东西看上去就不太能直接求。</p>\n<p>我们既然不能一眼看出怎么求，那就多看几眼。</p>\n<p>$k \\ mod \\ i = k-\\lfloor k/i \\rfloor \\cdot i$</p>\n<p>这样，我们要求的东西就变成了：$k \\cdot n - \\sum_{i=1}^{n} \\lfloor k/i \\rfloor \\cdot i$</p>\n<p>这个$\\lfloor k/i \\rfloor$显然在$i$更大时变化的几率会越来越小，我们想一想怎么把它变化的规律找出来。</p>\n<p>（事实上，这个好像是数论分块里的内容，只能说：见多识广啊）</p>\n<p>我们凭空捏造一个函数$g(x) = \\lfloor k/\\lfloor k/x \\rfloor \\rfloor$。</p>\n<p>$f(x) = k/x$是单调递减的，所以$g(x)\\geq\\lfloor k/(k/x) \\rfloor = x$，所以$\\lfloor k/g(x) \\rfloor \\leq \\lfloor k/x \\rfloor$。</p>\n<p>又因为$\\lfloor k/g(x) \\rfloor \\geq \\lfloor k/(k/\\lfloor k/x \\rfloor) \\rfloor = \\lfloor k/x \\rfloor$，所以$\\lfloor k/g(x) \\rfloor = \\lfloor k/x \\rfloor$。</p>\n<p>所以，对于任意$i \\in [x,\\lfloor k/ \\lfloor k/x \\rfloor \\rfloor]$，$\\lfloor k/i \\rfloor$都相等。</p>\n<p>而且，每个数都必然属于所有区间中的一个，所以我们可以枚举左右端点，里面的$\\lfloor k/i \\rfloor \\cdot i$就是等差数列求和。</p>\n<p>由于在$\\sqrt{k}$以内的$i$，最多有$\\sqrt{k}$个$\\lfloor k/i \\rfloor$，所以这个式子的取值最多有$\\sqrt{k}$种，而在$\\sqrt{k}$以外的$i$，$k/i\\leq \\sqrt{k}$，所以这个式子最多也有$\\sqrt{k}$种取值，那么对于所有的$i$，最多只有$2\\sqrt{k}$种取值，所以整个算法的时间复杂度为$O(\\sqrt{k})$。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">int</span> n,k;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r,ans = n*k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=n;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (k/l == <span class=\"number\">0</span>) r = n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = <span class=\"built_in\">min</span>(k/(k/l),n);</span><br><span class=\"line\">\t\tans-=(r-l+<span class=\"number\">1</span>)*(k/l*l+k/l*r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","数学"]},{"title":"Remove Directed Edges 题解","url":"/2022/05/26/Remove-Directed-Edges-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Remove-Directed-Edges-题解\"><a href=\"#Remove-Directed-Edges-题解\" class=\"headerlink\" title=\"Remove Directed Edges 题解\"></a>Remove Directed Edges 题解</h1><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先考虑删除一些边之后的情况，这时我们要求一个最大的点集，使其中任意两点之间都至少单向可达。</p>\n<p>这是一个常见的套路（虽然我并不知道），最大的点集即为最长的路径。</p>\n<span id=\"more\"></span>\n<p>证明：因为这是一个有向无环图，所以其中一条路径上的点必然互相可达，若有一个不再这个路径上的点也可达其他任意一个点，那么必然出现一条分支，因为没分叉之前的点都可达，所以它到没分叉之前的点的方向和另一条路径的方向相同，于是这两条路径必然无法到达。</p>\n<p>那么，如何求出这条链呢？</p>\n<p>由于这是一条有向无环图，那么必然有拓扑序，我们通过拓扑排序求出每个点的最大路径长度就行了。</p>\n<p>之后，我们考虑删除哪条边：对于一个包含在路径中的边，它必须要有至少两个入边和出边，这样才能保证选择它时不会出现断路。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">4e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,head[N],tot,indeg[N],odeg[N],degs[N],dis[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y);</span><br><span class=\"line\">\t\tindeg[y]++;</span><br><span class=\"line\">\t\todeg[x]++;</span><br><span class=\"line\">\t\tdegs[y]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tdis[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!degs[i]) q.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\tx = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (indeg[y]&gt;<span class=\"number\">1</span> &amp;&amp; odeg[x]&gt;<span class=\"number\">1</span>) dis[y] = <span class=\"built_in\">max</span>(dis[y],dis[x]+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\tdegs[y]--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!degs[y]) q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans = <span class=\"built_in\">max</span>(ans,dis[i]);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","图论","拓扑排序"]},{"title":"P3959 宝藏 题解","url":"/2022/03/28/P3959-%E5%AE%9D%E8%97%8F-%E9%A2%98%E8%A7%A3/","content":"<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给出一个$n$个节点，$m$条边的图，你可以选定一个节点，从这个节点开始遍历整个图，其中每走到一条新的边，就要花费$l*k$的代价，其中$l$是这条边的边权，$k$是从你选定的点到这条边的起点经过的宝藏屋的数量。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"一些初步的想法\"><a href=\"#一些初步的想法\" class=\"headerlink\" title=\"一些初步的想法\"></a>一些初步的想法</h3><p>没有啥思路就直接暴搜。</p>\n<p>首先要枚举选择的起点，还要枚举选择的边，形式化的说，给每个边都定一个访问顺序，如果不访问就设为$0$，每个点都有$n+1$种选择，复杂度大概是$O(m^n)$的，啥都过不了。</p>\n<p>于是考虑优化。</p>\n<p>选定的边组成的必然是一棵树，这样才能使代价最小，而对于同一棵树而言，节点的选择顺序不会对答案有影响，所以我们可以枚举树，计算每个树的答案。枚举的过程是从$m$条边中选择$n-1$条，复杂度是$m\\cdot(m-1)\\cdot (m-2) \\cdot \\cdot \\cdot (m-n+1)$，计算每个树的答案可以直接换根dp解决，复杂度是$O(n)$的，这时，复杂度已经有了明显的改善。</p>\n<p>还有没有优化空间呢？有。</p>\n<p>因为我们是随便找出的$n-1$条边，它们不一定能构成树，而且题目里面有重边，显然我们只用选一个长度最小的就行了，这样边最多是$66$条，复杂度明显降低了。</p>\n<p>但是这里的$n$和$m$依旧不是一个量级的，我们能不能用$n$作为复杂度呢？</p>\n<p>我们直接搜索，重复状态很多，同一张图，选择不同的根，就会有$n$种状态，而我们用这个图转移到下一个图，只用从其中最小的状态转移，这样就减少了很多重复计算。</p>\n<p>既然状态有很多重复的，但是状态空间并不大，我们可以考虑使用<strong>状压DP</strong>优化。</p>\n<h3 id=\"一种错误的解法\"><a href=\"#一种错误的解法\" class=\"headerlink\" title=\"一种错误的解法\"></a>一种错误的解法</h3><p>设点$i$被选择为$1$，不被选择为$0$，这样我们可以表示在每个阶段中的状态。</p>\n<p>设$f[i]$表示压缩后的点的选择情况，我们枚举每个没有被选择，且能从已经被选择的其中一个点到达的点，选择一条路径到达那个点，这样就可以计算出要转移到的状态和最小值，如果存在一个更优解，就从这个状态继续转移。</p>\n<p>但是，一定是在有更优解的时候才会转移吗？</p>\n<p>如果一个点的深度比较小，但是这个点连向下一个点的边权比较大，我们可能会因为它转移到下一个状态时不是最优解而不再转移，但是如果让它继续转移下去，下面的点之间的边权较小，就有可能因为它的深度获益，这样可能会达到一个更优的解。</p>\n<p>所以，我认为这样做是错误的。</p>\n<p>据cyh大佬说，这是因为在同一个状态$s$中可能有一个点的深度不同，那么就不知道用哪个深度转移是最优的。</p>\n<h3 id=\"正确解法\"><a href=\"#正确解法\" class=\"headerlink\" title=\"正确解法\"></a>正确解法</h3><p>上面算法的错误在于没有限定深度，导致不同深度的时候转移不完全，我们其实可以限定一个当前的最大深度，之后把所有位于最大深度的点转移。</p>\n<p>设$f[i][j]$表示在最大深度为$i$，选择状态为$j$时的最小花费，那么$f[i][j] = max(f[i][j],f[i-1][k]+(i-1)\\cdot cost(j,k))$。</p>\n<p>我们先判断上一个状态的合法性：</p>\n<p>首先，这个状态要被转移过，否则转移它也没啥用，所以$f[i-1][k]$不等于初始值。</p>\n<p>其次，这个状态要满足从$k$能转移到$j$，这时就要考虑两个限制：</p>\n<ol>\n<li>$k$是$j$的一个子集，因为状态转移，选择的点只增不减。</li>\n<li>$j$是$expand(k)$的一个子集，$expand(k)$表示从$k$中已经选择的所有点往深度为$i$的点扩展，能够扩展到的所有点，则$j$必然在能够扩展到的点集内。</li>\n</ol>\n<p>我们再考虑如何计算扩展所需的花费$cost(j,k)$。</p>\n<p>先要找到所有被扩展的点，这个可以通过$j \\oplus k$计算出来。</p>\n<p>还要知道每个点被扩展所需的最小花费，由于每个$k$中的点深度都为$i-1$，所以到要扩展的点的经过的宝藏屋的数量是一样的，我们只用考虑路径长度就行了，而路径长度可以通过之前的$expand(k)$计算，即将所有能连向要扩展的点的路径长度取min。</p>\n<p>这样我们就完成了最重要的一步<strong>状态转移</strong>。</p>\n<p>之后就是初始化了，对于所有$x \\in [1,n]$，$f[1][(1&lt;&lt;x)] = 0$，因为是赞助商免费打通的，不需要费用，其他的都没有被转移，为了避免转移不合法的状态，其他的都设为$+ \\infty$。</p>\n<p>但是这样做，复杂度还不是最优的，因为$expand$和$cost$函数都会被重复计算很多次，我们可以预处理出来。</p>\n<p>时间复杂度：$O(n3^n+m2^n)$。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">25</span>,M = (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,edge[N][N],f[N][M],valid[M][M],cost[M][M],road[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">expand</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span>&#123; <span class=\"comment\">//复杂度为O(n^2) </span></span><br><span class=\"line\">\t<span class=\"type\">int</span> exp = i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;n;p++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;p)&amp;i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> q=<span class=\"number\">0</span>;q&lt;n;q++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (((<span class=\"number\">1</span>&lt;&lt;q)&amp;i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[p][q]&lt;=<span class=\"number\">10000000</span>)&#123;</span><br><span class=\"line\">\t\t\t\troad[q] = <span class=\"built_in\">min</span>(road[q],edge[p][q]);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;q)&amp;exp)) exp+=(<span class=\"number\">1</span>&lt;&lt;q);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> exp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//这里枚举顺序换一下会有优化效果，但是我喜欢在里面算exp，所以就不改了 </span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123; <span class=\"comment\">//之前的集合</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(road,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(road));</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> exp = <span class=\"built_in\">expand</span>(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;n);j++)&#123; <span class=\"comment\">//转移的集合</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((i&amp;j) == i &amp;&amp; (exp&amp;j) == j)&#123; <span class=\"comment\">//合法</span></span><br><span class=\"line\">\t\t\t\tvalid[i][j] = <span class=\"number\">1</span>; </span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;n;p++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ((j&amp;(<span class=\"number\">1</span>&lt;&lt;p)) &amp;&amp; !(i&amp;(<span class=\"number\">1</span>&lt;&lt;p))) cost[i][j]+=road[p];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(edge,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(edge));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\tx--;</span><br><span class=\"line\">\t\ty--;</span><br><span class=\"line\">\t\tedge[x][y] = <span class=\"built_in\">min</span>(edge[x][y],z);</span><br><span class=\"line\">\t\tedge[y][x] = <span class=\"built_in\">min</span>(edge[y][x],z);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) f[<span class=\"number\">1</span>][<span class=\"number\">1</span>&lt;&lt;i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123; <span class=\"comment\">//枚举深度 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;n);j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;(<span class=\"number\">1</span>&lt;&lt;n);p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (valid[j][p] &amp;&amp; f[i<span class=\"number\">-1</span>][j]&lt;=<span class=\"number\">100000000</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tf[i][p] = <span class=\"built_in\">min</span>(f[i][p],f[i<span class=\"number\">-1</span>][j]+(i<span class=\"number\">-1</span>)*cost[j][p]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> Min = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) Min = <span class=\"built_in\">min</span>(Min,f[i][(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\tcout&lt;&lt;Min&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","DP"]},{"title":"P4662黑手党题解","url":"/2022/03/19/P4662%E9%BB%91%E6%89%8B%E5%85%9A%E9%A2%98%E8%A7%A3/","content":"<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给一个有 $n$ 个点和 $m$ 条边的图，现在给定一个源点 $a$ ，一个汇点 $b$ 和去掉每个点所需的费用，求出需要去掉哪些点，使 $a$ 和 $b$ 不再连通的费用最小。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我们发现，只要把点变成边，边权设为去掉这个点的费用，就变成了求一个网络的最小割，即最大流，于是考虑通过Dinic算法求出最大流。</p>\n<p>我们用拆点解决将点变成边的问题。首先，原来图中就有的边，是不允许去掉的，所以我们要保证它不会被割掉，将其边权设为正无穷。对于图中的点，我们可以把一个点拆成两个，一个称作入点，即有流量进入的点，一个称作出点，即流量流向别的地方的点，我们从入点向出点连边，边权设为费用，这样我们就将点转化为了边。而原来图中连的边，可以看作从一个点的出点连向另一个点的入点。</p>\n<p>之后，我们可以跑一遍Dinic求出最大流，这样我们就找到了最小割。<strong>需要注意的是，题目中说明源点 $a$ 和汇点 $b$ 也是可以去掉的，所以我们要从源点 $a$ 的入边到汇点 $b$ 的出边跑最大流，这样才能让源点 $a$ 和汇点 $b$ 都能被去掉</strong>。</p>\n<p>这一部分是比较常见的套路。</p>\n<p><strong>不太寻常的是题目中的输出，求的是构成最小割的一个方案。</strong></p>\n<p>我们再来思考最小割的意义：</p>\n<p>最小割，即去掉某些边后，网络的源点和汇点不再连通，且边权之和最小。</p>\n<p>显然，在求出最大流后的残量网络中，从源点一定无法到达汇点。</p>\n<p>也就是说，我们只要从源点 $a$ 开始走，走所能到达的点，一定会存在某一时刻走不动了，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/image-20220319170146094.png\" alt=\"\"></p>\n<p>此图中，从源点 $a$ 开始，一直走，直到走到了 $x$，发现后面再走 $y$ 和 $z$ 的边权都为 $0$ ，不能继续走了，就说明如果将 $y$ 和 $z$ 割掉，源点途径 $x$ 的路径就永远无法到达汇点，也就是说，所有满足这样，这条边指向的点（如 $x$ ）被访问，但是出发点（如 $y$ 和 $z$ ）没有被访问的点，都是需要被去除的点，这样才能构成一个割。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e2</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,dis[N],now[N],in[N],out[N],vis[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; an;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[M*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">    edge[++tot].to = y;</span><br><span class=\"line\">    edge[tot].next = head[x];</span><br><span class=\"line\">    edge[tot].w = w;</span><br><span class=\"line\">    head[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">    dis[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    now[s] = head[s];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">            y = edge[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !dis[y])&#123;</span><br><span class=\"line\">                dis[y] = dis[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                now[y] = head[y];</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> flow)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">    <span class=\"type\">int</span> v,res = flow,use;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=now[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">        v = edge[i].to;</span><br><span class=\"line\">        now[u] = i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; dis[v] == dis[u]+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            use = <span class=\"built_in\">dfs</span>(v,<span class=\"built_in\">min</span>(edge[i].w,res));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!use) dis[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            edge[i].w-=use;</span><br><span class=\"line\">            edge[i^<span class=\"number\">1</span>].w+=use;</span><br><span class=\"line\">            res-=use;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!res) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> flow-res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> v;</span><br><span class=\"line\">    vis[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">        v = edge[i].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !vis[v]) <span class=\"built_in\">dfs2</span>(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"comment\">//算出入点和出点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        in[i] = i*<span class=\"number\">2</span><span class=\"number\">-1</span>;</span><br><span class=\"line\">        out[i] = i*<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = in[s];</span><br><span class=\"line\">    t = out[t];</span><br><span class=\"line\">    <span class=\"comment\">//读入与建图</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[i],out[i],x);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[i],in[i],<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[x],in[y],inf);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[y],out[x],<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[y],in[x],inf);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[x],out[y],<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//Dinic求出最小割</span></span><br><span class=\"line\">    <span class=\"type\">int</span> flow,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (flow = <span class=\"built_in\">dfs</span>(s,inf)) ans+=flow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//求出一个方案使源点和汇点不连通</span></span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=tot;i+=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!vis[edge[i].to] &amp;&amp; vis[edge[i^<span class=\"number\">1</span>].to])&#123;</span><br><span class=\"line\">            an.<span class=\"built_in\">push_back</span>((edge[i^<span class=\"number\">1</span>].to+<span class=\"number\">1</span>)/<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(an.<span class=\"built_in\">begin</span>(),an.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> sz = an.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;sz;i++) cout&lt;&lt;an[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","网络流"]},{"title":"Round 810 D 题解","url":"/2022/07/25/Round-810-D-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Round-810-D-题解\"><a href=\"#Round-810-D-题解\" class=\"headerlink\" title=\"Round 810 D 题解\"></a>Round 810 D 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>有 $n$ 处地方降雨，降雨的位置为 $x_i$，降雨量为 $p_i$，一个地方 $j$ 的降雨量为 $\\sum_{i=1}^np_i-|x_i-j|$，如果最大的降雨量大于等于 $m$，则说有洪水。现在对每一个 $i$，去掉第 $i$ 场雨，问你是否会发生洪水。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先考虑最简单的情况：求一个点的降雨量。</p>\n<p>把对降雨量产生贡献的线段找出来，分为左右两边，则降雨量等于 $p_l+x_l-k_l\\cdot j+p_r-x_r+k_r\\cdot j$。</p>\n<p>我们考虑将一次降雨（一条线段代表其产生贡献的区间）分成左右两个端点加上中点这三个点。</p>\n<p>把贡献分成左右两块来算。</p>\n<p>先从左往右扫一遍，则每次扫到中点，都会产生贡献，扫到终点，就减掉贡献，维护一下 $p_l,x_l,k_l$。</p>\n<p>然后从右往左扫一遍，同理维护 $p_r,x_r,k_r$。</p>\n<p>这样可以求出关键点的降雨量。</p>\n<p>如何计算消去一个线段之后的最大降雨量呢？</p>\n<p>显然，在起点到中点的关键点都减去了右边一块的贡献，在中点到终点的关键点都减去了左边一块的贡献，这可以用线段树来维护。</p>\n<p>$p,l$ 的改变是个定值，但是 $j$ 的改变却不是个定值，怎么办？</p>\n<p>很简单，虽然 $j$ 的改变看上去不是个定值，但是对于同一个位置 $j$ 来说，不管谁不再产生贡献，它都会减去一个定值 $j$，所以我们可以再维护一个全部都减去 $j$ 的修改之后的值，每次取其中一段的最大值即可。</p>\n<p>另一边的计算同理。</p>\n<p>现在已经 0:48 了，懒得实现了，起床之后再搞吧。</p>\n<p><del>竟然搞了1.5h才搞出来，太太太菜了锕！</del></p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,m,tot,b[N],cnt,v[N],glp[N],glx[N],Maxl[N],Maxr[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">lin</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p,x,ty,orix;</span><br><span class=\"line\">&#125; l[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tre</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,Max;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">SegT</span>&#123;</span><br><span class=\"line\">\ttre tr[N*<span class=\"number\">4</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\t\ttr[node].Max = <span class=\"built_in\">max</span>(tr[node&lt;&lt;<span class=\"number\">1</span>].Max,tr[node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>].Max);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> flag)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\t\ttr[node].l = tr[node].r = l;</span><br><span class=\"line\">\t\t\ttr[node].Max = v[l]+flag*b[l];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>,lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">build</span>(lc,l,mid,flag);</span><br><span class=\"line\">\t\t<span class=\"built_in\">build</span>(rc,mid+<span class=\"number\">1</span>,r,flag);</span><br><span class=\"line\">\t\ttr[node].l = tr[lc].l;</span><br><span class=\"line\">\t\ttr[node].r = tr[rc].r;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(node);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span> <span class=\"number\">-0x3f3f3f3f</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r) <span class=\"keyword\">return</span> tr[node].Max;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r),<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t1,t2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp1</span><span class=\"params\">(lin a,lin b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a.x&lt;b.x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcnt = tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;y&gt;&gt;x;</span><br><span class=\"line\">\t\t\tglp[i] = x;</span><br><span class=\"line\">\t\t\tglx[i] = y;</span><br><span class=\"line\">\t\t\tl[++tot].p = x;</span><br><span class=\"line\">\t\t\tl[tot].ty = <span class=\"number\">-1</span>; <span class=\"comment\">//左端点</span></span><br><span class=\"line\">\t\t\tl[tot].x = y-x;</span><br><span class=\"line\">\t\t\tl[tot].orix = y;</span><br><span class=\"line\">\t\t\tl[++tot].p = x;</span><br><span class=\"line\">\t\t\tl[tot].ty = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tl[tot].x = y; <span class=\"comment\">//中点 </span></span><br><span class=\"line\">\t\t\tl[tot].orix = y;</span><br><span class=\"line\">\t\t\tl[++tot].p = x;</span><br><span class=\"line\">\t\t\tl[tot].ty = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tl[tot].x = y+x; <span class=\"comment\">//右端点</span></span><br><span class=\"line\">\t\t\tl[tot].orix = y;</span><br><span class=\"line\">\t\t\tb[++cnt] = y-x;</span><br><span class=\"line\">\t\t\tv[cnt] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tb[++cnt] = y;</span><br><span class=\"line\">\t\t\tv[cnt] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tb[++cnt] = y+x;</span><br><span class=\"line\">\t\t\tv[cnt] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+cnt);</span><br><span class=\"line\">\t\tcnt = <span class=\"built_in\">unique</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+cnt)-b<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(l+<span class=\"number\">1</span>,l+<span class=\"number\">1</span>+tot,cmp1);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pl = <span class=\"number\">0</span>,xl = <span class=\"number\">0</span>,cntl = <span class=\"number\">0</span>,now = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (l[now].x&lt;=b[i] &amp;&amp; now&lt;=tot)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (l[now].ty == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tpl+=l[now].p;</span><br><span class=\"line\">\t\t\t\t\txl+=l[now].orix;</span><br><span class=\"line\">\t\t\t\t\tcntl++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l[now].ty == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tpl-=l[now].p;</span><br><span class=\"line\">\t\t\t\t\txl-=l[now].orix;</span><br><span class=\"line\">\t\t\t\t\tcntl--;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tnow++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tv[i]+=pl+xl-cntl*b[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnow = tot;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pr = <span class=\"number\">0</span>,xr = <span class=\"number\">0</span>,cntr = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=cnt;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (l[now].x&gt;=b[i] &amp;&amp; now&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (l[now].ty == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tpr+=l[now].p;</span><br><span class=\"line\">\t\t\t\t\txr+=l[now].orix;</span><br><span class=\"line\">\t\t\t\t\tcntr++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l[now].ty == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tpr-=l[now].p;</span><br><span class=\"line\">\t\t\t\t\txr-=l[now].orix;</span><br><span class=\"line\">\t\t\t\t\tcntr--;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tnow--;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tv[i]+=pr-xr+cntr*b[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) v[<span class=\"built_in\">lower_bound</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+cnt,glx[i])-b]-=glp[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++) Maxl[i] = <span class=\"built_in\">max</span>(Maxl[i<span class=\"number\">-1</span>],v[i]);</span><br><span class=\"line\">\t\tMaxr[cnt+<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=cnt;i&gt;=<span class=\"number\">1</span>;i--) Maxr[i] = <span class=\"built_in\">max</span>(Maxr[i+<span class=\"number\">1</span>],v[i]);</span><br><span class=\"line\">\t\tt1.<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,cnt,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\tt2.<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,cnt,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> l = <span class=\"built_in\">lower_bound</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+cnt,glx[i]-glp[i])-b,mid = <span class=\"built_in\">lower_bound</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+cnt,glx[i])-b,r = <span class=\"built_in\">lower_bound</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+cnt,glx[i]+glp[i])-b;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> ans = <span class=\"built_in\">max</span>(Maxl[l<span class=\"number\">-1</span>],Maxr[r+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t\tans = <span class=\"built_in\">max</span>(ans,<span class=\"built_in\">max</span>(t1.<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,l,mid)-glp[i]+glx[i],t2.<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r)-glp[i]-glx[i]));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (ans&lt;=m) cout&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","线段树"]},{"title":"Surveillance 题解","url":"/2022/07/15/Surveillance-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Surveillance-题解\"><a href=\"#Surveillance-题解\" class=\"headerlink\" title=\"Surveillance 题解\"></a>Surveillance 题解</h1><p>$\\color{lightgreen}Status: OK$</p>\n<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给你一个环和若干条覆盖环的线段，求覆盖整个环所需的最小的线段数量。<br><span id=\"more\"></span></p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>看到环，就要化环为链，先复制一份在后面，之后再把线段存进去。</p>\n<p>于是，问题变成了，在长度为 $2n$ 的链上，选出一些线段，使其能覆盖大于等于 $n$ 的链。</p>\n<p>这个问题是可以贪心的。假设现在在位置 $i$，那么要选的线段一定是覆盖位置 $i$，且右端点最大的线段，这样才能最优。</p>\n<p>这个东西可以用一个 set 或优先队列维护。</p>\n<p>但是，直接枚举起点，再这样搞，时间复杂度可能达到 $O(n^2\\log n)$，无法通过。</p>\n<p>我们可以对每一个位置，把它能跳到的最远的位置算出来，时间复杂度为 $O(n\\log n)$。</p>\n<p>之后利用倍增的思想，把每个位置跳 $2^i$ 次到达的位置算出来，这样枚举起点之后，每个起点的求解就是 $O(n\\log n)$ 了。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,st[N][<span class=\"number\">21</span>],ans;</span><br><span class=\"line\">set&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">lin</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r;</span><br><span class=\"line\">&#125; l[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(lin x,lin y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x.l&lt;y.l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">20</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n*<span class=\"number\">2</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (st[j][i<span class=\"number\">-1</span>]) st[j][i] = st[st[j][i<span class=\"number\">-1</span>]+<span class=\"number\">1</span>][i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">1</span>,tmp = x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">20</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (st[x][i]&gt;=x &amp;&amp; st[x][i]&lt;tmp+n<span class=\"number\">-1</span>) x = st[x][i]+<span class=\"number\">1</span>,cnt+=(<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (st[x][<span class=\"number\">0</span>]&gt;=tmp+n<span class=\"number\">-1</span>) ans = <span class=\"built_in\">min</span>(ans,cnt);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cin&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t\tans = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">\t\ts.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x&gt;y) y+=n;</span><br><span class=\"line\">\t\t\tl[i].l = x;</span><br><span class=\"line\">\t\t\tl[i].r = y;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(l+<span class=\"number\">1</span>,l+<span class=\"number\">1</span>+k,cmp);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n*<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (l[now].l == i &amp;&amp; now&lt;=k)&#123;</span><br><span class=\"line\">\t\t\t\ts.<span class=\"built_in\">insert</span>(l[now].r);</span><br><span class=\"line\">\t\t\t\tnow++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tst[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!s.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">auto</span> it = s.<span class=\"built_in\">end</span>();</span><br><span class=\"line\">\t\t\t\tit--;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (*it&gt;=i) st[i][<span class=\"number\">0</span>] = *it;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"built_in\">chk</span>(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans == <span class=\"number\">0x3f3f3f3f</span>) cout&lt;&lt;<span class=\"string\">&quot;impossible&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">2</span>*n;i++) <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=<span class=\"number\">20</span>;j++) st[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","ST表"]},{"title":"Useless Thoughts(遐想)","url":"/2021/08/02/Useless-Thoughts-%E9%81%90%E6%83%B3/","content":"<p><strong>War, war never changes.</strong></p>\n<p><strong>But peace, peace changes everything.</strong></p>\n<p>犹记得曾经带领举国10个远古军团在《文明Ⅵ》中鲁莽地向自己的友邦瑞士开战，在军队突破阿拉伯的援兵，围在没有任何防御的日内瓦城的所有边界方格上，取得第一次压倒性胜利时的喜悦与狂热，对占领的渴望充斥着我的大脑。  </p>\n<span id=\"more\"></span>\n<p>也记得被阿拉伯疯狂传教、在边境造城挑衅后愤然发起突袭战争，率领接近20个单位的远征大军朝着开罗进发时的意气风发；但谁能想到几回合后我就被困在防御工事内进退不得，只得在阿拉伯的现代化大军到来前从海上逃跑，而又是什么导致了这场战争呢？是对复仇的渴望。</p>\n<p>最近了解了伊拉克战争和阿富汗战争，对此更是深有同感。9.11事件成为了阿富汗战争的导火索，控制石油资源的诱惑则导致了伊拉克战争，反观历史上的重大战争，又有哪个不是基于利益和复仇的呢？</p>\n<p>但在战争的进程中，有一方的力量却被忽视了——士兵。在游戏中，他们被化为单调的数值；在国家之间的战争中，他们被作为实力较量的筹码；在军官心中，他们被作为任人摆布的棋子。哪位国家元首曾将他们与经济损失、基础建设修复、物资补给一起计算战争的代价？P社玩家之所以成为”大恶人”，还不是因为他们无视面板上增加的死亡人数，狂热的发动战争，丝毫没想过那些数字对于他们的家人，挚友意味着什么！战争永远不会是美好的，不会是地图上几条线共同导向的结果，更不会是按动鼠标上的左右键就能完全体会的，其中酿成了多少人间悲剧，造就了多少绝望的结局，我们又如何得知！</p>\n<p>但仔细思考一下，各种冲突才是导致战争的最大缘由：边境冲突，宗教冲突，政党冲突（省略）它们也许是人类永远无法避免的命运。但就像线段树一样，作为叶子节点的我们，如果更加平和、宽容待人，能从生活中一个完美的光影，一个样貌奇特的绿树，一个陌生人的有趣谈话中发现美好，不过于厌世，也不盲目服从，那样也许经过多次pushup操作，上层的祖先们就会更加和睦，做出宝贵的和平决定吧。</p>\n<p>（吹爆COD现代战争三部曲）</p>\n","tags":["Life"]},{"title":"WHK目录","url":"/2022/02/11/WHK%E7%9B%AE%E5%BD%95/","content":"<h1 id=\"目录：\"><a href=\"#目录：\" class=\"headerlink\" title=\"目录：\"></a>目录：</h1><span id=\"more\"></span>\n<h2 id=\"化学\"><a href=\"#化学\" class=\"headerlink\" title=\"化学\"></a>化学</h2><h3 id=\"必修1\"><a href=\"#必修1\" class=\"headerlink\" title=\"必修1\"></a>必修1</h3><h4 id=\"第一单元\"><a href=\"#第一单元\" class=\"headerlink\" title=\"第一单元\"></a>第一单元</h4><h5 id=\"Part-1：物质的分类\"><a href=\"#Part-1：物质的分类\" class=\"headerlink\" title=\"Part 1：物质的分类\"></a>Part 1：<a href=\"https://bowenone580.github.io/2022/02/11/物质的分类/\">物质的分类</a></h5>","tags":["Knowledge","WHK","Menu"]},{"title":"YY的GCD 题解","url":"/2022/05/26/YY%E7%9A%84GCD-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"YY的GCD-题解\"><a href=\"#YY的GCD-题解\" class=\"headerlink\" title=\"YY的GCD 题解\"></a>YY的GCD 题解</h1><p>$gcd(x,y) = k(k \\in prime)$</p>\n<p>$gcd(x/k,y/k) = 1$</p>\n<p>正如某位大佬所说，此时应该直接上反演结论：</p>\n<p>$\\sum_{i=1}^n\\sum_{j=1}^mgcd(\\frac{i}{k},\\frac{j}{k}) = 1 \\iff \\sum_{i=1}^{\\frac{n}{k}}\\sum_{j=1}^{\\frac{m}{k}}\\sum_{d|gcd(i,j)}\\mu(d)$。</p>\n<p>发现，这个式子实际上就是求对于固定的$d$，所有为$d$的倍数的对数之和，于是可以把$d$挪出来：</p>\n<p>$\\sum_{d=1}^{min(n/k,m/k)}\\mu(d)\\lfloor n/dk\\rfloor \\lfloor m/dk\\rfloor$。</p>\n<span id=\"more\"></span>\n<p>这样，我们就得到了对于单个质数$k$的对数之和。但是，这样做的复杂度约为$O(n\\sqrt n)$，无法通过。</p>\n<p>利用题解区说的套路，设$t=dk$，则：</p>\n<p>$\\sum_{k \\in prime} \\sum_{d=1}^{min(n/k,m/k)}\\mu(t/k)\\lfloor n/t\\rfloor \\lfloor m/t \\rfloor \\iff \\sum_{t=1}^{min(n,m)} \\sum_{k \\in prime, k|t}\\mu(t/k)\\lfloor n/t\\rfloor \\lfloor m/t\\rfloor \\iff \\sum_{t=1}^{min(n,m)}\\lfloor n/t \\rfloor \\lfloor m/t \\rfloor \\sum_{k \\in prime, k|t}\\mu(t/k)$</p>\n<p>这个$\\sum_{k\\in prime, k|t}\\mu(t/k)$是可以预处理出来的，我们可以像埃氏筛一样把$k$的倍数都加一下。</p>\n<p>预处理的复杂度接近$O(n)$，每次询问，我们只用把前面的用数论分块算出来，乘上后面的和就行了，时间复杂度为$O(\\sqrt n)$。</p>\n<p>总时间复杂度为$O(n+T\\sqrt n)$。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e7</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,m,vis[N],pri[N],tot,mu[N];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sum[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = <span class=\"number\">1e7</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j*pri[i]&lt;=lim;j++)&#123;</span><br><span class=\"line\">\t\t\tsum[j*pri[i]]+=mu[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) sum[i]+=sum[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r,Min = <span class=\"built_in\">min</span>(n,m);</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=Min;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tr = <span class=\"built_in\">min</span>(n/(n/l),m/(m/l));</span><br><span class=\"line\">\t\t\tans+=(sum[r]-sum[l<span class=\"number\">-1</span>])*(n/l)*(m/l);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","数论","莫比乌斯反演"]},{"title":"ZAP-Queries 题解","url":"/2022/05/26/ZAP-Queries-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"ZAP-Queries-题解\"><a href=\"#ZAP-Queries-题解\" class=\"headerlink\" title=\"ZAP-Queries 题解\"></a>ZAP-Queries 题解</h1><p>求$gcd(i,j) = d$的数对的数量。</p>\n<p>这个式子需要化简，我们将其变为$gcd(i/d,j/d) = 1$。</p>\n<p>固定$j/d$，变成求和它互质的数的个数，可以直接用欧拉函数解决。</p>\n<p>但是，这样做的时间复杂度为每组数据$O(n)$，据说数据组数的级别也是$O(n)$的，所以总复杂度为$O(n^2)$，会超时，需要更优的算法。</p>\n<span id=\"more\"></span>\n<p>如果用莫比乌斯反演，那就必须先搞出两个函数来：</p>\n<p>第一个函数显然是我们的答案函数：$f(k) = \\sum_{i=1}^a\\sum_{j=1}^b[gcd(i,j) = k]$。</p>\n<p>第二个函数要和它有关系，我们不妨设$g(x) = \\sum_{x|k}f(k)$。</p>\n<p>直接上反演：$f(x) = \\sum_{x|k}\\mu(\\frac{k}{x})g(k)$。</p>\n<p>考虑$g(x)$求的到底是啥，发现是所有$gcd$是$x$的倍数的数的个数之和，这个东西显然只要两个数都是$x$的倍数就行了，于是可以转化为$g(x) = \\lfloor a/x\\rfloor \\lfloor b/x\\rfloor$。</p>\n<p>所以，最后的$f(d) = \\sum_{d|k}\\mu(\\frac{k}{d})\\lfloor a/k\\rfloor \\lfloor b/k\\rfloor$。</p>\n<p>但是，即使化成这样，也不好计算它的值，这个$\\mu$每次算一遍很浪费，而且它都是从$[1,x]$内的所有整数（$x$是一个不确定的上界），不难想到预处理出前缀和，方便计算。</p>\n<p>但是，后面还跟着两个东西，它们也不好分离开，而且$k$是不确定的，所以我们先做一个替换：$t = \\frac{k}{d}$，于是式子变为$f(d) = \\sum_{i=1}^x\\mu(i)\\lfloor \\frac{a}{td} \\rfloor \\lfloor \\frac{b}{td} \\rfloor$，把$d$提出来，变成$\\sum_{i=1}^x\\mu(i)\\frac{\\lfloor \\frac{a}{t} \\rfloor}{d}\\frac{\\lfloor \\frac{b}{t} \\rfloor}{d}$。</p>\n<p>发现后面的一块很像数论分块，于是想到用数论分块的思想优化复杂度，把后面的那一段相同的都找出来，捆绑计算，$\\mu$的值可以通过预处理前缀和实现$O(1)$计算，所以计算一次的时间复杂度为$O(\\sqrt{n})$。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,a,b,d,vis[N],pri[N],tot,mu[N],sum[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = <span class=\"number\">5e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) sum[i] = sum[i<span class=\"number\">-1</span>]+mu[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;d;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=<span class=\"built_in\">min</span>(a/d,b/d);l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tr = <span class=\"built_in\">min</span>(a/(a/l),b/(b/l));</span><br><span class=\"line\">\t\t\tans+=<span class=\"number\">1ll</span>*(sum[r]-sum[l<span class=\"number\">-1</span>])*(a/(d*l))*(b/(d*l));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","数论","莫比乌斯反演"]},{"title":"公约数的和 题解","url":"/2022/05/26/%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E5%92%8C-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"公约数的和-题解\"><a href=\"#公约数的和-题解\" class=\"headerlink\" title=\"公约数的和 题解\"></a>公约数的和 题解</h1><h2 id=\"单组数据\"><a href=\"#单组数据\" class=\"headerlink\" title=\"单组数据\"></a>单组数据</h2><p>$\\sum_{i=1}^n\\sum_{j=i+1}^n\\gcd(i,j)$</p>\n<p>这个式子中$j$从$i+1$开始，不好转化，于是根据$gcd(i,j) = gcd(j,i)$，我们把它转化一下：</p>\n<p>$\\frac{\\sum_{i=1}^n\\sum_{j=1}^n\\gcd(i,j)-\\sum_{i=1}^n\\gcd(i,i)}{2}$</p>\n<p>枚举$\\gcd$的值：</p>\n<p>$\\sum_{d=1}^nd\\sum_{i=1}^n\\sum_{j=1}^n[\\gcd(i,j) = d]$</p>\n<span id=\"more\"></span>\n<p>设$i’ = \\frac{i}{d}$，$j’ = \\frac{j}{d}$，代入：</p>\n<p>$\\sum_{d=1}^nd\\sum_{i’=1}^{\\frac{n}{d}}\\sum_{j’=1}^{\\frac{n}{d}}[\\gcd(i’,j’) = 1]$</p>\n<p>将$\\gcd$变成$\\mu$：</p>\n<p>$\\sum_{d=1}^nd\\sum_{i’=1}^{\\frac{n}{d}}\\sum_{j’=1}^{\\frac{n}{d}}\\sum_{k|\\gcd(i’,j’)}\\mu(k)$</p>\n<p>枚举$k$：</p>\n<p>$\\sum_{d=1}^nd\\sum_{k=1}^{\\frac{n}{d}}\\mu(k)\\lfloor \\frac{n}{dk}\\rfloor^2$</p>\n<p>直接套数论分块可以做到$O(n\\sqrt n)$，但是不足以通过此题。</p>\n<p>但是，仔细观察一下，发现这个$\\frac{n}{1}+\\frac{n}{2}+\\cdots +\\frac{n}{n}$的结果是$\\log$级别的，所以实际的复杂度为$O(n\\log n)$，可以通过此题。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>如果有多组数据，且$n$的限制不变，该怎么办？</p>\n<p>此时，我们显然不能再$O(n\\log n)$回答每组询问了，需要更高效的算法。</p>\n<p>之前的算法瓶颈主要在前面枚举$d$上，可是这里好像也没有优化空间了。</p>\n<p>这时，我们应该换一种思路：</p>\n<p>求这个是比较方便的：</p>\n<p>$\\sum_{i=1}^n\\gcd(i,n)$</p>\n<p>枚举$\\gcd$：</p>\n<p>$\\sum_{d|n}d\\sum_{i=1}^n[gcd(i,n) = d]$</p>\n<p>同时除$d$：</p>\n<p>$\\sum_{d|n}d\\sum_{i=1}^{\\frac{n}{d}}[gcd(i,\\frac{n}{d}) = 1]$</p>\n<p>后面的东西就是$\\varphi(\\frac{n}{d})$。</p>\n<p>于是，这个东西只需要$O(\\sqrt n)$的复杂度就可以了。</p>\n<p>我们要求的东西就是$\\sum_{i=1}^{n}(\\sum_{d|i}d\\cdot \\varphi(\\frac{i}{d}))-i$。</p>\n<p>这个东西可以$O(n\\log n)$预处理出来。</p>\n","tags":["Knowledge","数论","莫比乌斯反演"]},{"title":"冒泡排序 题解","url":"/2022/10/03/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"冒泡排序-题解\"><a href=\"#冒泡排序-题解\" class=\"headerlink\" title=\"冒泡排序 题解\"></a>冒泡排序 题解</h1><h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给你一个序列，每次可以交换相邻的两个数，或者查询对整个序列进行 $k$ 次冒泡排序之后的逆序对数量（这个操作不改变原序列）。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>手动模拟一下，发现冒泡排序的过程本质上就是，找到一个数，它的前面没有比它更大的数，找到它后面第一次出现比它更大的数的位置，将中间的数全部向左平移一位，把它放到比它大的那个数前面去。</p>\n<p>假设这样满足前面所有数都比它小的数有 $k$ 个，则这一次冒泡排序结束后，逆序对个数减少 $n-k$ 个。</p>\n<span id=\"more\"></span>\n<p>转换一下角度，一个数前面如果有 $k$ 个数比它大，那么它的逆序对个数每一轮 $-1$，直到第 $k$ 轮减到 $0$。</p>\n<p>证明：显然，每次越过它的数只能是前面的数中最大的一个，每次去掉一个最大的，去掉 $k$ 次之后就没有了。</p>\n<p>我们设 $b[i]$ 表示第 $i$ 个数前面有几个数比它大，考虑先预处理出进行 $k$ 轮排序后，逆序对的数量总和。</p>\n<p>第 $0$ 轮显然有 $\\sum_{i=1}^nb[i]$。</p>\n<p>第 $i$ 轮，能够对逆序对产生贡献的只有 $b[i]\\geq i$的数，即逆序对总数应该减去 $\\sum_{i,b[i]\\geq i}1$。</p>\n<p>再考虑如何计算修改产生的贡献。</p>\n<p>交换两个数的位置，有两种情况：</p>\n<ol>\n<li><p>$a[i]&lt;a[i+1]$。</p>\n<p>交换之后，$b[i+1]$ 要增大 $1$，因为 $a[i]&gt;a[i+1]$，而 $b[i]$ 不变。</p>\n<p>考虑逆序对数量的变化。</p>\n<p>由于 $b[i+1]$ 增大了 $1$，所以最初的逆序对数量应该增加 $1$。</p>\n<p>而 $b[i+1]$ 增大了 $1$，说明它的影响可以延后一位，即第 $b[i+1]$ 轮的减少量应该增加 $1$。</p>\n</li>\n<li><p>$a[i]&gt;a[i+1]$</p>\n<p>交换之后，$b[i]$ 要减少 $1$。</p>\n<p>由于 $b[i]$ 减少了 $1$，所以最初的逆序对数量应该减少 $1$。</p>\n<p>而 $b[i]$ 减少了 $1$，说明它的影响提前了一位，即第 $b[i]+1$ 轮的减少量应该减小 $1$。</p>\n</li>\n</ol>\n<p>处理好这些问题后，这道题就做完了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>很好的一道题，没有点对冒泡排序的深入认识还真有点困难，一定能够让你对冒泡排序的理解更深一步。 </p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,a[N],b[N],c[N];</span><br><span class=\"line\">ll tr[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">judge</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;test.in&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">\t<span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;test.out&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,stdout);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> x,ll v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;x&lt;=n;x+=(x&amp;(-x))) tr[x]+=v;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\tll ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;x;x-=(x&amp;(-x))) ret+=tr[x];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\tll cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tb[i] = i<span class=\"number\">-1</span>-<span class=\"built_in\">query</span>(a[i]);</span><br><span class=\"line\">\t\tcnt+=b[i];</span><br><span class=\"line\">\t\tc[b[i]]++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(a[i],<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(tr,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(tr));</span><br><span class=\"line\">\t<span class=\"built_in\">update</span>(<span class=\"number\">1</span>,cnt);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tnow+=c[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(i+<span class=\"number\">1</span>,-(n-now));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> op,x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op&gt;&gt;x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(a[x],a[x+<span class=\"number\">1</span>]),<span class=\"built_in\">swap</span>(b[x],b[x+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[x]&gt;a[x+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t\t\tb[x+<span class=\"number\">1</span>]++;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">update</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>),<span class=\"built_in\">update</span>(b[x+<span class=\"number\">1</span>]+<span class=\"number\">1</span>,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tb[x]--;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">update</span>(<span class=\"number\">1</span>,<span class=\"number\">-1</span>),<span class=\"built_in\">update</span>(b[x]+<span class=\"number\">2</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x&gt;=n) cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"built_in\">query</span>(x+<span class=\"number\">1</span>)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","Editorial","树状数组"]},{"title":"力 题解","url":"/2022/07/07/%E5%8A%9B-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"力-题解\"><a href=\"#力-题解\" class=\"headerlink\" title=\"力 题解\"></a>力 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给出 $q_1,q_2\\cdots q_n$，求 $E_i = \\sum_{j=1}^{i-1}\\frac{q_j}{(i-j)^2}\\sum_{j=i+1}^n\\frac{q_j}{(i-j)^2}$。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>如果要使用 FFT，最后都要化成加法卷积的形式：</p>\n<p>$C[k] = \\sum_{i+j = k}A[i]*B[j]$</p>\n<p>这里的 $C[k],A[i],B[j]$ 都是多项式的系数。</p>\n<span id=\"more\"></span>\n<p>先把 $*$ 搞出来：</p>\n<p>设 $A(x) = q_nx^n+q_{n-1}x^{n-1}\\cdots+q_0$，$B(x) = \\frac{x^n}{n^2}+\\frac{x^{n-1}}{(n-1)^2}+\\cdots +0^2$。</p>\n<p>$E_i = \\sum_{j=1}^{i-1}A[j]<em>B[i-j]-\\sum_{j=i+1}^nA[j]</em>B[j-i]$</p>\n<p>两边都加上一个 $i$，之后把左边扩展到 $0$（$A[0] = B[0] = 0$）：</p>\n<p>$E_i = \\sum_{j=0}^iA[j]<em>B[i-j]-\\sum_{j=i}^nA[j]</em>B[j-i]$</p>\n<p>左边的已经是卷积形式了，不用管它，继续推右边。</p>\n<p>首先，这个东西必须从 $0$ 开始，于是采用换元法，令 $T = j-i$：</p>\n<p>$\\sum_{T=0}^{n-i}A[T+i]B[T]$</p>\n<p>发现化不了了，于是考虑另取一个多项式，硬凑出来：</p>\n<p>设 $A[i] = A’[n-i]$，则：</p>\n<p>$\\sum_{T=0}^{n-i}A’[(n-i)-T]B[T]$</p>\n<p>这样，我们就把原式化为了这个东西：</p>\n<p>$E_i = \\sum_{j=0}^iA[j]*B[i-j]-\\sum_{T=0}^{n-i}A’[(n-i)-T]B[T]$</p>\n<p>直接用 FFT 计算左右两边卷积在 $i$ 和 $n-i$ 处的系数即可。 </p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> Pi = <span class=\"built_in\">acos</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">3e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,sw[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">cp</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">double</span> x,y;</span><br><span class=\"line\">\tcp <span class=\"keyword\">operator</span> + (cp <span class=\"type\">const</span> &amp;b) <span class=\"type\">const</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;x+b.x,y+b.y&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcp <span class=\"keyword\">operator</span> - (cp <span class=\"type\">const</span> &amp;b) <span class=\"type\">const</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;x-b.x,y-b.y&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcp <span class=\"keyword\">operator</span> * (cp <span class=\"type\">const</span> &amp;b) <span class=\"type\">const</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;x*b.x-y*b.y,x*b.y+y*b.x&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; a[N],b[N],c[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fft</span><span class=\"params\">(cp *f,<span class=\"type\">int</span> flag)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) <span class=\"keyword\">if</span> (i&lt;sw[i]) <span class=\"built_in\">swap</span>(f[i],f[sw[i]]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">2</span>;p&lt;=n;p&lt;&lt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> len = p&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tcp rt = &#123;<span class=\"built_in\">cos</span>(<span class=\"number\">2</span>*Pi/p),flag*<span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*Pi/p)&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i+=p)&#123;</span><br><span class=\"line\">\t\t\tcp now = &#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,tmp;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i;j&lt;i+len;j++)&#123;</span><br><span class=\"line\">\t\t\t\ttmp = now*f[j+len];</span><br><span class=\"line\">\t\t\t\tf[j+len] = f[j]-tmp;</span><br><span class=\"line\">\t\t\t\tf[j] = f[j]+tmp;</span><br><span class=\"line\">\t\t\t\tnow = now*rt;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcout&lt;&lt;fixed&lt;&lt;<span class=\"built_in\">setprecision</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tb[i].x = <span class=\"number\">1.0</span>/(<span class=\"number\">1ll</span>*i*i);</span><br><span class=\"line\">\t\tc[i].x = a[n-i].x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc[<span class=\"number\">0</span>].x = a[n].x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = n;</span><br><span class=\"line\">\tm = n*<span class=\"number\">2</span>,n = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (n&lt;=m) n&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) sw[i] = (sw[i&gt;&gt;<span class=\"number\">1</span>]&gt;&gt;<span class=\"number\">1</span>)|(i&amp;<span class=\"number\">1</span>?n&gt;&gt;<span class=\"number\">1</span>:<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">fft</span>(a,<span class=\"number\">1</span>),<span class=\"built_in\">fft</span>(b,<span class=\"number\">1</span>),<span class=\"built_in\">fft</span>(c,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) a[i] = a[i]*b[i],c[i] = c[i]*b[i];</span><br><span class=\"line\">\t<span class=\"built_in\">fft</span>(a,<span class=\"number\">-1</span>),<span class=\"built_in\">fft</span>(c,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tmp;i++) cout&lt;&lt;a[i].x/n-c[tmp-i].x/n&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","数学","多项式","FFT"]},{"title":"卡特兰数","url":"/2021/08/04/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","content":"<h2 id=\"更新记录\"><a href=\"#更新记录\" class=\"headerlink\" title=\"更新记录\"></a>更新记录</h2><p>2021.9.22 将部分内容替换成了$LaTeX$符号</p>\n<span id=\"more\"></span>  \n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><h3 id=\"排列数\"><a href=\"#排列数\" class=\"headerlink\" title=\"排列数\"></a>排列数</h3><p>$A_n^m$ $ = $ $\\frac{n!}{(n-m)!}$ （从$n$个数中选$m$个来排列）<br>理解为第一位可以有$n$种选择，第二位有$n-1$种，最后一位（即第$m$位）有$n-m+1$种选择<br>故为$n$ $\\times$ $(n-1)$ $\\times$ $(n-2)$ $\\times$ … $\\times$ $(n-m+1) = $ $\\frac{n!}{(n-m)!}$<br>全排列为$n!$</p>\n<h3 id=\"组合数\"><a href=\"#组合数\" class=\"headerlink\" title=\"组合数\"></a>组合数</h3><p>$C_n^m$ $=$ $\\frac{n!}{(n-m)!*m!}$<br>理解为将$A_n^m$的所有组合方式表示出来，也就是$m$的全排列，为$m!$，常将$n$与$m$写在一个括号里: $\\binom{m}{n}$<br>特别说明：$A_n^m$ $= 0$, $C_n^m$ $= 0$</p>\n<p><del>（写了这么多主要是因为看不懂将C写成括号后的表达方式）</del></p>\n<h2 id=\"卡特兰数的证明\"><a href=\"#卡特兰数的证明\" class=\"headerlink\" title=\"卡特兰数的证明\"></a>卡特兰数的证明</h2><p>首先想一个<strong>简单一点</strong>的问题：<br>你有一个栈，$n$个数，它们每一个都要进行一次入栈和出栈操作，请问共有多少种方式<br>可以将每次入栈操作看作 $+1$，出栈看作 $-1$，容易想到，合法的方案必须满足所有时刻的<strong>前缀和$&gt;=0$</strong><br>更形象地，将其转移到坐标系上，每次入栈将横坐标 $+1$，每次出栈将纵坐标 $+1$，则所有的合法情况满足<strong>横坐标值$&gt;=$纵坐标值</strong>，所有的不合法情况满足<strong>纵坐标-横坐标$&gt;=1$</strong>，则所有不合法情况和函数$y=x+1$必有大于等于1个交点，考虑将其转化为如下形式：</p>\n<p><img src=\"https://z3.ax1x.com/2021/09/05/hWt7gx.png\" alt=\"\"></p>\n<p>图中实线为不合法操作路径，将其与$y=x+1$相交后的线段关于$y=x+1$对称，得到的最终点是$(n-1,n+1)$，由于所有不合法路径必然经过$y=x+1$，所以不合法的路径的情况转化为了从$0$到$(n-1,n+1)$的路径总数之和，即$\\binom{n-1}{2n}$或$\\binom{n+1}{2n}$。<br>合法路径总数即为全部路径$-$不合法路径，即$\\binom{n}{2n}$-$\\binom{n-1}{2n}$或$\\binom{n}{2n}$-$\\binom{n+1}{2n}$ </p>\n<p><img src=\"https://z3.ax1x.com/2021/09/05/hWtHv6.md.png\" alt=\"代码示例\"></p>\n","tags":["Knowledge","组合数学"]},{"title":"博客总目录","url":"/2022/07/01/%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%9B%AE%E5%BD%95/","content":"<h2 id=\"分类细则\"><a href=\"#分类细则\" class=\"headerlink\" title=\"分类细则\"></a>分类细则</h2><p>标为 $\\color{lightgreen}绿色$ 的是已经写完了的.</p>\n<p>标为 $\\color{red}红色$ 的是还没完工的.</p>\n<p>标为 $\\color{yellow}黄色$ 的是自认为比较有价值的。</p>\n<p>标为 $\\color{lightblue}蓝色$ 的是知识点的学习。</p>\n<h2 id=\"数学部分\"><a href=\"#数学部分\" class=\"headerlink\" title=\"数学部分\"></a>数学部分</h2><p><a href=\"https://bowenone580.github.io/2022/04/01/质数/\">$\\color{lightblue}质数$</a></p>\n<p><a href=\"https://bowenone580.github.io/2022/07/13/对线段树的研究/\">$\\color{lightblue} 对线段树的研究$</a></p>\n<p>[$\\color{lightblue}字符串$]</p>\n","tags":["Menu"]},{"title":"史上第二简洁的题面 题解","url":"/2022/05/26/%E5%8F%B2%E4%B8%8A%E7%AC%AC%E4%BA%8C%E7%AE%80%E6%B4%81%E7%9A%84%E9%A2%98%E9%9D%A2-%E9%A2%98%E8%A7%A3/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"742dcb3c9d7d560bf5ff0411ad6722efc2acada99d68ae96c757ce18807625e5\">1400ed4044b03ec1d838481659093c6fd54a042401aa8dea52020a28d27e867b6ffd2e98c0eb7985eeaba020f43eb286e2453f5bb1791c1f9e5c86ad93ce6c6e2772c7df6d524c650341dd4950cc4607a533a8ddaec8af8bc7655066892eb686d11738793d2a88d71547627275386614cf953af2ef6b819bae0b610f8e15a6fbbfbab70fadac3836bd68691baf285a96589374cb3ca92eb70e4a10d070aa5cc57e355a5f2dce37d8e370e5766f1cd72f1ef10f9b03ef9944da8587ea3532b867523d989212255014ab3939290ab292f2a16d48385f147dda8d39e23521623b68a7949a5653e2f0c2c2879684fa0079aef22e5b7709cc75c1670100018b017f3a4ecde98aa9604a9f45b5f1978c622bf1f0ad8f8288f246f70f0a59ecc0c5b8a6033b2a74d75a548bd800cad3f0dceb108f8afc0da411aa4a8f8d73dfdbda7780cbc6aed50544993a3b3d8b75f224a0ce64c174d8ebc3b557fa6a42215d358c9480e0cbc2f08c1e67651a3974abbd1ced4b943daa8fdf9e46d9af98a521916d8adb1018fcc3776862155a40a2a23b959cadb1843a858f6b1ec51f2f6218bc6a2fbcf3eb495defcafe9c9b410cd3984ccb347c4db36496dde3e73ae4aaaf029fba1717e386241438d0fa4e6096538e1e39c2c7d718dd5b149a9ea6471e845bc84292c0e2f5d929509c77a9ad9993df87937d726f01781b1956391925a34eb3f05082e26fd538b31ce7db4db3056e9c9a6261047d29793238dbeb8db251ff7745259677f2b8df5ac4d25e1f88794ac0c6d6bbc3065bc83311c8b2e683d71d43428f22562f60bcbc2afe0676615eaa6da103ce8f5cc33ca672cc33d2ebbb19aa250db27587fa4aaa0f338b482e38854904d03c221c622050b1d0ada643600dad6bd081a31b2a79cce27ff055eae5df594d34354f673b63cb04013ef59142c02e7f4be22c64e77306a819e5c1012ee452843bb664086b692fd8553db7bfe5806e42685cf238dac56c8c2cbb24da96b38be6c64bcad83ef228794cae8b41b9319542a7cfce6c72d410b9dc152f98a21e33995ef8073f3a0ddf674889890ccf9121007b08df4b090b5c96ec15eb64c50206d1b7256e18a10de8960ef594e03adfcfe8666ba8885bbef42040e84f1807d2af068b88605abcbf436040689e3dc644eb2af9f4fb8f60bab7434036f5fec035d5cfc0e1a65debf123cad22aa9ff6be3fe8a4e5839c87d3391de17be165b1d3c72eb264c8c668a4c390bfcb3ed324efa145ea4d0e196c1603f711cf0b7a8f72f8df009a38ba288be04d82caaa44674a2aa97c29a12c9ea9ea21394845c5c5debf57c34dd3543c4d363b02e64f304e658d68306a69b1676db8e254f0e4e843bce24417be1d2f3b230571096fa32a990f2ed0d3cbf37c98ea5e2ef2a9cf65de163e222ee5287bd4b291ffc6d5499a804b06ab64af4eb5734c6eecd5456b76c45fea95916acfd7d6f38ee6d3907826281fbb8de20e7f697e148c422abe4f67b9560c43d73f91970c66423aa35c5659b21bfeb68f7e0acfc4f1f9297a73a6594a93fe7c62d6c914fd052545b1bd33678edc1385e28c57ed85d39cdf8e91c8a62e2c12e763c5982c9c876f847b47ecfa9557960f63fe3c509bac3cbdecbd6eefc894ad358a2d12e7b83beacb876285738c715275e1b181036bfcddd3c7b356d8015ec4fdd69ea61599e9ced1de9e063610eb5598064557659d980bca73125095329273b7178f12ac1e05ae128e1cca01d3cb858d1b1</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">输入我在2022-05-25 18:40:50提交记录的id</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","tags":["Knowledge","数论","莫比乌斯反演"]},{"title":"对双向搜索的研究","url":"/2022/05/26/%E5%AF%B9%E5%8F%8C%E5%90%91%E6%90%9C%E7%B4%A2%E7%9A%84%E7%A0%94%E7%A9%B6/","content":"<h1 id=\"对双向搜索的研究\"><a href=\"#对双向搜索的研究\" class=\"headerlink\" title=\"对双向搜索的研究\"></a>对双向搜索的研究</h1><p>其实这个东西叫Meet in the middle。</p>\n<p>简而言之，就是从两边开始搜，最后搜到最终的结果就停止。</p>\n<p>具体流程如下：从起点和终点分别搜索，比对搜索的结果，取相交的部分即为连接起点和终点的答案。</p>\n<span id=\"more\"></span>\n<p>例题：<a href=\"https://www.luogu.com.cn/problem/P8187\">P8187 USACO22FEB Robot Instructions S</a> 。</p>\n<p>搜索可以到达的点的过程就是暴力，时间复杂度为$ O( 2^{n/2+1} ) $，主要的复杂度瓶颈在于合并搜索的结果。</p>\n<p>这里我用了一个比较复杂的排序，对排完序的数组寻找有没有符合条件的，时间复杂度卡的比较紧。对于那些想用map/unordered_map做的人，我在这里提醒一下：过不了！</p>\n<p>还有人用双指针写的，也可以通过。</p>\n<p>这类问题最难的地方就在于合并结果。</p>\n<h2 id=\"双向搜索可以用在哪里？\"><a href=\"#双向搜索可以用在哪里？\" class=\"headerlink\" title=\"双向搜索可以用在哪里？\"></a>双向搜索可以用在哪里？</h2><p>所有把暴力的指数减半，能够通过的题目都可以试试，只要合并结果不构成瓶颈就可以用。</p>\n<p>而且，双向搜索必须用在有起点，有终点，中间状态好表示，可合并的题目上。</p>\n<h2 id=\"常用的合并思想有哪些？\"><a href=\"#常用的合并思想有哪些？\" class=\"headerlink\" title=\"常用的合并思想有哪些？\"></a>常用的合并思想有哪些？</h2>","tags":["Knowledge","搜索","双向搜索"]},{"title":"奶牛电话网 题解","url":"/2022/10/23/%E5%A5%B6%E7%89%9B%E7%94%B5%E8%AF%9D%E7%BD%91-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"奶牛电话网-题解\"><a href=\"#奶牛电话网-题解\" class=\"headerlink\" title=\"奶牛电话网 题解\"></a>奶牛电话网 题解</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>选择一个点，可以影响到所有的儿子节点和它的父亲。</p>\n<p>考虑一个点选或不选的情况：</p>\n<ol>\n<li>儿子中有点没有被选择，自己选了就行。</li>\n<li>儿子中所有点都可以覆盖，则自己选择只会影响到父亲的抉择。</li>\n</ol>\n<span id=\"more\"></span>\n<p>设 $f[i][0/1/2]$ 表示点 $i$ 是不合法，还是合法但未被选择，还是被选择。</p>\n<p>如果当前点不合法，显然儿子都要合法，且未被选择，即从 $f[v][1]$ 转移。</p>\n<p>如果当前点合法且未被选择，那么儿子中一定要有合法且被选择的，即至少要有一个 $f[v][2]$。</p>\n<p>如何维护？</p>\n<p>首先，儿子要么是 $f[v][1]$ 或 $f[v][2]$，这样才能保证子树是合法的。</p>\n<p>先贪心的选，选择 $\\min(f[v][1],f[v][2])$。</p>\n<p>之后，钦定一个儿子，让它变成 $f[v][2]$，更新答案。</p>\n<p>如果当前点合法且被选择，那么儿子随便选即可。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,head[N],tot;</span><br><span class=\"line\"><span class=\"type\">int</span> f[N][<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v,tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tf[u][<span class=\"number\">2</span>] = <span class=\"number\">1</span>,f[u][<span class=\"number\">1</span>] = <span class=\"number\">0x3f3f3f</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t\tf[u][<span class=\"number\">0</span>]+=f[v][<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tf[u][<span class=\"number\">0</span>] = <span class=\"built_in\">min</span>(f[u][<span class=\"number\">0</span>],<span class=\"number\">0x3f3f3f3f</span>);</span><br><span class=\"line\">\t\tf[u][<span class=\"number\">2</span>]+=<span class=\"built_in\">min</span>(f[v][<span class=\"number\">0</span>],<span class=\"built_in\">min</span>(f[v][<span class=\"number\">1</span>],f[v][<span class=\"number\">2</span>]));</span><br><span class=\"line\">\t\ttmp+=<span class=\"built_in\">min</span>(f[v][<span class=\"number\">1</span>],f[v][<span class=\"number\">2</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tf[u][<span class=\"number\">1</span>] = <span class=\"built_in\">min</span>(f[u][<span class=\"number\">1</span>],tmp-<span class=\"built_in\">min</span>(f[v][<span class=\"number\">1</span>],f[v][<span class=\"number\">2</span>])+f[v][<span class=\"number\">2</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y),<span class=\"built_in\">add</span>(y,x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"built_in\">min</span>(f[<span class=\"number\">1</span>][<span class=\"number\">1</span>],f[<span class=\"number\">1</span>][<span class=\"number\">2</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","Editorial","动态规划","树形dp"]},{"title":"同余","url":"/2022/04/05/%E5%90%8C%E4%BD%99/","content":"<h1 id=\"同余\"><a href=\"#同余\" class=\"headerlink\" title=\"同余\"></a>同余</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>如果两个整数$a,b$除以$m$的余数相等，则称$a,b$模$m$同余，记作$a\\equiv b(\\mod m)$。</p>\n<p>一个在$[0,m-1]$里面的数$a$，它所属的集合$\\{a+km\\}$里面的所有数和$m$同余，则称这个集合为一个模$m$的同余类。</p>\n<p>$1$~$m$中和$m$互质的数代表的同余类共有$\\varphi(m)$个，它们构成$m$的简化剩余系。</p>\n<span id=\"more\"></span>\n<p>结论1：如果$a,b$都属于$m$的简化剩余系，则$a\\cdot b \\mod m$也属于$m$的简化剩余系。</p>\n<p>证明：显然，$a,b$都和$m$互质，则$a\\cdot b \\mod m$一定和$m$互质，必然属于$m$的简化剩余系。</p>\n<h2 id=\"运算\"><a href=\"#运算\" class=\"headerlink\" title=\"运算\"></a>运算</h2><p>模$n$意义下的运算</p>\n<ul>\n<li><p>加法</p>\n<ul>\n<li>$a+b = (a\\mod n+b\\mod n)\\mod n$</li>\n<li>$a\\equiv -b(\\mod n) \\iff a+b \\equiv 0(\\mod n)$（等式两边同时加上一个整数，模意义下等式仍然成立）</li>\n</ul>\n</li>\n<li><p>减法</p>\n<ul>\n<li>$a-b = (a\\mod n-b\\mod n) \\mod n$</li>\n<li>$a\\equiv b(\\mod n) \\iff a-b\\equiv 0(\\mod n)$（等式两边同时减去一个整数，模意义下等式仍然成立）</li>\n</ul>\n</li>\n<li><p>乘法</p>\n<ul>\n<li>$a\\cdot b = (a \\mod n\\cdot b\\mod n)\\mod n$</li>\n<li>$a\\equiv b(\\mod n) \\iff a\\cdot k\\equiv b\\cdot k(\\mod n)$（等式两边同时乘上一个整数，模意义下等式仍然成立）</li>\n</ul>\n</li>\n<li><p>除法</p>\n<ul>\n<li><p>这个后面再说</p>\n</li>\n<li><p>$a\\cdot k\\equiv b\\cdot k(\\mod n) \\iff a\\equiv b(\\mod \\frac{n}{gcd(n,k)})$</p>\n<ul>\n<li><p>证明：$a\\cdot k\\equiv b\\cdot k(\\mod n) \\iff (a-b)\\cdot k\\equiv 0(\\mod n)$。</p>\n<p>感性理解一下，$k$尽全力只能帮助$a-b$拿下$gcd(n,k)$，剩下的$\\frac{n}{gcd(n,k)}$是$a-b$必须要有的，所以$a-b\\equiv 0(\\mod \\frac{n}{gcd(n,k)})$。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>乘方</p>\n<ul>\n<li>$a\\equiv b \\iff a^k\\equiv b^k(\\mod n)$</li>\n<li>证明：设$a = k_1n+r,b = k_2n+r$，则$a^k = k_1\\cdot X+r^k,b^k = k_2\\cdot Y+r^k$，所以原式等价于$r^k\\equiv r^k$，显然成立。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"定理\"><a href=\"#定理\" class=\"headerlink\" title=\"定理\"></a>定理</h2><p><strong>费马小定理：若$p$是质数，则对于任意正整数$a$，有$a^p\\equiv a(\\mod p)$。</strong></p>\n<p><strong>欧拉定理：若正整数$a,n$互质，则$a^{\\varphi(n)}\\equiv 1(\\mod n)$。</strong></p>\n<p>证明：对于$n$的所有互质的数，我们将其从小到达排列为$a_1,a_2,\\cdots,a_{\\varphi(n)}$。</p>\n<p>之后，我们把所有这些数都乘上$a$，得到$aa_1,aa_2,\\cdots,aa_{\\varphi(n)}$，又因为$a,n$互质，所以得到的数都和$n$互质。</p>\n<p>我们再证明这些数组成的集合正好是$n$的简化剩余系：</p>\n<p>如果对于两个不同的$a_i,a_j$来说，$aa_i\\equiv aa_j(\\mod n)$，那么根据上面的运算性质，要么$a\\mid n$，要么$a_i\\equiv a_j(\\mod n)$，然而根据$a,n$互质，第一个不成立，根据我们假设的$a_i\\neq a_j$，第二个也不成立，所以这个集合正好构成$n$的简化剩余系。</p>\n<p>由此，$aa_1\\cdot aa_2\\cdots aa_{\\varphi(n)}\\equiv a_1\\cdot a_2 \\cdots a_{\\varphi(n)}(\\mod n)$，所以$a^{\\varphi(n)}\\equiv 1(\\mod n)$。</p>\n<p>当$n$为质数时，$a^{\\varphi(n)}\\equiv1(\\mod n) = a^{n-1}\\equiv 1(\\mod n) = a^n\\equiv a(\\mod n)$。</p>\n<p>由此，费马小定理成立。</p>\n<h2 id=\"欧拉定理的推论\"><a href=\"#欧拉定理的推论\" class=\"headerlink\" title=\"欧拉定理的推论\"></a>欧拉定理的推论</h2><ol>\n<li><p><strong>若$a,n$互质，则对于任意正整数$b$，有$a^b\\equiv a^{b\\mod \\varphi(n)}(\\mod n)$</strong>。</p>\n<p>证明：</p>\n<p>设$b=k\\cdot \\varphi(n)+r$，则$a^b =  a^{k\\cdot \\varphi(n)+r} = a^{\\varphi(n)^k}\\cdot a^r\\equiv 1^k\\cdot a^r\\equiv a^r$，所以原式仍旧成立。</p>\n</li>\n<li><p><strong>若$a,n$不互质，且对于正整数$b&lt;\\varphi(n)$，有$a^b\\equiv a^b(\\mod n)$</strong>。</p>\n<p>证明：</p>\n<p>显然成立。</p>\n</li>\n<li><p><strong>若$a,n$不互质，且对于正整数$b\\geq \\varphi(n)$，有$a^b\\equiv a^{b\\mod \\varphi(n)+\\varphi(n)}(\\mod n)$</strong>。</p>\n<p>证明：</p>\n<ol>\n<li><p>$a$为质数，且$a\\mid n$。</p>\n<p>设$n=n’a^r$，则$a,n’$一定互质，根据欧拉定理，可得$a^{\\varphi(n’)}\\equiv 1(\\mod n’)$。</p>\n<p>又因为$a^r,n’$互质，所以$\\varphi(n) =\\varphi(n’)\\cdot (a-1)\\cdot a^{r-1}$，即$\\varphi(n’)\\mid \\varphi(n)$。</p>\n<p>所以根据$a^{\\varphi(n’)}\\equiv 1(\\mod n’)$，可以得到$a^{\\varphi(n)}\\equiv 1(\\mod n’)$。</p>\n<p>变换形式，可得$a^{\\varphi(n)} = n’k+1$，即$a^{\\varphi(n)+r} = nk+a^r$。</p>\n<p>所以，$a^{\\varphi(n)+r}\\equiv a^r(\\mod n)$，即$a^{k\\cdot\\varphi(n)+r}\\equiv a^r(\\mod n)$。</p>\n<p>设$b = r+k\\cdot\\varphi(n)+t$，则$a^b = a^{r+k\\cdot\\varphi(n)+t} = a^{r+t}$。</p>\n<p>又因为$t = b-r-k\\cdot\\varphi(n) = (b-r)\\mod \\varphi(n)$，所以$a^b = a^{r+(b-r)\\mod \\varphi(n)}(\\mod n)$。</p>\n</li>\n<li><p>$a$为质数的幂。</p>\n<p>剩下的看不懂了，有兴趣的直接看<a href=\"https://blog.csdn.net/synapse7/article/details/19610361\">三个重要的同余式——威尔逊定理、费马小定理、欧拉定理 + 求幂大法的证明_synapse7的博客</a>。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>总之，这个式子可以降低幂次，使我们能用快速幂之类的东西简化计算。</p>\n<h2 id=\"扩展欧几里得\"><a href=\"#扩展欧几里得\" class=\"headerlink\" title=\"扩展欧几里得\"></a>扩展欧几里得</h2><p>对于任意整数$a,b$，存在一对整数$x,y$，满足$ax+by = gcd(a,b)$。</p>\n<p>在欧几里得算法的最后一步中，$b=0$，我们可以得到一组解：$a\\cdot1+0\\cdot0 = gcd(a,0)$。</p>\n<p>我们往回导一下，在$b&gt;0$时，$gcd(a,b) = gcd(b,a\\mod b)$，假设存在一对整数$x,y$满足$bx+(a\\mod b)y=gcd(b,a \\mod b)$，则$bx+(a-b\\cdot\\lfloor a/b\\rfloor)y=ay+ b(x-\\lfloor a/b\\rfloor y)$，我们只要令$x’=y,y’=x-\\lfloor a/b\\rfloor y$，就可以求出另一组解，由于当$b=0$时是有解的，所以我们归纳一下，可以得到任意时刻都有解。于是对于任意整数$a,b$，都存在一组整数$x,y$，满足$ax+by = gcd(a,b)$。</p>\n<p>当然，这里求出的仅是一组特解，并不能代表所有的解。</p>\n<p>更一般的，对于$ax+by = c$，方程有解当且仅当$gcd(a,b)\\mid c$，且通解可表示为$x=\\frac{c}{gcd(a,b)}x_0+\\frac{kb}{gcd(a,b)},y = \\frac{c}{gcd(a,b)}y_0-\\frac{ka}{gcd(a,b)}$。其中$x_0,y_0$为$ax+by = gcd(a,b)$的一组特解。</p>\n<p>证明：咕了。</p>\n<h2 id=\"乘法逆元\"><a href=\"#乘法逆元\" class=\"headerlink\" title=\"乘法逆元\"></a>乘法逆元</h2><p>我们回到之前对于运算的处理，我们对加减乘和乘方运算都有较好的处理方式，但是除法中很可能会有小数，这时候再模就不知道是什么东西了，为了将结果限制在整数范围内，我们需要一种特殊的处理方式：乘法逆元。</p>\n<p>若整数$b,m$互质，且$b\\mid a$，则存在一个整数$x$，使得$a/b\\equiv ax(\\mod m)$，称$x$为$b$的模$m$乘法逆元，记为$b^{-1}(\\mod m)$。</p>\n<p>因为$a/b\\equiv a\\cdot b^{-1}\\equiv a/b\\cdot b\\cdot b^{-1}(\\mod m)$，所以根据上面的运算规律，我们可以得到$b\\cdot b^{-1}\\equiv 1(\\mod m)$。</p>\n<p>那么，我们就是要找到$b^{-1}$取啥比较合适。</p>\n<h3 id=\"模质数\"><a href=\"#模质数\" class=\"headerlink\" title=\"模质数\"></a>模质数</h3><p>如果$m$是质数，根据费马小定理，$b^m\\equiv b(\\mod m) \\iff b^{m-1}\\equiv 1(\\mod m) \\iff b\\cdot b^{m-2}\\equiv 1(\\mod m)$，所以$b^{-1} = b^{m-2}$是$b$的乘法逆元。</p>\n<h3 id=\"线性求1-n中所有数的逆元\"><a href=\"#线性求1-n中所有数的逆元\" class=\"headerlink\" title=\"线性求1~n中所有数的逆元\"></a>线性求1~n中所有数的逆元</h3><p>还要说明一点，如果要求$1$~$n$中所有数模质数$p$的逆元，是可以线性求出的。</p>\n<p>具体来说，我们设$p=k\\cdot i+r$，其中$0\\leq r&lt;i$。</p>\n<p>于是，$k\\cdot i+r\\equiv 0(\\mod p)$。</p>\n<p>两边同乘$i^{-1}$和$r^{-1}$，得到$k\\cdot r^{-1}+i^{-1}\\equiv 0(\\mod p)$。</p>\n<p>移项，得$i^{-1}\\equiv -k\\cdot r^{-1}(\\mod p)$，也就是说，$i^{-1}\\equiv -\\lfloor p/i\\rfloor\\cdot(p\\mod i)^{-1}(\\mod p)$，我们用的都是之前已经求出的逆元，可以线性求出所有的逆元。</p>\n<h3 id=\"线性求任意n个数的逆元\"><a href=\"#线性求任意n个数的逆元\" class=\"headerlink\" title=\"线性求任意n个数的逆元\"></a>线性求任意n个数的逆元</h3><p>我们首先求出$n$个数的前缀积，记为$s_i$，之后求出$s_n$的逆元$sv_n$。</p>\n<p>$s_n=\\Pi_{i=1}^na_i$，于是$sv_n=\\Pi_{i=1}^na_i^{-1}$。</p>\n<p>我们从后往前，每次乘上$a_i$，于是得到$s’_i=\\Pi_{j=1}^ia_j^{-1}$，那么$a_i^{-1} = s’_i\\cdot s_{i-1}$。</p>\n<p>这样，我们就用$n+\\log m$的时间求出了任意$n$个数的逆元。</p>\n<h3 id=\"b-m互质\"><a href=\"#b-m互质\" class=\"headerlink\" title=\"b,m互质\"></a>b,m互质</h3><p>如果只保证$b,m$互质，我们需要求解同余方程$bx\\equiv 1(\\mod m)$。</p>\n<p>接下来，我们将讨论如何解决这个问题。</p>\n<h2 id=\"线性同余方程\"><a href=\"#线性同余方程\" class=\"headerlink\" title=\"线性同余方程\"></a>线性同余方程</h2><p>形如$ax\\equiv b(\\mod m)$的方程叫做线性同余方程，因为其未知数$x$的指数为1。</p>\n<p>我们将其变形，得$ax-b\\equiv 0(\\mod m)$，即$ax-b=-ym$。</p>\n<p>移项，得$ax+ym=b$，这个东西可以用扩展欧几里得解决。</p>\n<p>我们先求出$ax+ym = gcd(a,m)$的一组解$x,y$，之后乘$b/gcd(a,m)$，就可以求出这个方程的一个特解$x_0$。</p>\n<p>通解是所有模$m/gcd(a,m)$和$x_0$同余的数，形象一点的说，通解是$x_0\\frac{b}{gcd(a,m)}+\\frac{tm}{gcd(a,m)}$，这里的$t$取遍整个整数集合。</p>\n<h2 id=\"中国剩余定理\"><a href=\"#中国剩余定理\" class=\"headerlink\" title=\"中国剩余定理\"></a>中国剩余定理</h2><p>设$m_1,m_2,\\cdots,m_n$是$n$个两两互质的整数，$m=\\Pi_{i=1}^nm_i$，$M_i = m/m_i$，$t_i$是线性同余方程$M_it_i\\equiv 1(\\mod m_i)$的一个解，则对于任意$n$个整数$a_1,a_2\\cdots a_n$，方程组</p>\n<p>$\\left\\{\\begin{aligned}x\\equiv a_1(\\mod m_1)\\\\x\\equiv a_2(\\mod m_2)\\\\\\cdots\\\\x\\equiv a_n(\\mod m_n)\\end{aligned}\\right.$</p>\n<p>有整数解，解为$x=\\sum_{i=1}^na_iM_it_i$。</p>\n<p>证明：</p>\n<p>对于$M_i\\neq m/m_i$，有$m_i\\mid M_i$，所以$a_iM_it_i\\equiv 0(\\mod m_i)$。</p>\n<p>对于$M_i=m/m_i$，有$M_it_i\\equiv 1(\\mod m_i)$，所以$a_iM_it_i\\equiv a_i(\\mod m_i)$。</p>\n<p>所以这是原方程组的一个特解。</p>\n<p>通解就是$x+km$。</p>\n<p>证明：又咕了。</p>\n<h2 id=\"扩展中国剩余定理\"><a href=\"#扩展中国剩余定理\" class=\"headerlink\" title=\"扩展中国剩余定理\"></a>扩展中国剩余定理</h2><p>虽然刚才的解确实非常妙，但是只有在$m_1,m_2\\cdots,m_n$中所有数两两互质才能使用，这在题目中是非常罕见的限制条件，更多的是随便取一些数，让你解这个方程组，这时候我们应该怎么做呢？</p>\n<p>我们考虑用数学归纳法解决。</p>\n<p>显然，只有$x\\equiv a_1(\\mod m_1)$时，我们可以通过线性同余方程求出一个解，或判断其无解。</p>\n<p>假设现在已经求出了前$k-1$个方程的解$x$，设$m = lcm(m_1,m_2\\cdots m_{k-1})$，则$x+im$是前$k-1$个方程的一个通解，现在要求出一个整数$t$，满足$x+tm\\equiv a_k(\\mod m_k)$，即$tm\\equiv a_k-x(\\mod m_k)$，这可以通过找出这个线性同余方程的一个解得到，或判断其无解。</p>\n<h2 id=\"高次同余方程\"><a href=\"#高次同余方程\" class=\"headerlink\" title=\"高次同余方程\"></a>高次同余方程</h2><h3 id=\"BSGS算法\"><a href=\"#BSGS算法\" class=\"headerlink\" title=\"BSGS算法\"></a>BSGS算法</h3><p>在$a,p$互质时，对于形如$a^x\\equiv b(\\mod p)$之类的问题，我们可以使用BSGS求解。</p>\n<p>这个$x$可以看成$it-j$，其中$t = \\lceil \\sqrt{p}\\rceil$，这里的$i\\in [1,t],j\\in[1,t]$，这样可以取到$[0,p-1]$中的任何一个值。</p>\n<p>为什么不需要取更大的值呢？因为$a,p$互质，所以我们可以使用欧拉定理，$a^{x+\\varphi(p)}\\equiv a^x\\cdot a^{\\varphi(p)}\\equiv a^x\\cdot 1\\equiv a^x(\\mod p)$。</p>\n<p>所以，$x$只要在$[0,p-1]$的范围内就行了。</p>\n<p>对这个式子进行变形，$a^{it-j}\\equiv b \\iff a^{it}\\equiv b\\cdot a^j(\\mod p)$。</p>\n<p>我们从小到大枚举$j$，算出$b\\cdot a^j$的所有取值，当取值相等时，我们用较大的$j$更新，这样可以保证我们得到的是最小非负整数解。</p>\n<p>之后，再从小到大枚举$i$，直接求出$a^{it}$的值，查找是否有对应的$j$，使同余后结果相同，有就直接输出答案。</p>\n<p>这个答案为什么最小？我们考虑极端一点的情况，$it-1&lt;(i+1)t-t$，所以就没啥问题了。</p>\n<p>查找相等的取值好像可以用hash做到$O(1)$，但是我只会用$O(\\log n)$的map。也许以后会再更一下。</p>\n<p>这个方程也有可能无解，就是在枚举完所有的可能之后都没有找出解来。</p>\n<p>这个算法的复杂度优化主要在用map将所有$b\\cdot a^j$的值都存起来，这样我们对于每个$i$，就只用花费$O(\\log n)$的时间进行查找了，于是总复杂度就是$O(\\sqrt{p}\\cdot \\log p)$。这种分割$x$的思想是非常具有启发性的。</p>\n<h3 id=\"扩展BSGS\"><a href=\"#扩展BSGS\" class=\"headerlink\" title=\"扩展BSGS\"></a>扩展BSGS</h3><p>如果只有$a^x\\equiv b(\\mod p)$，不保证$b,p$互质，该如何做呢？</p>\n<p>我们取$d = gcd(a,p)$，将整个方程同时除以$d$，得到$\\frac{a}{d}\\cdot a^{x-1}\\equiv \\frac{b}{d}(\\mod \\frac{p}{d})$。</p>\n<p>为什么可以这样除呢？我们假设原来的方程为$a^x+kp=b$，则整体除$d$，得$\\frac{a}{d}\\cdot a^{x-1}+k\\cdot\\frac{p}{d}=\\frac{b}{d}$，这就相当于把模数也一起除$d$。</p>\n<p>现在，$\\frac{a}{d}$和$\\frac{p}{d}$显然是互质的，于是我们可以用乘法逆元把$\\frac{a}{d}$除过去，得到$a^{x-1}\\equiv \\frac{b}{d}\\cdot (\\frac{a}{d})^{-1}(\\mod \\frac{p}{d})$。</p>\n<p>我们一直这样除下去，设$D = \\Pi_{i=1}^kd_i$，直到左边的$a^{x-k}$和$\\frac{p}{D}$互质，这样我们就可以应用上面的BSGS来解决这个问题了。</p>\n<p>BSGS的时间复杂度为$O(\\sqrt{p}\\cdot\\log p)$，每次求gcd的时间复杂度为$O(\\log p)$，总的复杂度大概就是$O(\\sqrt{p}\\cdot \\log p)$。</p>\n<h2 id=\"阶\"><a href=\"#阶\" class=\"headerlink\" title=\"阶\"></a>阶</h2><p>对于两个互质的数$a,m$而言，$a^x\\equiv 1(\\mod m)$，这个$n$取最小时称作$a$模$m$的阶，记作$\\delta_m(a)$。</p>\n<p>由欧拉定理可得，$a^{\\varphi(m)}\\equiv 1(\\mod m)$，所以在$a,m$互质时，$n$一定存在。</p>\n","tags":["Knowledge","数学"]},{"title":"对拓扑排序的研究","url":"/2022/05/26/%E5%AF%B9%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A0%94%E7%A9%B6/","content":"<h1 id=\"对拓扑排序的研究\"><a href=\"#对拓扑排序的研究\" class=\"headerlink\" title=\"对拓扑排序的研究\"></a>对拓扑排序的研究</h1><h2 id=\"拓扑排序是什么？\"><a href=\"#拓扑排序是什么？\" class=\"headerlink\" title=\"拓扑排序是什么？\"></a>拓扑排序是什么？</h2><p>简而言之，每次选择一个入度为 $ 0 $ 的点，遍历其所有出边，更新出边到达的点的入度，这样一直进行下去，直到所有点的入度都变成 $ 0 $ 。</p>\n<span id=\"more\"></span>\n<h2 id=\"任何图都能拓扑排序吗？\"><a href=\"#任何图都能拓扑排序吗？\" class=\"headerlink\" title=\"任何图都能拓扑排序吗？\"></a>任何图都能拓扑排序吗？</h2><p>并不是。拓扑排序只能用在DAG（有向无环图）中，如果有环，那么必然有一些点的入度永远无法变成 $ 0 $ ，所以无法进行拓扑排序。</p>\n<h2 id=\"拓扑排序的时间复杂度是多少？\"><a href=\"#拓扑排序的时间复杂度是多少？\" class=\"headerlink\" title=\"拓扑排序的时间复杂度是多少？\"></a>拓扑排序的时间复杂度是多少？</h2><p>先要取出所有入度为 $ 0 $ 的点，花费 $ O(n) $ 的时间，之后要遍历所有边，花费 $ O(m) $ 的时间，所以总时间复杂度为 $ O(n+m) $ 。</p>\n<h2 id=\"拓扑排序能用来干什么？\"><a href=\"#拓扑排序能用来干什么？\" class=\"headerlink\" title=\"拓扑排序能用来干什么？\"></a>拓扑排序能用来干什么？</h2><h3 id=\"1-判断图中是否有环\"><a href=\"#1-判断图中是否有环\" class=\"headerlink\" title=\"1. 判断图中是否有环\"></a>1. 判断图中是否有环</h3><p>上面提到对存在环的图进行拓扑排序无法遍历到所有点，所以可以通过是否能够遍历到所有点来判断图中是否有环。</p>\n<h3 id=\"2-找出图中的最长路\"><a href=\"#2-找出图中的最长路\" class=\"headerlink\" title=\"2. 找出图中的最长路\"></a>2. 找出图中的最长路</h3><p>例题： <a href=\"https://www.luogu.com.cn/problem/P1807\">P1807 最长路</a> 。</p>\n<p>每次从入度为 $ 0 $ 的点更新出边所到的点的最长路，最后取其中的最大值即可。</p>\n<h3 id=\"3-约束条件\"><a href=\"#3-约束条件\" class=\"headerlink\" title=\"3. 约束条件\"></a>3. 约束条件</h3><p>例题： <a href=\"https://www.luogu.com.cn/problem/P1983\">P1983 车站分级</a> 。</p>\n<p>要约束不同车站间的层级大小关系，这个大小关系显然是个 DAG ，我们将所有入度为 $ 0 $ 的点的层级设为 $ 1 $ ，每次连边代表所到的点的层级至少比这个点大 $ 1 $ ，由于我们使用了拓扑序，可以保证当前点的层级是满足所有条件的最小的一个，最后取所有点的层级中最大的一个即可。</p>\n<p>练习： <a href=\"https://www.luogu.com.cn/problem/P1347\">P1347 排序</a> 。</p>\n<p>综合判环和约束的题： <a href=\"https://www.luogu.com.cn/problem/P3243\">P3243 菜肴制作</a> 。</p>\n","tags":["Knowledge","图论","拓扑排序"]},{"title":"字符串","url":"/2022/10/26/%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这个板块很久都没有搞清楚，以至于压根不想做任何含有字符串的题，现在想来，还是要系统的学一遍为好。</p>\n<h2 id=\"单模式串匹配\"><a href=\"#单模式串匹配\" class=\"headerlink\" title=\"单模式串匹配\"></a>单模式串匹配</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>这个东西，一般使用 KMP 算法解决，KMP 的思想很好理解，就是每次找到最大的能匹配的位置。</p>\n<p>需要注意的有两点：</p>\n<ol>\n<li>模式串自己匹配的时候，KMP 数组的定义是最长的从开头开始的能和它匹配的串的长度，但是这里显然不能自己匹配自己，所以这个串要求非自身，这也是模式串匹配的下标都从 $2$ 开始，且 $f[1] = 0$ 的原因。</li>\n<li>时间复杂度的证明：每次下标移动一位，$j$ 最多增加 $1$，也就意味着 $j$ 能减少的次数最多增加 $1$。这样下来，即使每一位 $j$ 都能增加且后面会减少，时间复杂度也只有 $O(N+M)$。</li>\n</ol>\n<h3 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h3><h4 id=\"最短循环节\"><a href=\"#最短循环节\" class=\"headerlink\" title=\"最短循环节\"></a>最短循环节</h4><p><a href=\"https://www.luogu.com.cn/problem/P4391\">P4391 BOI2009 Radio Transmission</a></p>\n<p>结论：循环节的长度为 $n-nxt[n]$。</p>\n<p>证明看题解就行了，讲的比较清楚，这个结论其实挺常用的。</p>\n<h4 id=\"num-数组\"><a href=\"#num-数组\" class=\"headerlink\" title=\"num 数组\"></a>num 数组</h4><p><a href=\"https://www.luogu.com.cn/problem/P2375\">P2375 NOI2014 动物园</a></p>\n<p>重点在于及时剔除不可能的答案。</p>\n<p>对于一个前缀，它的所有满足前后缀相等的子串的长度分别为 $nxt[i],nxt[nxt[i]],\\cdots$。这个感性理解一下就行了。</p>\n<p>考虑我们求出了 $nxt$ 数组，现在要求 $num$ 数组。如果暴力求解，就是每次跳 $nxt$，枚举答案。</p>\n<p>但是，我们完全不需要让指针 $j$ 大于 $i/2$，因为如果当前能匹配的长度比串的一半大，那么后一位还能用到这次的 $nxt$ 的情况只能是后一位能够匹配，这时 $j+1&gt;(i+1)/2$，显然不合法，所以不需要判断。</p>\n<h4 id=\"所有前缀出现次数\"><a href=\"#所有前缀出现次数\" class=\"headerlink\" title=\"所有前缀出现次数\"></a>所有前缀出现次数</h4><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3336\">Count the string</a></p>\n<p>希望 hdu 能再次开放使用。</p>\n<p>题意：求一个串的每一个前缀出现次数之和。</p>\n<p>这道题涉及到 nxt 数组的理解。众所周知，一个前缀的所有前后缀相等的子串构成的集合一定是 $nxt[i],nxt[nxt[i]]\\cdots$。而且这些东西之间是有内在关系的，你可以把它们看成一棵树，即每个 $i$ 都唯一的对应着一个 $nxt[i]$，而在其中某一个节点增加出现次数，相当于它到根节点的路径上的出现次数都增加了。</p>\n<p>既然是树，我们可以先统计每个节点出现的次数，并且仅将自己的贡献向父亲贡献，这样可以做到不重不漏的统计贡献，正确性看上去就挺对的，只不过这个写法需要记清楚，很容易考到。</p>\n<h2 id=\"Manacher-算法\"><a href=\"#Manacher-算法\" class=\"headerlink\" title=\"Manacher 算法\"></a>Manacher 算法</h2><h3 id=\"基本概念-1\"><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>思想是简单的。</p>\n<p>先对输入的串进行一些改造：在开头添加 ~，以避免越界匹配；在每两个字符中间添加一个 #，让所有回文串的长度变为奇数。</p>\n<p>考虑维护以 $i$ 为中心的最长回文串长度，记为 $p[i]$，记下当前右端点最右的回文串的中心 $mid $ 和右端点 $r$。</p>\n<p>在计算点 $i$ 的最长回文串长度时，根据 $i$ 和 $r$ 的关系可以分为两种情况。</p>\n<ol>\n<li><p>$i\\leq r$。</p>\n<p>这时，我们找到 $i$ 关于 $mid$ 的对称点 $l = mid\\cdot 2-i$，显然我们已经知道 $p[l]$ 的值。又因为以 $mid$ 为中心的串是回文的，所以以 $l$ 为中心的回文串对称过去，直到 $r$ 之前就都是回文的。后面是否回文直接暴力扩展。</p>\n</li>\n<li><p>$i&gt;r$。</p>\n<p>直接暴力扩展，此时，每扩展一次，$r$ 就会增加 $1$，则 $r$ 增加的总次数不超过 $n$ 次。</p>\n</li>\n</ol>\n<p>于是，我们就能在 $O(n)$ 的时间内求出最长回文串的长度了。</p>\n<p>测板子链接：<a href=\"https://www.luogu.com.cn/problem/P3805\">P3805 manacher 算法</a></p>\n<h3 id=\"变式1\"><a href=\"#变式1\" class=\"headerlink\" title=\"变式1\"></a>变式1</h3><p><a href=\"https://www.luogu.com.cn/problem/P3501\">P3501 POI2010 ANT-Antisymmetry</a></p>\n<p>将原串取反，再反过来，等价于前一段和后一段互补，即前一段取反后是回文串，且串长要为偶数。</p>\n<p>转化为求回文串个数。显然只用知道每个位置的最长回文串即可。</p>\n<p>可见，字符串题的重点不在于算法，而在于推性质。</p>\n<h3 id=\"变式2\"><a href=\"#变式2\" class=\"headerlink\" title=\"变式2\"></a>变式2</h3><p><a href=\"https://www.luogu.com.cn/problem/P4555\">P4555 国家集训队 最长双回文串</a></p>\n<p>前方高妙！</p>\n<p>不难想到一种解法：</p>\n<p>先把 $p$ 数组求出来，设 $f[i] = \\lfloor \\frac{p[i]}{2} \\rfloor$，于是如果 $i,j$ 满足是同一个双回文串的中点，那么有 $i+f[i]\\geq j-f[j]-1$。这个东西的两边分别只和 $i,j$ 有关，于是可以计算出所有 $j$ 的值，对于一个固定的点 $i$，就变成了线段树上最值问题。但是这样做稍显复杂。</p>\n<p>不妨转换一下思路，把枚举中点变成枚举断点，显然，如果我们知道每个断点向左右延伸的最大长度，就能求出双回文串的最大长度。</p>\n<p>记点 $i$ 向左右延伸的最大长度为 $L[i],R[i]$。</p>\n<p>首先，根据我们求出的 $p$ 数组，可以得到一些点的 $L$ 和 $R$。这个很好更新。</p>\n<p>然后，这些 $L,R$ 就可以唯一确定所有点的 $L,R$！为什么？因为我们求出了每个点最长的回文串，就相当于求出了所有回文串，只不过需要递推一下。</p>\n<p>$L[i] = L[i-2]-2$</p>\n<p>$R[i] = R[i+2]-2$</p>\n<p>于是，就能在 $O(n)$ 的时间内解决此题了。</p>\n<h3 id=\"变式3\"><a href=\"#变式3\" class=\"headerlink\" title=\"变式3\"></a>变式3</h3><p><a href=\"https://www.luogu.com.cn/problem/P6216\">P6216 回文匹配</a></p>\n<p>KMP 和 Manacher 算法的巧妙结合。</p>\n<p>先看一眼题，发现要求长度为奇数的回文区间，于是我们只用在最前面加一个占位符即可，之后直接跑 manacher。</p>\n<p>又要求 $s2$ 在一个区间内的出现次数。不难发现，我们只要统计 $s2$ 在 $s1$ 中出现的位置，做一个前缀和即可 $O(1)$ 求出。而统计 $s2$ 在 $s1$ 中出现的位置就是 KMP 的经典应用。</p>\n<p>但是，这里需要求出所有回文串中出现的次数，不是一个 $p$ 数组就能解决的。</p>\n<p>观察，可以发现，当回文串的中心在同一位置时，我们慢慢从最长的回文串缩小，则每次长度 $-2$，而求前缀和的左端点右移一位，右端点左移一位，如果把这些东西合到一起，不就是前缀和的前缀和吗！</p>\n<p>于是，对之前求出的前缀和再做一次，即可快速求出最长回文串内的所有子串对答案的贡献。</p>\n<h2 id=\"扩展-KMP\"><a href=\"#扩展-KMP\" class=\"headerlink\" title=\"扩展 KMP\"></a>扩展 KMP</h2><p>这个算法就不是那么好理解了。</p>\n<p>先弄清楚这个算法是干什么的：可以在 $O(n)$ 的时间内求出串 $s1$ 的每一个后缀和 $s2$ 的 LCP（最长公共前缀）长度。</p>\n<p>假设我们现在已经求出了一个 $z$ 数组，代表 $s2$ 的每一个后缀和 $s2$ 的 LCP 长度，答案数组记为 $ext[i]$，代表 $s1$ 以 $i$ 开始的后缀和 $s2$ 的 LCP 长度。</p>\n<p>维护两个值 $l,r$，代表能匹配的 LCP 右端点最大时的右端点和左端点。</p>\n<p>和 Manacher 算法类似，我们分为两种情况：</p>\n<ol>\n<li><p>$i\\leq r$。</p>\n<p>这时，我们知道 $l$~$l+m-1$ 和 $s2$ 中从 $1$ 开始的部分是相等的。所以 $i$~$m-1$ 和 $s2$ 必然也有一段相等的区间。</p>\n<p>而且，我们已经求出了 $z$ 数组，所以可以直接得出 $1$~$z[i-l+1]$ 一定是 $i$ 的 LCP。</p>\n</li>\n<li><p>$i&gt;r$。</p>\n<p>暴力扩展即可，每次扩展的长度只增不减，所以时间复杂度为 $O(n)$。</p>\n</li>\n</ol>\n<p>为什么叫它扩展 KMP 呢？因为求 $z$ 数组的过程和 $ext$ 的过程完全一样！我们只用拿 $s2$ 去匹配一遍就行了。</p>\n<p>推荐博客：<a href=\"https://www.luogu.com.cn/blog/nitubenben/solution-p5410\">题解 P5410 扩展 KMP（Z 函数） - 泥土笨笨 的博客</a></p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>为啥变成练习了呢？因为这两道题都有更简单的解法，用 exKMP 做就当练一下熟练度了。</p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF432D\">Prefixes and Suffixes</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/UVA11475\">Extend to Palindrome</a></p>\n<h2 id=\"后缀数组\"><a href=\"#后缀数组\" class=\"headerlink\" title=\"后缀数组\"></a>后缀数组</h2><p>简称 SA，是学习 SAM 的前置知识。</p>\n<p>需要花费一定时间想通概念，之后就好理解了。</p>\n<p>后缀数组，指 $SA$ 数组，一般存储第 $i$ 小的后缀的位置</p>\n","tags":["Knowledge","字符串"]},{"title":"对杜教筛的研究","url":"/2022/06/20/%E5%AF%B9%E6%9D%9C%E6%95%99%E7%AD%9B%E7%9A%84%E7%A0%94%E7%A9%B6/","content":"<h1 id=\"对杜教筛的研究\"><a href=\"#对杜教筛的研究\" class=\"headerlink\" title=\"对杜教筛的研究\"></a>对杜教筛的研究</h1><h2 id=\"更新记录\"><a href=\"#更新记录\" class=\"headerlink\" title=\"更新记录\"></a>更新记录</h2><p>2022.6.20 修缮了部分文本，加深认识。</p>\n<h2 id=\"狄利克雷卷积\"><a href=\"#狄利克雷卷积\" class=\"headerlink\" title=\"狄利克雷卷积\"></a>狄利克雷卷积</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>$(f*g)(n) = \\sum_{d|n}f(d)g(\\frac{n}{d})$</p>\n<p>这里的 $f$ 和 $g$ 并没有特殊限制，只要求是数论函数就够了，其中 $*$ 代表卷积，以和乘法区别开。</p>\n<span id=\"more\"></span>\n<p>（它和莫比乌斯反演的形式很相似，<del>因为莫比乌斯反演本质就是狄利克雷卷积</del>）</p>\n<h3 id=\"积性函数\"><a href=\"#积性函数\" class=\"headerlink\" title=\"积性函数\"></a>积性函数</h3><p>对于函数 $f(x)$，如果满足对于任意<strong>互质的数</strong> $a$、$b$，都有 $f(ab) = f(a)\\cdot f(b)$，那么就称 $f(x)$ 为积性函数。</p>\n<p>对于函数 $f(x)$，如果对于<strong>任意两个数</strong> $a$、$b$，都有 $f(ab) = f(a) \\cdot f(b)$，那么就称 $f(x)$ 为完全积性函数。</p>\n<p><strong>1和任何数都互质</strong>。</p>\n<h3 id=\"常见的积性函数\"><a href=\"#常见的积性函数\" class=\"headerlink\" title=\"常见的积性函数\"></a>常见的积性函数</h3><p>$\\mu$、$\\varphi$、$d$、$\\sigma$</p>\n<p>这里的 $\\mu$ 是莫比乌斯函数，$\\varphi$ 是欧拉函数，它们定义应该都耳熟能详了。</p>\n<p>这里的 $d(x) = \\sum_{i|x}1$，即数 $x$ 的约数个数。</p>\n<p>这里的 $\\sigma(x) = \\sum_{i|x}i$，即数 $x$ 的约数和。</p>\n<p>当 $x = 1$ 时，这四个函数的值都是 $1$。</p>\n<p><strong>注：以下内容和之后的东西相关，虽然看上去很显然，但是它们也是杜教筛时间复杂度的基础之一。</strong></p>\n<p>我们思考一下它们的前缀和的预处理速度：</p>\n<p>$\\mu$ 和 $\\varphi$ 都可以被线性筛 $O(n)$ 筛出，求前缀和后总时间复杂度为 $O(n)$。</p>\n<p>$d$ 可以用整除分块 $O(\\sqrt n)$ 筛出其前缀和。（只能筛前缀和）</p>\n<p>$\\sigma$ 可以用整除分块 $O(\\sqrt n)$ 筛出前缀和。（只能筛前缀和）</p>\n<p>可以做以下题目加深了解：</p>\n<p> <a href=\"https://www.luogu.com.cn/problem/P2424\">P2424 约数和</a> </p>\n<p> <a href=\"https://www.luogu.com.cn/problem/P3935\">P3935 Calculating</a> </p>\n<h3 id=\"常见的完全积性函数\"><a href=\"#常见的完全积性函数\" class=\"headerlink\" title=\"常见的完全积性函数\"></a>常见的完全积性函数</h3><p>$\\epsilon$、$I$、$id$</p>\n<p>这里的 $\\epsilon(x) = [x = 1]$，$I(x) = 1$，$id(x) = x$。</p>\n<p><strong>像上面一样，思考一下筛出前缀和的速度。</strong></p>\n<p>$\\epsilon(x)$ 的前缀和是 $1$。</p>\n<p>$I(x)$ 的前缀和是 $x$。</p>\n<p>$id(x)$ 的前缀和是 $1+2+\\cdots +x = \\frac{x\\cdot (1+x)}{2}$。</p>\n<p>它们的前缀和都可以 $O(1)$ 求解。</p>\n<h3 id=\"常见的式子\"><a href=\"#常见的式子\" class=\"headerlink\" title=\"常见的式子\"></a>常见的式子</h3><h4 id=\"式子1\"><a href=\"#式子1\" class=\"headerlink\" title=\"式子1\"></a>式子1</h4><p>$\\mu*I = \\epsilon$</p>\n<p>这个东西在我写的莫比乌斯反演的博客里以另一种形式出现，当时已经证过一遍，如果会证的可以跳到式子2。</p>\n<h5 id=\"证明：\"><a href=\"#证明：\" class=\"headerlink\" title=\"证明：\"></a>证明：</h5><p>上面的式子可化为 $[x = 1] = \\sum_{d|x}\\mu(d)I(\\frac{x}{d})$。</p>\n<p>根据 $I$ 函数的定义，去掉它：</p>\n<p>$[x = 1] = \\sum_{d|x}\\mu(d)$</p>\n<p>当 $x = 1$ 时，右边只有 $d = 1$，根据 $\\mu$ 函数的定义，右边为 $1$。</p>\n<p>当 $x\\neq 1$ 时，考虑 $x$ 的质因数分解：</p>\n<p>$x = p_1^{c_1}\\cdot p_2^{c_2}\\cdots p_k^{c_k}$</p>\n<p>设 $x’ = p_1\\cdot p_2\\cdots p_k$。</p>\n<p>所有包含指数大于等于 $2$ 的质因数的 $\\mu$ 都是 $0$，所以可以把这些数舍去：</p>\n<p>$\\sum_{d|x}\\mu(d)\\iff \\sum_{d|x’}\\mu(d)$</p>\n<p>枚举 $d$ 包含的质因子个数，假设有 $q$ 个，就相当与从 $k$ 个质因子里面选出 $q$ 个的方案数，即为 $C_{k}^q$，于是可化为：</p>\n<p>$\\sum_{q=0}^{k}C_k^q(-1)^q$</p>\n<p>再看看二项式定理：</p>\n<p>$(a+b)^k = \\sum_{i=0}^kC_k^ia^ib^{k-i}$</p>\n<p>我们根据它把上面的式子补全：</p>\n<p>$\\sum_{q=0}^kC_k^q(-1)^q1^{k-q} = ((-1)+1)^k = 0$</p>\n<p>得证。</p>\n<p>这个式子还有一个更广为人知的形式：</p>\n<p>$[\\gcd(i,j) = 1] = \\sum_{d|\\gcd(i,j)}\\mu(d)$</p>\n<h4 id=\"式子2\"><a href=\"#式子2\" class=\"headerlink\" title=\"式子2\"></a>式子2</h4><p>$\\varphi*I = id$</p>\n<h5 id=\"证明：-1\"><a href=\"#证明：-1\" class=\"headerlink\" title=\"证明：\"></a>证明：</h5><p>先把式子化开：</p>\n<p>$\\sum_{d|x}\\varphi(d)I(\\frac{x}{d}) = x$</p>\n<p>$\\sum_{d|x}\\varphi(d) = x$</p>\n<p>将 $x$ 分解质因数：</p>\n<p>$x = p_1^{c_1}\\cdot p_2^{c_2}\\cdots p_k^{c_k}$</p>\n<p>由于 $\\varphi$ 是积性函数，所以可以将式子化为下面的形式：</p>\n<p>$\\sum_{i=0}^{c_1}\\varphi(p_1^{i})\\sum_{j=0}^{c_2}\\varphi(p_2^j)\\cdots \\sum_{q=0}^{c_k}\\varphi(p_k^q) = x$</p>\n<p>于是，设 $x’ = p^{c}$，要证的东西变成了下面的这个：</p>\n<p>$\\sum_{i=0}^{c}\\varphi(p^i) = x’$</p>\n<p>发现，它们都只有一个质因数 $p$，所以直接套欧拉函数定义式求值：</p>\n<p>$1+p\\cdot \\frac{p-1}{p}+p^2\\cdot \\frac{p-1}{p}+\\cdots +p^{c}\\cdot \\frac{p-1}{p}$</p>\n<p>化简：</p>\n<p>$1+(p-1)\\cdot (1+p+p^2+p^{c-1})$</p>\n<p>等比数列求和：</p>\n<p>$1+(p-1)\\cdot \\frac{p^{c}-1}{p-1} = p^c$</p>\n<p>得证。</p>\n<p>这个式子比较常用的是上面打开之后的形式，经常在中间的转化中出现。</p>\n<h4 id=\"式子3\"><a href=\"#式子3\" class=\"headerlink\" title=\"式子3\"></a>式子3</h4><p>$\\mu*id = \\varphi$</p>\n<h5 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h5><p>纯数学公式证法之后再推，这里先说用卷积的证法：</p>\n<p>$\\mu<em>id</em>I = \\varphi*I$</p>\n<p>运用上面的公式1和公式2：</p>\n<p>$\\epsilon*id = id$</p>\n<p>好像只要 $id(1)$ 有逆元，就可以同时除以 $id$。</p>\n<p>所以式子化为：</p>\n<p>$\\epsilon = [x = 1]$</p>\n<p>得证。</p>\n<p>这个式子主要是让 $\\mu$ 化为 $\\varphi$，常在用 $\\mu$ 推不出来的时候使用。</p>\n<h2 id=\"莫比乌斯反演\"><a href=\"#莫比乌斯反演\" class=\"headerlink\" title=\"莫比乌斯反演\"></a>莫比乌斯反演</h2><p>设 $f(x) = \\sum_{d|x}g(d)$</p>\n<p>则 $g(x) = \\sum_{d|x}\\mu(\\frac{x}{d})f(d)$</p>\n<h3 id=\"证明：-2\"><a href=\"#证明：-2\" class=\"headerlink\" title=\"证明：\"></a>证明：</h3><p>下面的式子可以看为 $\\mu*f = g$。</p>\n<p>于是，根据 $\\mu<em>I = \\epsilon$，可以得到 $\\epsilon</em>f = g*I$。</p>\n<p>而上面的式子等价于 $g*I = f$。</p>\n<p>所以 $\\epsilon*f = f$。</p>\n<p>得证。</p>\n<h2 id=\"杜教筛\"><a href=\"#杜教筛\" class=\"headerlink\" title=\"杜教筛\"></a>杜教筛</h2><p>假设现在要筛一个<strong>积性函数</strong> $f$ 的前缀和。</p>\n<p>（其实杜教筛不是只能筛积性函数，你只要能在线性以内的时间把一个函数的前缀和预处理出来，一般都是可以筛的，至于积性函数是因为一般的积性函数都可以拿线性筛筛出来）</p>\n<p>即求 $S(n) = \\sum_{i=1}^nf(i)$。</p>\n<p>先找一个函数 $g$，把它们卷起来：</p>\n<p>$\\sum_{i=1}^{n}(f*g)(n) = \\sum_{i=1}^n\\sum_{d|i}f(\\frac{i}{d})g(d)$</p>\n<p>枚举 $d$：</p>\n<p>$\\sum_{d=1}^ng(d)\\sum_{i=1}^{\\frac{n}{d}}f(i)$</p>\n<p>后面的东西就是 $S$：</p>\n<p>$\\sum_{d=1}^ng(d)S(\\frac{n}{d})$</p>\n<p>于是，得到了：</p>\n<p>$\\sum_{i=1}^n(f*g)(n) = \\sum_{d=1}^ng(d)S(\\frac{n}{d})$</p>\n<p>再想想我们要求的是什么：</p>\n<p>$g(1)S(n) = \\sum_{i=1}^{n}g(d)S(\\frac{n}{d})-\\sum_{i=2}^{n}g(d)S(\\frac{n}{d}) = \\sum_{i=1}^n(f*g)(i)-\\sum_{i=2}^{n}g(d)S(\\frac{n}{d})$</p>\n<p>这里的 $g(1)$ 一般都是 $1$，所以只要能快速预处理出前面的 $f*g$ 的前缀和和 $g$ 的前缀和，后面的就可以通过整除分块递归求解。</p>\n<p>时间复杂度为 $O(\\sqrt n\\cdot \\sqrt{\\sqrt n}) = O(n^{\\frac{1}{2}+\\frac{1}{4}}) = O(n^{\\frac{3}{4}})$。</p>\n<p>由于这个$\\frac{n}{i}$的取值只有$\\sqrt n$种，所以如果用map把用过的 $\\frac{n}{i}$ 对应的前缀和的值都存起来，map中元素的个数不超过 $2\\cdot \\sqrt n$ 个。</p>\n<p>加上了记忆化搜索，提前筛好前$n^{\\frac{2}{3}}$个数之后，算法的时间复杂度就变成了$O(n^{\\frac{2}{3}})$。</p>\n<p>模板： <a href=\"https://www.luogu.com.cn/problem/P4213\">P4213 杜教筛</a> </p>\n<p>Code：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>,lim = <span class=\"number\">1.5e6</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,vis[N],pri[N],tot,mu[N];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> phi[N];</span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>,<span class=\"type\">long</span> <span class=\"type\">long</span>&gt; mp1,mp2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tphi[<span class=\"number\">1</span>] = mu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tphi[i] = i<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i%pri[j]) phi[i*pri[j]] = phi[i]*(pri[j]<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> phi[i*pri[j]] = phi[i]*pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\tmu[i]+=mu[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\tphi[i]+=phi[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">getmu</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;=lim) <span class=\"keyword\">return</span> mu[x];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mp1[x]) <span class=\"keyword\">return</span> mp1[x];</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">long</span> <span class=\"type\">long</span> l=<span class=\"number\">2</span>,r;l&lt;=x;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tr = x/(x/l);</span><br><span class=\"line\">\t\tret-=<span class=\"built_in\">getmu</span>(x/l)*(r-l+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mp1[x] = ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">getphi</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;=lim) <span class=\"keyword\">return</span> phi[x];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mp2[x]) <span class=\"keyword\">return</span> mp2[x];</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> ret = (x+<span class=\"number\">1</span>)*(x)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">long</span> <span class=\"type\">long</span> l=<span class=\"number\">2</span>,r;l&lt;=x;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tr = x/(x/l);</span><br><span class=\"line\">\t\tret-=<span class=\"built_in\">getphi</span>(x/l)*(r-l+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mp2[x] = ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"built_in\">getphi</span>(n)&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;<span class=\"built_in\">getmu</span>(n)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>杜教筛是基于整除分块和预处理保证时间复杂度的，筛数论函数前缀和的有力工具，其算法复杂度为 $O(n^{\\frac{2}{3}})$，即使 $n = 10^{12}$，也可以在常数较小的情况下跑过。</p>\n<p>要达到 $O(n^{\\frac{2}{3}})$ 的时间复杂度，你需要找到合适的函数 $g$ ，使你能够快速求出其前缀和和 $f*g$ 的前缀和，一般都是在上面提到的那一堆函数里面挑。</p>\n<p>还要灵活运用莫比乌斯反演，将你要求的函数转化为好求的东西哦。</p>\n","tags":["Knowledge","数论","杜教筛"]},{"title":"数字表格 题解","url":"/2022/06/03/%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"数字表格-题解\"><a href=\"#数字表格-题解\" class=\"headerlink\" title=\"数字表格 题解\"></a>数字表格 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>求$\\prod_{i=1}^n\\prod_{j=1}^mf_{\\gcd(i,j)}$，其中$f_i$表示斐波那契数列的第$i$项。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先把斐波那契数列去掉，因为这样写是没办法直接求的。</p>\n<p>因为是$\\prod$，所以我们可以把$\\gcd$相同的数的个数算出来，而那一项上的指数就是这个个数啦。</p>\n<span id=\"more\"></span>\n<p>转化为求这个东西：</p>\n<p>$\\prod_{d=1}^{\\min(n,m)}f_d^{\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd(i,j) = d]}$</p>\n<p>同时除以$d$：</p>\n<p>$\\prod_{d=1}^{\\min(n,m)}f_d^{\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{m}{d}}[gcd(i,j) = 1]}$</p>\n<p>将$\\gcd$变为$\\mu$：</p>\n<p>$\\prod_{d=1}^{\\min(n,m)}f_d^{\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{m}{d}}\\sum_{k|\\gcd(i,j)}\\mu(k)}$</p>\n<p>枚举$k$：</p>\n<p>$\\prod_{d=1}^{\\min(n,m)}f_d^{\\sum_{k=1}^{\\min(\\frac{n}{d},\\frac{m}{d})}\\mu(k)\\lfloor \\frac{n}{dk}\\rfloor \\lfloor \\frac{m}{dk} \\rfloor}$</p>\n<p>设$t=kd$：</p>\n<p>$\\prod_{d=1}^{\\min(n,m)}f_d^{\\sum_{d|t,t\\leq\\min(n,m)}\\mu(\\frac{t}{d})\\lfloor \\frac{n}{t}\\rfloor \\lfloor \\frac{m}{t}\\rfloor}$</p>\n<p>改枚举$t$：</p>\n<p>$\\prod_{t=1}^{\\min(n,m)}\\prod_{d|t}f_d^{\\mu(\\frac{t}{d})\\lfloor \\frac{n}{t}\\rfloor \\lfloor \\frac{m}{t}\\rfloor}$</p>\n<p>把一样的提出来：</p>\n<p>$\\prod_{t=1}^{\\min(n,m)}(\\prod_{d|t}f_d^{\\mu(\\frac{t}{d})})^{\\lfloor \\frac{n}{t}\\rfloor \\lfloor \\frac{m}{t}\\rfloor}$</p>\n<p>外面的式子可以用整除分块做到$O(\\sqrt n)$求解，我们把里面的式子拎出来：</p>\n<p>$\\prod_{d|t}f_d^{\\mu(\\frac{t}{d})}$</p>\n<p>看到求一个数的所有约数的贡献，首先应该想到用调和级数级别复杂度的算法：</p>\n<p>枚举$d$，贡献到它的所有倍数上，时间复杂度为$O(n\\log n)$，每次查询的时间复杂度为$O(1)$。</p>\n<p>注意前缀积也要预处理，方法是线性求逆元，不然可能无法通过。</p>\n<p>总时间复杂度为$O(n\\log n+T\\sqrt n)$。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,m,vis[N],pri[N],tot,mu[N];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sum[N],fib[N],inv[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> ret = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ret = (ret*bas)%mod;</span><br><span class=\"line\">\t\tbas = (bas*bas)%mod;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = sum[<span class=\"number\">1</span>] = inv[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = <span class=\"number\">1e6</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsum[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfib[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++) fib[i] = (fib[i<span class=\"number\">-1</span>]+fib[i<span class=\"number\">-2</span>])%mod;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;i*j&lt;=lim;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (mu[j] == <span class=\"number\">1</span>) sum[i*j] = (sum[i*j]*fib[i])%mod;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mu[j] == <span class=\"number\">-1</span>) sum[i*j] = (sum[i*j]*<span class=\"built_in\">ksm</span>(fib[i],mod<span class=\"number\">-2</span>))%mod;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> tim = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) tim = (tim*sum[i])%mod;</span><br><span class=\"line\">\ttim = <span class=\"built_in\">ksm</span>(tim,mod<span class=\"number\">-2</span>);</span><br><span class=\"line\">\tinv[lim] = tim;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=lim<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">1</span>;i--) inv[i] = (inv[i+<span class=\"number\">1</span>]*sum[i+<span class=\"number\">1</span>])%mod;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++) sum[i] = (sum[i]*sum[i<span class=\"number\">-1</span>])%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r,Min = <span class=\"built_in\">min</span>(n,m);</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=Min;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tr = <span class=\"built_in\">min</span>(n/(n/l),m/(m/l));</span><br><span class=\"line\">\t\t\tans = (ans*<span class=\"built_in\">ksm</span>(sum[r]*inv[l<span class=\"number\">-1</span>]%mod,(<span class=\"number\">1ll</span>*n/l*(m/l))%(mod<span class=\"number\">-1</span>)))%mod;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>有些时候，推不了了就想办法换一个枚举的东西，之后重新推，而且式子中变量越少越好，比如这道题中，如果直接用$\\frac{n}{dk}$，是需要确定两个变量才行的，所以就想到把$dk$打包成一个变量。</p>\n<p>而且，在这种多组数据的题目里，一般需要预处理出一些东西，加快计算，这就要求其中的变量尽量少（如果有两个变量，复杂度就直接爆炸了）。</p>\n<p>而最快的预处理方式一般是调和级数级别的，所以要往推出形如$\\sum_{d|k}f(d)$之类的东西。</p>\n<p>总之，这是一道比较考验推式子的技巧（<del>套路</del>）的好题。</p>\n","tags":["Knowledge","数学","数论","莫比乌斯反演","逆元"]},{"title":"对莫比乌斯函数的研究","url":"/2022/05/26/%E5%AF%B9%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E7%9A%84%E7%A0%94%E7%A9%B6/","content":"<h1 id=\"对莫比乌斯函数的研究\"><a href=\"#对莫比乌斯函数的研究\" class=\"headerlink\" title=\"对莫比乌斯函数的研究\"></a>对莫比乌斯函数的研究</h1><p>$\\color{lightgreen}Status:Finished$.</p>\n<h2 id=\"更新日志\"><a href=\"#更新日志\" class=\"headerlink\" title=\"更新日志\"></a>更新日志</h2><p>2022/5/25 成文。</p>\n<p>2022/5/28 对部分语言进行了更改，简要写了一下一般用在哪。</p>\n<p>2022/6/25 更新了部分内容，补充了各种函数的基本用法，增加了一些例题。</p>\n<h2 id=\"什么是莫比乌斯函数\"><a href=\"#什么是莫比乌斯函数\" class=\"headerlink\" title=\"什么是莫比乌斯函数\"></a>什么是莫比乌斯函数</h2><p>将 $n$ 分解，$n = \\prod_{i=1}^kp_i^{c_i}$。</p>\n<p>如果对于 $1\\leq i \\leq k$，$c_i\\leq 1$，则$\\mu(k) = (-1)^k$。</p>\n<p>否则，$\\mu(k) = 0$。</p>\n<p>等于 $0$ 的 $\\mu$ 值可以避免一些乘法计算，因为乘出来的结果就是 $0$。</p>\n<span id=\"more\"></span>\n<h2 id=\"这个东西有什么用\"><a href=\"#这个东西有什么用\" class=\"headerlink\" title=\"这个东西有什么用\"></a>这个东西有什么用</h2><h3 id=\"积性函数\"><a href=\"#积性函数\" class=\"headerlink\" title=\"积性函数\"></a>积性函数</h3><p>当两个数$n$，$m$互质时，必然不包含相同的质因数，所以乘起来之后质因数的指数没有变化 ，故 $\\mu(n\\cdot m) = \\mu(n) \\cdot \\mu(m)$。</p>\n<p>这个性质使 $\\mu$ 能用线性筛筛出。</p>\n<h3 id=\"性质1\"><a href=\"#性质1\" class=\"headerlink\" title=\"性质1\"></a>性质1</h3><p>$\\sum_{d|n}\\mu(d) = [n = 1]$</p>\n<p>卷积形式：$\\mu*I = \\epsilon$。</p>\n<h4 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h4><p>当 $n = 1$ 时，有 $\\sum_{d|n} \\mu(d) = 1$，因为它等价于 $\\mu(d) = 1$。</p>\n<p>当 $n\\neq 1$ 时，设 $n = \\prod_{i=1}^kp_i^{c_i}$，$n’ = \\prod_{i=1}^kp_i$。</p>\n<p>注意到，对于指数 $&gt;1$ 的，它的贡献是 $0$，所以有贡献的数必然是 $n’$ 的约数，即：</p>\n<p>$\\sum_{d|n}\\mu(d) = \\sum_{d|n’}\\mu(d)$</p>\n<p>之后，根据 $\\mu$ 函数的定义，得到以下式子：</p>\n<p>$\\sum_{d|n’}\\mu(d) = \\sum_{i=0}^k C_k^i\\cdot (-1)^i$</p>\n<p>$i$ 从 $0$ 开始是为了把 $d = 1$ 的情况算进去。</p>\n<p>这个式子很眼熟（虽然我第一次看它时毫无感觉），这很像二项式定理啊：</p>\n<p>$(a+b)^k = \\sum_{i=0}^k C_k^i a^i b^{k-i}$</p>\n<p>于是可以把原式化为 $(1+(-1))^k = (1-1)^k = 0^k$。</p>\n<p>发现，当 $k\\neq 0$ 时，这个式子的值为 $0$。</p>\n<p>得证。</p>\n<h4 id=\"在哪里用\"><a href=\"#在哪里用\" class=\"headerlink\" title=\"在哪里用\"></a>在哪里用</h4><p>可能它最大的用处是下面的扩展。</p>\n<h3 id=\"性质1扩展\"><a href=\"#性质1扩展\" class=\"headerlink\" title=\"性质1扩展\"></a>性质1扩展</h3><p>$[\\gcd(i,j) = 1] = \\sum_{d|\\gcd(i,j)}\\mu(d)$</p>\n<p>直接把 $\\gcd(i,j)$ 代入性质1中的 $n$ 即可得到。</p>\n<h4 id=\"在哪里用-1\"><a href=\"#在哪里用-1\" class=\"headerlink\" title=\"在哪里用\"></a>在哪里用</h4><p>很多求 $\\gcd$ 的题目最终都是化成这个形式，之后通过反演，把难看的 $\\gcd$ 转化为可以线性求出的 $\\mu$。</p>\n<p>一般，在莫比乌斯反演题目中，最后都是要化出这个形式，再变换，所以这个东西也被称作反演结论。</p>\n<p><del>由于我太菜了，不太会莫比乌斯反演，一车题都是用这个反演结论做的，但是还没碰到有关$\\gcd$且只能用莫比乌斯反演做的题。</del></p>\n<h3 id=\"性质2\"><a href=\"#性质2\" class=\"headerlink\" title=\"性质2\"></a>性质2</h3><p>$n = \\sum_{d|n}\\varphi(d)$</p>\n<p>卷积形式：$\\varphi * I =id$</p>\n<p>由它可以推导出另一个式子：</p>\n<p>$\\varphi(n) = \\sum_{d|n}\\frac{n}{d}\\mu(d)$</p>\n<p>卷积形式：$\\mu*id = \\varphi$</p>\n<p><del>这个东西我好像只会用卷积推</del></p>\n<p>我也不知道这个有什么用，但是它看上去能把欧拉函数和莫比乌斯函数联系起来，似乎很重要的样子。</p>\n<h4 id=\"证明-1\"><a href=\"#证明-1\" class=\"headerlink\" title=\"证明\"></a>证明</h4><p><del>搬运杜教筛博客中的证明</del></p>\n<p>将 $x$ 分解质因数：</p>\n<p>$x = \\prod_{i=1}^kp_i^{c_i}$</p>\n<p>由于 $\\varphi$ 是积性函数，所以可以将式子化为下面的形式：</p>\n<p>$\\prod_{i=1}^k\\sum_{j=0}^{c_i}\\varphi(p_i^j) = x$</p>\n<p>于是，设 $x’ = p^{c}$，要证的东西变成了下面的这个：</p>\n<p>$\\sum_{i=0}^{c}\\varphi(p^i) = x’$</p>\n<p>发现，它们都只有一个质因数 $p$，所以直接套欧拉函数定义式求值：</p>\n<p>$1+p\\cdot \\frac{p-1}{p}+p^2\\cdot \\frac{p-1}{p}+\\cdots +p^{c}\\cdot \\frac{p-1}{p}$</p>\n<p>化简：</p>\n<p>$1+(p-1)\\cdot (1+p+p^2+\\cdots+p^{c-1})$</p>\n<p>等比数列求和：</p>\n<p>$1+(p-1)\\cdot \\frac{p^{c}-1}{p-1} = p^c$</p>\n<p>得证。</p>\n<h4 id=\"在哪里用-2\"><a href=\"#在哪里用-2\" class=\"headerlink\" title=\"在哪里用\"></a>在哪里用</h4><p>感兴趣的可以做做这题：<a href=\"https://www.luogu.com.cn/problem/P1447\">P1447 NOI2010 能量采集</a>。</p>\n<h3 id=\"莫比乌斯变换\"><a href=\"#莫比乌斯变换\" class=\"headerlink\" title=\"莫比乌斯变换\"></a>莫比乌斯变换</h3><p>设 $f(x)$，$g(x)$ 为两个数论函数。</p>\n<p>形式1：</p>\n<p>$f(x) = \\sum_{d|n}g(d)$，那么 $g(x) = \\sum_{d|n}\\mu(\\frac{n}{d})f(d) = \\sum_{d|n}\\mu(d)f(\\frac{n}{d})$。</p>\n<p>形式2：</p>\n<p>$f(x) = \\sum_{n|d}g(d)$，那么 $g(x) = \\sum_{n|d}\\mu(\\frac{d}{n})f(d) = \\sum_{n|d}\\mu(d)f(\\frac{d}{n})$。</p>\n<h4 id=\"证明-2\"><a href=\"#证明-2\" class=\"headerlink\" title=\"证明\"></a>证明</h4><p>考虑卷积形式：</p>\n<p>已知 $f = g<em>I$，证明 $g = f</em>\\mu$。</p>\n<p>对第二个式子变换：</p>\n<p>$g<em>I = f</em>\\mu*I$</p>\n<p>$f = f*\\epsilon$</p>\n<p>化开：</p>\n<p>$f(x) = \\sum_{d|x}f(d)\\cdot [\\frac{x}{d} = 1]$</p>\n<p>只有当 $d = x$时有贡献，故原式得证。</p>\n<h2 id=\"怎么求出莫比乌斯函数的值呢\"><a href=\"#怎么求出莫比乌斯函数的值呢\" class=\"headerlink\" title=\"怎么求出莫比乌斯函数的值呢\"></a>怎么求出莫比乌斯函数的值呢</h2><p>当然是用线性筛了！</p>\n<p>我们在判断 $vis[i]&lt;pri[j]$ 时将相等情况特判一下，因为如果 $vis[i] = pri[j]$，那么 $i\\cdot pri[j]$ 中质因子 $pri[j]$ 的指数至少是 $2$，所以 $\\mu(i\\cdot pri[j]) = 0$，其他的直接根据积性函数性质拿 $\\mu(i)\\cdot \\mu(pri[j])$ 就行了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>; <span class=\"comment\">//1要特别初始化，因为它是特殊定义的</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = <span class=\"number\">5e4</span>+<span class=\"number\">10</span>; <span class=\"comment\">//筛到的数的上限</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">            vis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>; <span class=\"comment\">//质数的mu为-1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i]; <span class=\"comment\">//在vis[i] = pri[j]时要赋值为0</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果是求单个数的 $\\mu$，也可以枚举它的质因数，找出其指数，求出值，时间复杂度为$O(\\sqrt n)$。</p>\n<h2 id=\"例题1\"><a href=\"#例题1\" class=\"headerlink\" title=\"例题1\"></a>例题1</h2><p><a href=\"https://www.luogu.com.cn/problem/P3455\">P3455 POI2007 ZAP-Queries</a></p>\n<p>求 $\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd(i,j) = d]$。</p>\n<p>尽量往出现 $[\\gcd(i,j) = 1]$ 的方向推，因为这样才能用反演结论：</p>\n<p>$\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{m}{d}}[\\gcd(i,j) = 1]$</p>\n<p>把这个东西反演掉：</p>\n<p>$\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{m}{d}}\\sum_{t|\\gcd(i,j)}\\mu(t)$</p>\n<p>这个 $t|\\gcd(i,j)$ 的限制不好处理，怎么办？<strong>既然 $t$ 是变的，就要确定一个枚举顺序让它在更深的循环内不变</strong>：</p>\n<p>$\\sum_{t=1}^{\\min(\\frac{n}{d},\\frac{m}{d})}\\mu(t)\\sum_{t|\\gcd(i,j)}1$</p>\n<p>发现，只有当 $t|\\gcd(i,j)$ 的时候才有贡献，也就是说，只有当 $t|i$ 且 $t|j$ 时，才会被计算进去，而这样的数对 $(i,j)$ 的个数显然是 $\\frac{n}{dt}\\frac{m}{dt}$：</p>\n<p>$\\sum_{t=1}^{\\min(\\frac{n}{d},\\frac{m}{d})}\\mu(t)\\frac{n}{dt}\\frac{m}{dt}$</p>\n<p>发现，后面的 $\\frac{n}{dt}$ 和 $\\frac{m}{dt}$ 都是裸的整除分块，于是总时间复杂度就变成了 $O(\\sqrt n)$。</p>\n<p>一般的莫比乌斯反演题目，<strong>最后都要推到能够整除分块处理的式子上，否则复杂度会很高</strong>。</p>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><p><a href=\"https://www.luogu.com.cn/problem/P2568\">P2568 GCD</a></p>\n<p>求 $\\sum_{i=1}^n\\sum_{j=1}^n[\\gcd(i,j)\\in Prime]$。</p>\n<p>先枚举 $\\gcd$：</p>\n<p>$\\sum_{p\\in Prime}\\sum_{i=1}^{n}\\sum_{j=1}^n[\\gcd(i,j) = p]$</p>\n<p>写成 $[\\gcd(i,j) = 1]$ 的形式：</p>\n<p>$\\sum_{p\\in Prime}\\sum_{i=1}^{\\frac{n}{p}}\\sum_{j=1}^\\frac{n}{p}[\\gcd(i,j) = 1]$</p>\n<p>这时，已经可以开始反演了，但是我们实际上有两种思路可以选择：</p>\n<h3 id=\"思路1\"><a href=\"#思路1\" class=\"headerlink\" title=\"思路1\"></a>思路1</h3><p>既然反演结论已经出现，就直接反演掉：</p>\n<p>$\\sum_{p\\in Prime}\\sum_{i=1}^{\\frac{n}{p}}\\sum_{j=1}^{\\frac{n}{p}}\\sum_{d|\\gcd(i,j)}\\mu(d)$</p>\n<p>枚举 $d$：</p>\n<p>$\\sum_{p\\in Prime}\\sum_{d=1}^{\\frac{n}{p}}\\mu(d)(\\frac{n}{pd})^2$</p>\n<p>对于每个质数都用整除分块计算一遍，时间复杂度为 $O(n\\sqrt n)$，勉强可以通过。</p>\n<h3 id=\"思路2\"><a href=\"#思路2\" class=\"headerlink\" title=\"思路2\"></a>思路2</h3><p>如果我们令 $i\\geq j$，那么后面的就是 $\\sum_{i=1}^{\\frac{n}{p}}\\sum_{j=1}^{i}[\\gcd(i,j) = 1]$。</p>\n<p>把后面的单独拿出来看：</p>\n<p>$\\sum_{j=1}^{i}[\\gcd(i,j) = 1]$</p>\n<p>这不就是 $\\varphi(i)$ 吗！</p>\n<p>于是，原式化成 $\\sum_{p\\in Prime}\\sum_{i=1}^{\\frac{n}{p}}2\\cdot \\varphi(i)-1$。</p>\n<p>至于为啥后面的是 $2\\cdot \\varphi(i)-1$：</p>\n<p>首先，刚刚是令 $i\\geq j$，显然 $i\\leq j$ 时也是对称的，所以是 $2\\cdot \\varphi(i)$。</p>\n<p>其次，这两种情况的重叠部分只有 $[\\gcd(1,1) = 1]$，所以要减去 $1$。</p>\n<p>但是，如果你想的是直接算这个式子，那还是太天真了。</p>\n<p>把后面的东西提出来：</p>\n<p>$f(n) = \\sum_{i=1}^{n}2\\cdot \\varphi(i)-1$</p>\n<p><strong>这个 $f$ 是可以预处理的，因为它里面的值和上界 $n$ 没有关系。</strong></p>\n<p>也就是说，我们可以在线性筛的时候完成这个工作，之后只用把每个质数对应的 $f$ 加起来就行了。</p>\n<p>时间复杂度 $O(n)$。</p>\n<p>但是，这种思路的应用需要满足特定的条件，即这里的 $i$、$j$ 的枚举上界都是一样的，这样才符合 $\\varphi$ 函数的性质。</p>\n<h2 id=\"例题3\"><a href=\"#例题3\" class=\"headerlink\" title=\"例题3\"></a>例题3</h2><p><a href=\"https://www.luogu.com.cn/problem/P2257\">P2257 YY的GCD</a></p>\n<p>现在，不仅有了 $n$、$m$，还加入了多测，上面两种方法全都挂了。</p>\n<p>思路2已经不可用，只能顺着思路1继续推了（下面假设 $n\\leq m$）：</p>\n<p>$\\sum_{p\\in Prime}\\sum_{d=1}^{\\frac{n}{p}}\\mu(d)\\frac{n}{pd}\\frac{m}{pd}$</p>\n<p>看看这个式子，发现最毒瘤的地方是 $\\frac{n}{pd}$，这使它受到两个变量的制约，完全不能变换。</p>\n<p>怎么办？既然它是变的，我们枚举它就好了啊！</p>\n<p>令 $T = pd$：</p>\n<p>$\\sum_{T=1}^{n}\\frac{n}{T}\\frac{m}{T}\\sum_{p\\in Prime,p|T}\\mu(\\frac{T}{p})$</p>\n<p>看上去没有办法化简了呢（实际上我也确实不知道怎么化了），直接算的复杂度还是 $O(n^2)$，是否就这样挂了呢？</p>\n<p>注意到这里有一个很特殊的地方：$p|T$。</p>\n<p>既然 $T$ 是 $p$ 的倍数，那就可以用调和级数的复杂度预处理出后面的东西了！</p>\n<p>简单来说，就是枚举质数 $p$，将 $\\mu(kp)$ 贡献到它的倍数 $kp$ 上去，这样的复杂度是：</p>\n<p>$O(\\frac{n}{1}+\\frac{n}{2}+\\cdots+\\frac{n}{n}) = O(n\\log n)$</p>\n<p>于是，只用花 $O(n\\log n)$ 的时间预处理，花 $O(\\sqrt n)$ 的时间用整除分块算出答案，可以通过。</p>\n<h2 id=\"例题4\"><a href=\"#例题4\" class=\"headerlink\" title=\"例题4\"></a>例题4</h2><p><a href=\"https://www.luogu.com.cn/problem/SP3871\">SP3871 GCDEX - GCD Extreme</a></p>\n<p>求 $\\sum_{i=1}^{n}\\sum_{j=i+1}^n\\gcd(i,j)$。</p>\n<p>这里，求的不再是 $[\\gcd(i,j) = d]$，而是所有的 $\\gcd$。怎么办？枚举 $d$：</p>\n<p>$\\sum_{d=1}^nd\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=i+1}^\\frac{n}{d}[\\gcd(i,j) = 1]$</p>\n<h3 id=\"思路1-1\"><a href=\"#思路1-1\" class=\"headerlink\" title=\"思路1\"></a>思路1</h3><p>我是莫比乌斯反演的忠实粉丝，无论如何都要用反演做出来！</p>\n<p>$\\sum_{d=1}^nd\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=i+1}^{\\frac{n}{d}}\\sum_{k|\\gcd(i,j)}\\mu(k)$</p>\n<p>这里的 $j=i+1$ 有些限制发挥了，就改写成 $j=1$：</p>\n<p>$f(x) = \\sum_{d=1}^nd\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{n}{d}}\\sum_{k|\\gcd(i,j)}\\mu(k)$</p>\n<p>答案就是 $\\frac{f(x)-(1+2+\\cdots +n)}{2}$。</p>\n<p>提出 $k$：</p>\n<p>$\\sum_{d=1}^nd\\sum_{k=1}^{\\frac{n}{d}}\\mu(k)(\\frac{n}{dk})^2$</p>\n<p>令 $T = dk$：</p>\n<p>$\\sum_{T=1}^n(\\frac{n}{T})^2\\sum_{d|T}\\mu(\\frac{T}{d})d$</p>\n<p>（眼尖的同学已经可以把这道题秒了，因为后面的东西就是 $\\mu*Id = \\varphi$）</p>\n<p>注意到 $d|t$ 这个限制，又是熟悉的用调和级数复杂度预处理出来。</p>\n<p>前面的东西直接整除分块，时间复杂度为 $O(n\\log n+T\\sqrt n)$。</p>\n<h3 id=\"思路2-1\"><a href=\"#思路2-1\" class=\"headerlink\" title=\"思路2\"></a>思路2</h3><p>我是非常NB的选手，一眼就看出它是个欧拉函数！</p>\n<p>$\\sum_{d=1}^nd\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=i+1}^\\frac{n}{d}[\\gcd(i,j) = 1]$</p>\n<p>转换枚举顺序：</p>\n<p>$\\sum_{d=1}^nd\\sum_{i=2}^{\\frac{n}{d}}\\sum_{j=1}^{i-1}[\\gcd(i,j) = 1]$</p>\n<p>后面的东西就是 $\\varphi$：</p>\n<p>$\\sum_{d=1}^n\\sum_{i=2}^{\\frac{n}{d}}\\varphi(i)$</p>\n<p>后面的可以预处理出来，前面的可以整除分块做，时间复杂度为 $O(n+T\\sqrt n)$。</p>\n<p><strong>欧拉函数在一定条件下可以极大的简化推式子的过程，因为可以用 $\\mu$ 推的最后大概都能卷成 $\\varphi$。</strong></p>\n<h2 id=\"例题5\"><a href=\"#例题5\" class=\"headerlink\" title=\"例题5\"></a>例题5</h2><p><a href=\"https://www.luogu.com.cn/problem/P1891\">P1891 疯狂 LCM</a></p>\n<p>求 $\\sum_{i=1}^n\\operatorname{lcm}(i,n)$。</p>\n<p>$\\operatorname{lcm}$ 怎么求？这里有一个常见的转化技巧：</p>\n<p>$\\operatorname{lcm}(i,j) = \\frac{i\\cdot j}{\\gcd(i,j)}$</p>\n<p>（这个应该自己推一推就出来了）</p>\n<p>转化为（不要自作聪明把 $n$ 提出来，因为这里的除实际上是下取整）：</p>\n<p>$\\sum_{i=1}^n\\frac{i\\cdot n}{\\gcd(i,n)}$</p>\n<p>枚举 $\\gcd$：</p>\n<p>$\\sum_{d=1}^n\\sum_{i=1}^n\\frac{i\\cdot n}{d}[\\gcd(i,n) = d]$</p>\n<p>往 $\\gcd(i,j) = 1$ 上化：</p>\n<p>$\\sum_{d=1}^n\\sum_{i=1}^{\\frac{n}{d}}\\frac{i\\cdot d\\cdot n}{d}[\\gcd(i,\\frac{n}{d}) = 1]$</p>\n<p>整理一下：</p>\n<p>$n\\sum_{d=1}^n\\sum_{i=1}^{\\frac{n}{d}}i[\\gcd(i,\\frac{n}{d}) = 1]$</p>\n<h3 id=\"思路1-2\"><a href=\"#思路1-2\" class=\"headerlink\" title=\"思路1\"></a>思路1</h3><p>我爱莫反！</p>\n<p>$n\\sum_{d=1}^n\\sum_{i=1}^{\\frac{n}{d}}i\\sum_{k|\\gcd(i,\\frac{n}{d})}\\mu(k)$</p>\n<p>枚举 $k$：</p>\n<p>$n\\sum_{d=1}^n\\sum_{k|\\frac{n}{d}}\\mu(k)(k+2\\cdot k+\\lfloor\\frac{n}{dk}\\rfloor \\cdot k)$</p>\n<p>后面的调和级数复杂度预处理，前面的整除分块求答案，时间复杂度为 $O(n\\log n+T\\sqrt n)$。</p>\n<h3 id=\"思路2-2\"><a href=\"#思路2-2\" class=\"headerlink\" title=\"思路2\"></a>思路2</h3><p>这不是裸的欧拉函数吗！</p>\n<p>$n\\sum_{d=1}^n\\sum_{i=1}^{\\frac{n}{d}}i[\\gcd(i,\\frac{n}{d}) = 1]$</p>\n<p>众所周知，$\\sum_{i=1}^ni[\\gcd(i,n) = 1] = \\frac{n\\cdot \\varphi(n)}{2}$</p>\n<p>可以这样理解：如果 $x$ 不和 $n$ 互质，那么 $n-x$ 也不和 $n$ 互质，所以不和 $n$ 互质的数的平均值为 $\\frac{n}{2}$。</p>\n<p>所以，和 $n$ 互质的数的平均值也为 $\\frac{n}{2}$。</p>\n<p>于是，原式可化为：</p>\n<p>$n\\sum_{d=1}^n\\frac{\\frac{n}{d}\\cdot \\varphi(\\frac{n}{d})}{2}$</p>\n<p>直接整除分块即可做到 $O(n+T\\sqrt n)$ 的复杂度。</p>\n<h2 id=\"例题6\"><a href=\"#例题6\" class=\"headerlink\" title=\"例题6\"></a>例题6</h2><p><a href=\"https://www.luogu.com.cn/problem/P3911\">P3911 最小公倍数之和</a></p>\n<p>给你一些数 $a_1,a_2\\cdots a_n$，求 $\\sum_{i=1}^n\\sum_{j=1}^n\\operatorname{lcm}(a_i,a_j)$。</p>\n<p>直接求解不太可行，但是注意到题目中 $a_i\\leq 5\\cdot 10^4$ 的特殊限制，不难想到转化为求所有数的 $\\operatorname{lcm}$。</p>\n<p>$\\sum_{i=1}^n\\sum_{j=1}^n\\operatorname{lcm}(i,j)\\cdot c_i\\cdot c_j$</p>\n<p>其中 $c_i$ 代表值为 $i$ 的数的个数有多少个。</p>\n<p>将 $\\operatorname{lcm}$ 变成 $gcd$：</p>\n<p>$$</p>\n<h2 id=\"一些练习\"><a href=\"#一些练习\" class=\"headerlink\" title=\"一些练习\"></a>一些练习</h2><p><a href=\"https://www.luogu.com.cn/problem/P1447\">P1447 NOI2010 能量采集</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P5221\">P5221 Product</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1829\">P1829 国家集训队Crash的数字表格</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3327\">P3327 SDOI2015 约数个数和</a></p>\n<p>这些练习里面的技巧也有十分常用的，希望各位能够掌握。<del>主要还是我太懒了，不然会把里面的技巧一起总结的。</del></p>\n<h2 id=\"说在最后\"><a href=\"#说在最后\" class=\"headerlink\" title=\"说在最后\"></a>说在最后</h2><p>首先，上面的文字都是我口胡出来的，如有错误，还请指正。</p>\n<p>这些题目的代码都分散在博客中的各篇题解中（虽然那时我对莫反的理解还十分肤浅），有兴趣的同学可以自行查看。</p>\n<p>莫比乌斯反演是十分精深的学问，对技巧性要求很高，有时候，多见一个套路可能会让你豁然开朗，而推错方向、反演时机错误、漏掉一些东西、不能观察到式子中隐藏的性质，都有可能使你功亏一篑。</p>\n<p>所以请在做莫反题时保持耐心、开阔思路，实在推不出来时，也要对自己有信心，虚心的对照题解思考自己在哪一步出了问题、哪里没有想到。这类题不是死的，灵活性很强，而我们这种平凡人能做的，就是练习，熟能生巧啊。</p>\n","tags":["Knowledge","数学","数论","莫比乌斯反演"]},{"title":"对线段树的研究","url":"/2022/07/13/%E5%AF%B9%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E7%A0%94%E7%A9%B6/","content":"<h1 id=\"对线段树的研究\"><a href=\"#对线段树的研究\" class=\"headerlink\" title=\"对线段树的研究\"></a>对线段树的研究</h1><p>$\\color{lightblue}Status:OK$</p>\n<h2 id=\"咕\"><a href=\"#咕\" class=\"headerlink\" title=\"咕\"></a>咕</h2><p>李超树</p>\n<p>Segment Tree Beats</p>\n<p>线段树二分</p>\n<p>线段树合并</p>\n<p>线段树分治</p>\n<span id=\"more\"></span>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>线段树实际上是一个满二叉树，每个节点都存储一段区间内的信息，而且可以通过左右孩子的信息推出自己的信息。所以要求存储的信息具有可加性。</p>\n<p>具体线段树怎么写应该不用多说了。。。</p>\n<p>在有区间修改时，必须应用懒标记以保证复杂度，因为这样只会对 $\\log n$ 个节点的信息产生修改，这也要求了懒标记具有可加性，且下传的时间复杂度应比较低。</p>\n<h2 id=\"经典应用\"><a href=\"#经典应用\" class=\"headerlink\" title=\"经典应用\"></a>经典应用</h2><h3 id=\"特殊的信息合并——区间最大子段和\"><a href=\"#特殊的信息合并——区间最大子段和\" class=\"headerlink\" title=\"特殊的信息合并——区间最大子段和\"></a>特殊的信息合并——区间最大子段和</h3><p><a href=\"https://www.luogu.com.cn/problem/SP1716\">SP1716 GSS3 - Can you answer these queries III</a></p>\n<p>给你一个序列，操作有：</p>\n<ol>\n<li>每次询问 $[l,r]$ 中的最大子段和。</li>\n<li>单点修改一个数的值（可能有负数）。</li>\n</ol>\n<p>区间最大子段和指区间内一个连续的子区间，它们的和是这个区间内所有子区间中最大的。</p>\n<p>如果已经知道两个连续的子区间的最大子段和，这个大区间的最大子段和可以是两个里面更大的一个，也可以是横跨两个区间的新区间，难点就在于把横跨两个区间的最大区间算出来。</p>\n<p>只维护一个区间和是不行的，怎么办？维护多个信息！</p>\n<p>考虑维护 $4$ 个信息：区间和($sum$)、从左端点开始的最大子段和($lMax$)，从右端点开始的最大子段和($rMax$)，区间最大子段和($Max$)。</p>\n<p>那么，横跨两个区间的最大子段和就是左区间的 $rMax$ 加上右区间的 $lMax$。</p>\n<p>这里有个形象的图，其中绿色部分代表左区间的 $rMax$，橙色部分代表右区间的 $lMax$：</p>\n<p><a href=\"https://imgloc.com/image/Nrq5X\"><img src=\"https://s1.328888.xyz/2022/07/17/Nrq5X.png\" alt=\"Nrq5X.png\"></a></p>\n<p>于是可以合并两个子树的信息，维护当前节点的 $Max$。</p>\n<p>$lMax$ 可以是左子树的 $lMax$，也可以是左子树的 $sum$ 加上右子树的 $lMax$。</p>\n<p>$rMax$ 同理。</p>\n<p>这样，我们就可以轻松的写出 pushup 操作。</p>\n<p>但是，还有一个难题：如何写出 query？</p>\n<p>给定了区间 $[l,r]$，就意味着可能出现一个满足条件的区间在孙子里面的情况，这样就无法很好的维护 $lMax$ 和 $rMax$ 。</p>\n<p>有一个骚操作：直接将节点当作返回值，方便获取 $lMax$ 和 $rMax$，这样就和维护儿子节点一样了。</p>\n<p>这个问题启发我们：<strong>在信息不好维护时找信息之间的关系，把有关联的信息都维护掉，信息就能够维护了</strong>。</p>\n<h4 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,a[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tre</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,sum,Max,lMax,rMax;</span><br><span class=\"line\">&#125; tr[N*<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(tre &amp;node,tre lc,tre rc)</span></span>&#123; <span class=\"comment\">//传3个参数方便在query时调用 </span></span><br><span class=\"line\">\tnode.Max = <span class=\"built_in\">max</span>(-inf,<span class=\"built_in\">max</span>(lc.Max,<span class=\"built_in\">max</span>(rc.Max,lc.rMax+rc.lMax)));</span><br><span class=\"line\">\tnode.lMax = <span class=\"built_in\">max</span>(-inf,<span class=\"built_in\">max</span>(lc.lMax,lc.sum+rc.lMax));</span><br><span class=\"line\">\tnode.rMax = <span class=\"built_in\">max</span>(-inf,<span class=\"built_in\">max</span>(rc.rMax,rc.sum+lc.rMax));</span><br><span class=\"line\">\tnode.sum = (lc.sum == -inf?<span class=\"number\">0</span>:lc.sum)+(rc.sum == -inf?<span class=\"number\">0</span>:rc.sum)-((lc.sum == -inf &amp;&amp; rc.sum == -inf)?-inf:<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\ttr[node].l = tr[node].r = l;</span><br><span class=\"line\">\t\ttr[node].sum = tr[node].Max = tr[node].lMax = tr[node].rMax = a[l];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>,lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(lc,l,mid);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(rc,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(tr[node],tr[lc],tr[rc]);</span><br><span class=\"line\">\ttr[node].l = tr[lc].l;</span><br><span class=\"line\">\ttr[node].r = tr[rc].r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r)&#123;</span><br><span class=\"line\">\t\ttr[node].sum = tr[node].Max = tr[node].lMax = tr[node].rMax = v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">update</span>(lc,l,r,v);</span><br><span class=\"line\">\t<span class=\"built_in\">update</span>(rc,l,r,v);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(tr[node],tr[lc],tr[rc]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">tre <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\ttre ans;</span><br><span class=\"line\">\tans.lMax = ans.rMax = ans.Max = ans.sum = -inf;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r) <span class=\"keyword\">return</span> tr[node];</span><br><span class=\"line\">\ttre lc = <span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r),rc = <span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(ans,lc,rc);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> op,l,r;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>) cout&lt;&lt;<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,l,r).Max&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(<span class=\"number\">1</span>,l,l,r);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"练手题：\"><a href=\"#练手题：\" class=\"headerlink\" title=\"练手题：\"></a>练手题：</h4><p><a href=\"https://www.luogu.com.cn/problem/P4513\">P4513 小白逛公园</a></p>\n<p><a href=\"https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/A\">A - Segment Tree</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1471\">P1471 方差</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/SP2916\">SP2916 GSS5 - Can you answer these queries V</a></p>\n<h3 id=\"均摊复杂度——区间开平方\"><a href=\"#均摊复杂度——区间开平方\" class=\"headerlink\" title=\"均摊复杂度——区间开平方\"></a>均摊复杂度——区间开平方</h3><p><a href=\"https://www.luogu.com.cn/problem/SP2713\">SP2713 GSS4 - Can you answer these queries IV</a></p>\n<p>给你一个序列，操作有：</p>\n<ol>\n<li>区间内的每个数开方（下取整）。</li>\n<li>区间求和。</li>\n</ol>\n<p>给区间内的所有数开方显然不是给和开方就能解决的，貌似只能暴力在叶子节点开方。</p>\n<p>但是，这样实际上就足够了，因为一个 $10^{18}$ 以内的数 $7$ 次左右开方就能开到 $1$，所以对一个数的操作次数最多为 $7$ 次，那么对所有数的操作次数最多就是 $7n$ 次了，时间绰绰有余。</p>\n<p>但是，不要用懒标记延迟下传到儿子，因为你不能在只知道区间和的情况下求出区间开方后的值，所以无法提前改变当前节点的和，导致访问到未更新的值。</p>\n<p>这个问题告诉我们两个要点：</p>\n<ol>\n<li>使用懒标记前必须确保能在下传之前更新当前节点的值。</li>\n<li>不仅要思考如何合并区间信息，在无法合并时也要分析暴力修改的复杂度，有很多时候传到叶子节点，复杂度也是对的。</li>\n</ol>\n<h4 id=\"Code：-1\"><a href=\"#Code：-1\" class=\"headerlink\" title=\"Code：\"></a>Code：</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> a[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tre</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> l,r,flag;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> sum;</span><br><span class=\"line\">&#125; tr[N*<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">    tr[node].sum = tr[lc].sum+tr[rc].sum;</span><br><span class=\"line\">    tr[node].flag = (tr[lc].flag&amp;tr[rc].flag);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">        tr[node].l = tr[node].r = l;</span><br><span class=\"line\">        tr[node].sum = a[l];</span><br><span class=\"line\">        tr[node].flag = (a[l] &lt;= <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>,lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(lc,l,mid);</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(rc,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(node);</span><br><span class=\"line\">    tr[node].l = tr[lc].l;</span><br><span class=\"line\">    tr[node].r = tr[rc].r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[node].flag) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    tr[node].sum = <span class=\"built_in\">sqrt</span>(tr[node].sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r &amp;&amp; tr[node].flag) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[node].l == tr[node].r)&#123;</span><br><span class=\"line\">        tr[node].sum = <span class=\"built_in\">sqrt</span>(tr[node].sum);</span><br><span class=\"line\">        tr[node].flag = (tr[node].sum&lt;=<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r);</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r) <span class=\"keyword\">return</span> tr[node].sum;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r)+<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cin&gt;&gt;n)&#123;</span><br><span class=\"line\">        t++;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class=\"string\">&quot;:&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">        <span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">        cin&gt;&gt;m;</span><br><span class=\"line\">        <span class=\"type\">int</span> op,l,r;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l&gt;r) <span class=\"built_in\">swap</span>(l,r);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>) cout&lt;&lt;<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,l,r)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(<span class=\"number\">1</span>,l,r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>练手题：</p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF438D\">CF438D The Child and Sequence</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF920F\">CF920F SUM and REPLACE</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF444C\">CF444C DZY Loves Colors</a></p>\n<h3 id=\"离线的力量——不重复最大子段和\"><a href=\"#离线的力量——不重复最大子段和\" class=\"headerlink\" title=\"离线的力量——不重复最大子段和\"></a>离线的力量——不重复最大子段和</h3><p><a href=\"https://www.luogu.com.cn/problem/SP1557\">SP1557 GSS2 - Can you answer these queries II</a></p>\n<p>给你一个序列，求最大子段和，其中子段中的重复数字只算一次。</p>\n<p>显然，我们是无法通过转换为二进制等方式去除重复的，所以我们需要换个思路。</p>\n<p>先改变最大子段和的方式：</p>\n<p>对于每一个位置，记录其所有前缀和，历史最大前缀和就是以那个位置为左端点的最大子段和。</p>\n<p>之后考虑重复元素对答案的贡献：</p>\n<p>记在第 $i$ 位的元素上一次出现的位置为 $las$，对左端点在 $las$ 之前的子段，由于它和 $las$ 重复，所以它不会被算进去。于是它产生贡献的子段只有 $las+1$~$i$（能加到前缀中，更新前缀和）。</p>\n<p>但是，这样算出来的前缀是没有任何限制的，也就是说最大子段和的右端点可能会超过询问的右端点，所以要边处理询问边算。</p>\n<p>容易想到把询问按右端点递增排序，每次只更新上一次的右端点到这次的前缀和，再询问左端点到右端点间的历史最大值就行了。</p>\n<p>很多时候，在不要求在线且问题难以直接处理时，用一种特殊的顺序处理询问会极大简化问题。</p>\n<h4 id=\"Code：-2\"><a href=\"#Code：-2\" class=\"headerlink\" title=\"Code：\"></a>Code：</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">3e5</span>+<span class=\"number\">10</span>,eps = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,qs,a[N],las[N];</span><br><span class=\"line\">ll ans[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tre</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r;</span><br><span class=\"line\">\tll sum,hsum,lazy,hlazy;</span><br><span class=\"line\">&#125; tr[N*<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">que</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,id;</span><br><span class=\"line\">&#125; q[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(que x,que y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x.r&lt;y.r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\ttr[node].l = tr[node].r = l;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>,lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(lc,l,mid);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(rc,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\ttr[node].l = tr[lc].l;</span><br><span class=\"line\">\ttr[node].r = tr[rc].r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\ttr[node].sum+=v;</span><br><span class=\"line\">\ttr[node].hsum = <span class=\"built_in\">max</span>(tr[node].hsum,tr[node].sum);</span><br><span class=\"line\">\ttr[node].lazy+=v;</span><br><span class=\"line\">\ttr[node].hlazy = <span class=\"built_in\">max</span>(tr[node].hlazy,tr[node].lazy);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push2</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\ttr[node].hsum = <span class=\"built_in\">max</span>(tr[node].sum+v,tr[node].hsum);</span><br><span class=\"line\">\ttr[node].hlazy = <span class=\"built_in\">max</span>(tr[node].lazy+v,tr[node].hlazy);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].hlazy)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">push2</span>(lc,tr[node].hlazy);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push2</span>(rc,tr[node].hlazy);</span><br><span class=\"line\">\t\ttr[node].hlazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].lazy)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">push</span>(lc,tr[node].lazy);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push</span>(rc,tr[node].lazy);</span><br><span class=\"line\">\t\ttr[node].lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\ttr[node].sum = <span class=\"built_in\">max</span>(tr[node&lt;&lt;<span class=\"number\">1</span>].sum,tr[node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>].sum);</span><br><span class=\"line\">\ttr[node].hsum = <span class=\"built_in\">max</span>(tr[node&lt;&lt;<span class=\"number\">1</span>].hsum,tr[node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>].hsum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">upd</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">push</span>(node,v);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">pushdown</span>(node);</span><br><span class=\"line\">\t<span class=\"built_in\">upd</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r,v);</span><br><span class=\"line\">\t<span class=\"built_in\">upd</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r,v);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r) <span class=\"keyword\">return</span> tr[node].hsum;</span><br><span class=\"line\">\t<span class=\"built_in\">pushdown</span>(node);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r),<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">\tcin&gt;&gt;qs;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=qs;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;q[i].l&gt;&gt;q[i].r;</span><br><span class=\"line\">\t\tq[i].id = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(q+<span class=\"number\">1</span>,q+<span class=\"number\">1</span>+qs,cmp);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=qs;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (now&lt;=q[i].r)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">upd</span>(<span class=\"number\">1</span>,las[a[now]+eps]+<span class=\"number\">1</span>,now,a[now]);</span><br><span class=\"line\">\t\t\tlas[a[now]+eps] = now;</span><br><span class=\"line\">\t\t\tnow++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans[q[i].id] = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,q[i].l,q[i].r);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=qs;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>练手题：<a href=\"https://www.luogu.com.cn/problem/P4314\">P4314 CPU 监控</a></p>\n<h3 id=\"转化询问——区间区间数量\"><a href=\"#转化询问——区间区间数量\" class=\"headerlink\" title=\"转化询问——区间区间数量\"></a>转化询问——区间区间数量</h3><p><a href=\"https://www.luogu.com.cn/problem/P2184\">P2184 贪婪大陆</a></p>\n<p>每次在区间内添加一种不同于之前的元素，询问区间内不同元素数量。</p>\n<p>由于元素一定是互不相同的，所以等价于求区间中不同区间数量。</p>\n<p>假设询问的区间为 $[L,R]$，一个合法的区间为 $[l,r]$，则有以下几种情况：</p>\n<ol>\n<li>$l\\leq L,R\\leq r$，即询问区间被合法区间完全包含。</li>\n<li>$l\\leq L,L\\leq r\\leq R$，即只有左端点没有被询问区间包含。</li>\n<li>$L\\leq l\\leq R,R\\leq r$，即只有右端点没有被询问区间包含。</li>\n<li>$L\\leq l\\leq R,L\\leq r\\leq R$，即合法区间被询问区间完全包含。</li>\n</ol>\n<p>如何求解这 $4$ 种情况呢？</p>\n<p>对于 $1,2$，我们可以询问 $[1,L)$ 内左端点与右端点之差，相当与每个左端点产生 $1$ 的贡献，每个右端点产生 $-1$ 的贡献，这样就减去了左右端点都在 $[1,L)$ 内的区间，保留了合法的区间。</p>\n<p>对于 $3,4$，我们可以询问 $[L,R]$ 内左端点的数量，因为产生贡献的区间，其左端点必定在这里面。</p>\n<p>于是，我们可以用树状数组维护左端点和右端点的数量，每次回答询问时输出 $[1,R]$ 内的左端点数量减去 $[1,L)$ 内的右端点数量。</p>\n<h4 id=\"Code：-3\"><a href=\"#Code：-3\" class=\"headerlink\" title=\"Code：\"></a>Code：</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">BIT</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a[N];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (;x&lt;=n;x+=(x&amp;(-x))) a[x]+=v;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (;x;x-=(x&amp;(-x))) ret+=a[x];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; tr1,tr2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> op,l,r;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\ttr1.<span class=\"built_in\">update</span>(l,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\ttr2.<span class=\"built_in\">update</span>(r,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;(tr1.<span class=\"built_in\">query</span>(r)-tr2.<span class=\"built_in\">query</span>(l<span class=\"number\">-1</span>))&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-log-线段树\"><a href=\"#2-log-线段树\" class=\"headerlink\" title=\"$2\\log$ 线段树\"></a>$2\\log$ 线段树</h2><h3 id=\"非线性合并\"><a href=\"#非线性合并\" class=\"headerlink\" title=\"非线性合并\"></a>非线性合并</h3><p><a href=\"https://www.luogu.com.cn/problem/P4198\">P4198 楼房重建</a></p>\n<p>给你一个序列，单点修改，每次计算比前面的所有数大的数的数量（$a_i&gt;\\max(a_1,a_2\\cdots a_{i-1})$）。</p>\n<p>假设已经知道了左右儿子的数量，现在要计算当前节点的数量。左儿子的数量不会改变，因为它已经是合法的了，可是右儿子可能会因为某些原来合法的点的值比左儿子中的一些值小，而变得不合法，我们要做的就是剔除这些点。</p>\n<p>显然，右儿子中原本合法的点，只要比左儿子的最大值（记为 $Max$）大，就还是合法的。我们可以再次递归，重新访问右儿子的子树，这里分几种情况考虑：</p>\n<ol>\n<li>如果其最大值不大于 $Max$，那么这里面的点都没戏。</li>\n<li>如果其最大值大于 $Max$，不能知道合法的点的数量，要继续递归：<ol>\n<li>如果左儿子的最大值都比 $Max$ 大，那右儿子中的点显然都是合法的，只用访问左儿子，最后加上右儿子中合法的点的数量。</li>\n<li>如果左儿子的最大值比 $Max$ 小，就不用访问左儿子了，直接访问右儿子。</li>\n</ol>\n</li>\n</ol>\n<p>这样就完成了合并两个子节点信息的过程。</p>\n<h4 id=\"Code：-4\"><a href=\"#Code：-4\" class=\"headerlink\" title=\"Code：\"></a>Code：</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> eps = <span class=\"number\">1e-12</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tre</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,len;</span><br><span class=\"line\">\t<span class=\"type\">double</span> Max;</span><br><span class=\"line\">&#125; tr[N*<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\ttr[node].l = tr[node].r = l;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>,lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(lc,l,mid);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(rc,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\ttr[node].l = tr[lc].l;</span><br><span class=\"line\">\ttr[node].r = tr[rc].r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">double</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((v-tr[node].Max)&gt;eps || <span class=\"built_in\">fabs</span>(tr[node].Max-v)&lt;=eps) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l == tr[node].r) <span class=\"keyword\">return</span> tr[node].len;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tr[node&lt;&lt;<span class=\"number\">1</span>].Max-v)&gt;eps) <span class=\"keyword\">return</span> <span class=\"built_in\">get</span>(lc,v)+tr[node].len-tr[lc].len;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">get</span>(rc,v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">double</span> m = tr[node&lt;&lt;<span class=\"number\">1</span>].Max;</span><br><span class=\"line\">\ttr[node].len = tr[node&lt;&lt;<span class=\"number\">1</span>].len+<span class=\"built_in\">get</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,m);</span><br><span class=\"line\">\ttr[node].Max = <span class=\"built_in\">max</span>(tr[node&lt;&lt;<span class=\"number\">1</span>].Max,tr[node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>].Max);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">double</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r)&#123;</span><br><span class=\"line\">\t\ttr[node].len = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ttr[node].Max = v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">update</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r,v);</span><br><span class=\"line\">\t<span class=\"built_in\">update</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r,v);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(<span class=\"number\">1</span>,x,x,<span class=\"number\">1.0</span>*y/x);</span><br><span class=\"line\">\t\tcout&lt;&lt;tr[<span class=\"number\">1</span>].len&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"非线性修改\"><a href=\"#非线性修改\" class=\"headerlink\" title=\"非线性修改\"></a>非线性修改</h3>","tags":["Knowledge","线段树"]},{"title":"数论 题解","url":"/2022/05/18/%E6%95%B0%E8%AE%BA-%E9%A2%98%E8%A7%A3/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"f47335ec00c1e0cf247512bf81a29edeb0d37cd1f4c55d12309f479fe2209eb7\">7834362f950599cdb5db0897431343df3392469bb64c0a7d7e1daf9a788b03e117f85bdf84dcf851c3718bc5b3bf4149d4ffad7ca561ef244ec407d412eba0943d4568c8944d116906b6d4559e3dc28d34757a3f2ebc88a76d5e72b8cc4ac7cde0de1a23a173f3e33203046ad8242a9683a3449e693a1ef86da6dccf32e9e8e5b9c67497049851ed476ea7a7c02b33dce767cd9a85dfe430d5f4a761b3c809ee363720c8913bda67887cc744fb210933a8a0ceac9560ef15d583ffe503406c0daf4a67bf74368fd85345eff69fea7bce6958eb3c670baeb43d6983bf95064ba402b597602857b4db192d9dd3dd8eb0c08da87e25d39b31d4ed2ad6351cf92e0aabae272ccbee3e898cf4b274c5036122cd8ef257806bfe0cb7a2e6a79fe9411a16993e8bec8abaa65f8b76b1d91702a5471028e3d1f5ea6d288b64568d8d081d1e8e097156fa3a3eca77d2f1152fa6c6189fad7c0aa27eb18cf99ca79dbb7193135fd7c44c98d913b45bed0c51aaf80f38d14a2a62c6f215e7ef989abaf1671d330106394c8660bb408c7712f3f1d46cd934b7594559dc7c4f0ca0634b0a9f3cbd81edc36f7bf20364d619285c9541ad394d825470e15410f24c0ef00a2e17e0ede05c48edd01684d5c065f1a2c1dff2252244fc7b3ae4e98772d31041951725917106d691d9b294e7defb6c59e0881612a4f1e6fa2698fc5cdc2f3fe71daf7f0d2a7ad27ff1a65c95704f144b3b773f5b0a9fd5091f0a9ffa40d44dea2ec160ccba538fd903c857af7ebb8919aed7455bff6cc89cf53e8d15801be69ce9b31bbf48276e93a1850a1cef25acd96acd186c8e3402bed12e5abc91b2cd13ee85e29dcd4a3bfdab4df443fe1bc278d27c4ecca1c44d4a1b131f46cf326ed63159872f7201ff564dac9c5f23c9f1d5ac55034a43a4f5d6c22e3f583e99cce62547ace7ae865d3300c6810c1b35797760ee963faf2151548fe19f07332ccad0ba7112809301ca3f963324ee960be77945bd087dd11f662c22771f4321b1e2282332ad46b171757950a027652ce2abcb416c83edeb084dd518750c85116146126b8bdf2d58ad4819837f0098b7e886c392f931afc0fcce1e4d19071ad0d7ac93e75f755bbdb8550cb0ea45a87e7b2823316fcb9c6ae069c2312b8b4189aa6101d5254f32065b2f351c084ce1b0d10f89d0e1642ffda0d02fef38f205387bde99c27def5c78970e9696698381f567cf40972e597f90245db91c821ef67823a8428494347c2e9cb4d5275ac314590128937ee2ee19f54ae010029a6d9c7b2e16dfd77a9dccee2be31953ec00f237adfb589eaede06ddca02ba7a6c0a1732b4bc9bc48299bcb0a856026737c55ddb28a46b47c15b4fab68ae104c349fe5c21f1e064903d7783cafc83a96b5039f81c19d72c8cc711516ab463e90e39472d6890ae2110d609b055dca029a0a95e1430d18bdd23e6bfb1623ff15cc579116df1209d21d2b6c74fe0e60e86abcd36cc28c46c894960acf93cf9e23097c837952833725060788adb38eb8bf369962b710e4954cb099776b3aedc2a8766d3840083d2e5a3e05a117dba490b4f7257d9310246240ee00ea7bb079f28c2b0d4333a577f04a2a9836aa9773f3df95e60cdfc82d355c2ff021e8d7150dc6c63920048b1e837d2542dd0fb50a6ec4e0805746130b9c73aea6af5ba5a866ed8b7d03639ada9fbe24ff506ae8e39e45161609df05b966a6927d5d46862dd1c129b792c9f5ffbfbe9634d4fd93600fc45ac086cd2e415b3ab48888ae0a41b29dc7cbaa512826b7a12c2c67c7533bdb8087adab22f6dae95459c5e0852d6e08e2d37145756f807a9ca501776986a697151182263be3c81edbb5f0dda9f3d5937a56eb2cc4dd529a077d1bf2ebca9e0f0c4405dcf7752fb394610d65e45748b308b4b05cc73f22b88205262189eae87aa4d9c5318ac1005d13e2e1a9cf86509727cfc3e57a5bb4e32d6abaf97193d9407902ca350c7b696633a4636fbcac15edbcd48f3f3525c5123458909fc15f56e2e24c52d8bc225ad2cfd2dfb8fb6f308cb22480e1c6bcf2a3ff2c45c3e5922fdf81181e9f4417b0d878e5520e746b0cb9ca50aa5d0606d1f90638b73816d0d7e20239445e1a61e8d6257ba574cdad5a57454f78f9e00172728433ed2d9b372e9c94470e7932dad7c92f21f6130c3b61cc9fcdb2cb7930bd624f1816a7c4651430f353d98291a149866070762926cd3470cfe45d7f4a947ccedcfe83b1633b7ef034cdd5d9d1e8605874b52c1f65f7da5038a2a2d7778c385d03b516090ee638c2465bc58e176f932ed82537e2adf68f1dd16a38e90765ccdd5cd5f9fccab540dd23a70cb7f64c415167f1640d7cefb637452936303f9cc70b2ef01a540f7f2dfe5ba3810b11b21c8b96b80282e1705d1370d3218ec6a34234efe7d3a77723cab55c512ad52b67cc0c4dbcbde2d6dd66790c8fc5a4387cbb67c9d0e20b700a6abd84b7ee43273dbf61063bb2eb0dece71301362eb712f6b369019cd1937d4d634a1b7a91a5974e1fed9cb20872f07493c721d0a9215f46472731a8e57a95d8b63b7aa50c2bbdf3c59acce0e261a9f8b249c44e38ef3f3888cb8b6465175b8b2b5daf365b97b5bdd2673399f1f88e08f706314d5bfb60de94fd6b150325f2f5b9b96064d92e766d528e03a7e5c2c135b843e4013cd22744c978d748b133a960c7841d104d0b500d71c1c1c033f1cbecdda384779ffc27c6d483d014888e73912a72f5f647475241fbd40058b8ac42dc287026fd3ab441c2995a66e4f5f1f2b1088eec493e50c0c4f88799736d9f2edb10b9fe86c6c3378ae85ab0a2acd67aea61b3b120eaa435289f6d6036c4085b1ec47bb9289c4935844ae54fd55d3a6f2bc9392be50ee48706493b8dc22c8895202d4d1519b6fb2956fe396cd49e213f17e5177ceb2cb529440463d9d881a130552457adccee8f6492209a633459196345d38951ec11a101f51e8f5113a078eabff18c8270d5be1a66e6cac8f45ff7f153a22e60ae81b023470f33e6841fd88e0b4be47db8bcc44a5e5b5f9ce435b687cd2a23d4c997cc89cd5da1740f078f96cfb7ca9269948016d5d011a352be3d18e2b07d83904ab1c383232d1f3946e28928fbda4d921702558ce4f606294a2b6359ecbbd3221ec2b1b0fc816916de9320c0334f3cd240d8e292df6d3827e532274adaabb5f10b8386b832fde830fe8ace6e2c9c09ed73cb545a804628cbf751bab6e66f905d7eb443744e065c976fac2f2a6133e3e127744a7d25a030bd716b667df98fe24dda3b35546701f3bdaec743f9d65629727625bb39b22a0afe4b7f6119f71b8730594269fc1db8a039ddc5ccf0ece6ad5c5c835f209500294bbfe05ef8bb77b1c368a205da0e95e55bf49acfebbbad9154936a30c43e33bc7aae4d1d58501768c878ce1c8a5fbbcab999d8814a45ecedd8887c5305924091f6cd3262bd2878f3c5d8732d9e81211e52e4da5eb83a4de4a6ba59b549b3dade5b2d4b6a4a52627a40825b77c10122d77cd2facec61412d00301ce9f4e37b16a53551a76e8e17c38dac81c2b390e0566977d78bd004e7bb8a76e84c7c2aa30d4c5d1b31493d8a49729a8bc83bbd0e4ef1fb2bf2988d8a11f294a7f71efb54418eef68f226c5efb666eaced89627c56087330c72be45f5f730473bb9c1050484cb670864695bda965b640ccd4af9b0384f4fa6a443631495a9fdca6845a112e09f37ae14e0031522e210cdc7fcbd31c4174f5b1d0ddbc4236a3fc11b20c6240ec9441a56fe9a545df90ba87c697bda0bbed8d29e9a526e164f3993130408c40f92f400825131ef00f7cd65faae8b663bbe308019737d726da087ef24e38393edaa893f5a97d2242ddb5e33476bbd8e881707502bec1e8e105ee01bb6f2b1772cf97c57cd2f4ffba835b6109a2a2f1cf3ef3dcf6a646374e3d62fb827335d2e9b92d91aaf6fb7fbe64bcbd2d46bf5f29fe19de911ff9f65111aa11bef71ba6124a97a48b11ea309a6a2215320734ac3d8fc2152963d6d27d2d49d9dc2d0b2ce86e77d053cecd367161f34cf3f547731d4c2c2ead6793883880a7b6e99bf9751641bd4d17afa2cd7ec9920c378e23e9357e9f93c9419ebe27d3400a7e797573aeb83dc65fd1545519b3e5a178dbdb045c07f1729bb369630cb83d9a3010e8eedc04518fa048ee2d12f830154971b9f2b6461c11946e7b936a7f8639e0060a40ac0d3be851d0cba0ac9c37cbd833d1e51ccb2787963875909de639ee74400c6a0695ca9959a8f4da786b657a3a3ae67f197fe5f8c1a6b9bf59134db770f3d392b3e688621ca2199a17dc13d273052c656db619a2d128369e9f8b04042e8d303464c190c5abf7be31a67944a3c6e3abfe6ee587115783780bd4ee005dba885ec7b332a12536e3f56af1e04dd179b1308299e9017a55f73526a0c41cb7674e43fec74d6c36fd3ff6f23894176d822f791345f02be4e3632613fa552d8f52637bee35cfdab3cfee9c56fede09736f19a6a06157e6123a811e37a89d36c35fbb286d91f4c0857eb9182ae400397d45724778b9dff176975fc1fb2e2fb154d3aff3dcd6eb0942ca5038ab80e1ca45ff11fc99a1bd54bd9e3f239b7e188cdb7ebaa96b1f6b6ddb6f4fd9ddc50a7e8eb16bed7c81b875afe3e61fc5e51a3d979942381bfa3c6d12bf9d0fd2271c2f0ba54ce92cd2ba62ce351dcdfc292c9b56823a1fefaaa7537e5702ce71bf73da92757e663cac5099bf558c1cd7ae7d94f97cfec638021bf3bba2a6170c8cde42a07e947d25778ee7e3d284e200a90e85dda5b5d0d94ff8a50b177e5f18938dc186c0e5930ceb4fc236de63b1858468f6fcaffeead48163563bc39f83ff1c2fed9588289d0c445468aadc8b09163f7d6d13f83d0717b36537672ee05f55f0482e28b8e14ffa7ac68f445ce62c9dbfb49b073915cf02a3c4c62c3d0c00c449b13bbc3f07e398eb24d4c745ad41b7e9c965e047fbdfa1cf2e30f1d5099f315a6b191220d3d1ae7cf0a76a52574b92a919360e196954517b656383271105c993ff881d751c5d8b31b3f2525e2c280ff651d4a1f500c347ac11a661122d2ad1f7ae4f30bf9ca4829557b0b555b6054ca69aecfd6181303107ad57aa7d43667cf64800bc2830fc8ebe2c4421b70db21699845b1e203a7d91624a7523931ee7aa9be669fa23429234f914d26c7e325016f022072057d585a3f9d9aef639c35e0e8b1826eb6a965dff6e304b10ffa00c02fa91894b52cb8fbef7a9b60dbba4220325f5dfb104830d9d9b8392a6506c2d80819988edf6fef37fe7ebe7b59c62132f8d46de1d923ad4e5b5de9d433823434e07c2dc05bef318c30afbaecf0cf1dd48cab3d4574225c7f8a24e792868ddcfc06bbadc649e3cb77587d1b233f176cebf3bf3e15c4f1850a090b1c637be6d51d2bfafa8fb5232934abd83d5a94a141de01f126f85c75ded62cb4f0fc6ed7e53743d5f84ecf050823bf7e2fa17be674561aaee94743009d080eb60a3ccbdcda62544f6b46ce441f70a5bc8956edd9335028d998f02f60511377dd377037633d139160ec196533a4e723c62c70e3356bf2b3c3402459a6f7ddad25c61dfc08faea0ad21ffe50c2098b457b9eae75d4057a77040e69864e49ba7223511a8522dd71d392f4f615579e4aecb88a9d84f4d287d7a2001e816b32df3d50417f8fcd3f92bfc8dbfc39caee48bb61747a06923c04c0008732eb9879098aee0e091e79d33bc72192628550c42013b58b9d8f3d13c180553fa84c878a18e07fda217c37a76fcd1645541e11d79e23d5a2b292369e7b4e15564c83569c8df0f57034dd13458c6dff796ad8ed35d7e45054d278c0b96ff3540814995db47f16ba5a3812ae67b8813c41cc79faae6cca2e3c956851c900d73ee6fd1063e8bf25d48fd1bba7e7b23bef148f57deb8be91ba1d39b878d43228aa654b3226aa9cff5983177c480022041fb41fc3e7e666227c8dbd8c6e5bd684617d5b5b4289a8be07872eeb6d10f231718de84eb6fb133b8adee5f4be9eb7165897c4e67dffff7eefab890076557b4209305a6a1479d3a98a786202185221294fedd9aaf1bcff38d56c0b1b2c79c7c5628ab6ee98f49233320a21f4866741f4d38bb248b29067f6b7673ab1888b4c64a54333e8d6ee690a25da91370925b7bb551de1dfd5def50183302aae4fc2aab03583e52ba936ff9da261488f32300af7e6408af918d88fb78724dc20311d281d3e9a62b2dd0052c7de4650756f1e08f5b03f4508f109f8bf3c8e7874b7920dfa4a8baaee5afe5acd8cd8b01c539462e0259b953a5b053ccb5219afec82e9552c970e1ec6726c9145790ec92dbd279a86f1eca0d8bc6106f552513aca8b9eba22cf3f67769b72a12ba6d27a36a7e44947c2f9ba65ab318057a833f33e91677821f937d71e56cdd19eba35853c2b15c922efaf1756a5b88fc7a1485bd605387f64094017fa65cc6b5efe7f49cd5aeea3344573b415b133ccda5a25c73317021ae5305da2b3c7c6cd1716a4c58bb7e526febb57cd0dc3ce30a9ad00106a604a1ffbfbef4b7c94368b3aec29dcc7f4660c8812a55ed01b31eefdf7d56f41d1c88b569f678107f5c58031282e60759b68294a21fad20b80870062ce56beda10a01a72d1bdadea977a431d7bfec0b9ad06729803434e591a8990553a266edb4a3a4abd30f2d17954d38baf476d00314f198d4c9208efc36595aaeb728fd488daf44805601d36312f3cd81093d98abc6fde43651343f53cb06e7926dcec0ad7f7bef0aa99b076ee277c7186f0c2f8be5e9bdc0ff5fda0ea7bd296945ade4241a5ca2b2b079eb09eaf6f5914a32a063873b54fc4678b28b0491460d4e12569ac1ed7796b6d5a102d3a602ca6acac4e13ebf4e8ea14114d010d89ff4d7b1b648fef90e20d72d2706a62bf51f41eb44c1f1cef0c6fa1c07ec26299471d9c9b7be1e441efd5c9791a3019e2e848063a7b20b0281a66e4ac5f4d3019f9f43bb31433d9f3aff5dda82ad5ba9f4b2d9a7db3652b1b36e8780cc6f5ba87f5b5674b807fdc43d1e12d04b78a55d63ce3c343d0827f41918a9d46cc217812702a13c47a32879e32e745f298e139dde927e5498d473aef003dd887f43c3f6cc8d5bee490a37b1f510053f6eda6be5f2cabe943e9847ce8cde87f8c1c3ac6a043675ea8bf011e4dadf9ae3c10160dfdb7d8c47d953fb7c643b100cf93ddd99094c671e6c2c6115de12e1e4b290de7b921350f90e6efb2da70aa0802acfaa00f2d6bb3bbb8246e928b97f2b4c14b9faab100307570e7347311e673151b3549bf6ed3631b7eb61692b4fdcbe1d3acc00c824bdd86dfe485593226610aa398f41b599e16b3db1183059f39f4bf8777209016473614d837b9d950f9a6ead3832c28abc58dd449009a542048fda6959e1964401438a8d42fd66f59390a4d434025f9d0e293a779ddf0892538ba6581f2001f48dea79977a66c34f20a2dc068ae2acac8d5587f297b9bdcc5a6a64e10da0a2ac268f0ec19794a2b86bfe9de8ef86c259ad3caa85749b0e1639ccbef42f0697007375d51c94ae1cfd55b26dd62a326635101dc9136ae5a9413066e0e7468fd9e075b3ebd1f32870f16d48580908539a733c712bbe73bf8aed38740d5e164093d5f697722182182c7ce5b857ab9956ac38c8e50c2990441664df5e035576de26dcc8ce634ef99f06cfd6a750e4d1dc9a4319f16148e3f0ff62628a3aee920d5c6ac4a5d6bf95d6690afdd7265eefc7b1dac5dec5ac5137a4154b5d473922203d787c9c88963efc184696a022f2ae0d3a7f8517fd08561874dcafcef3c93ca334e2125e7d86fe4886322d0366f8c9fe8081eed69e79fdef9e6c553a4555b7c1e2231fbdeb539b084db1c5bd5d2e337cf12b33198c0c4b412f4db3139434d9aee35aaea1506ae1bc0d3ad781d9910f4072b5cb79274ddf875376200acfc49c2084c6c02f18289616fb4c4ed5ff8db165e068ca575e0d2fe3eed1712fda6ab9b622be580ba5a445d615264b36c426444460b01ea7ed6a21c5d6d6c993cc9e8b38c0ab6646d0d417ff792604ecb17d92268b3b70987bb7c46b4df6b428a055059581d2b143a2a8cb3dfc49806fb3029e2b4d9c16ba5b94f43500576390c723fd3fd666ff7df77f7395fa3ad3e1b554ae240def055a1461eb07b1d4744aa984484ddf5d9413a0008fcdc4dc8fe795ccffe07590393bb56a16126a1407cbbed38c7d2ba56f6f03a640104f378da22972d1b60512f5e6b44743061c25adc9225db3690ff622b5e6672a700f4108158dba2744db5e8631ede21982f3f8907dea2f94bff6f26096f510924761509b6c8a00bacfec865c755ba33eaaaf0060b8ed210a699b4fa75d2fa9f55cb0f23595258c5a6f6b667f6462837aa0820da368ea4a72258c05272f207bff6f18866605b37fa22898135383d915737a6439e0dc5bb145b0e8eb8111071119d6884b59db97f830b2c7c1c3cb0cde2798a6f44cdb60e0c6554c63c4602fe4a46a27511764417f80b54f4931f1c7acc7922a1bf9ec89a12ba21145f5f492136e01dfeff875b108898693acec195f6e978357bdbfb3bab11fad673ad11e4426276c1f7af76a79c5961162a5f65b214f3446776ca509b85ce94c3c8f048629b4a8fb7c09e3f9ba6f9d286adefbcfbd920f9de8899b2a771b7ad0c6743d9b37b818ec93059a72ca0e2e6fb97d52da480d36123edddc55f29995c68c629215debab03c206aebc412909f428e8b7c6b13ebb31910b7693d1986d107ff346b9f7ad810627a106c19e629283462d3d0f02313a5120304153d50c9512ee5bda85f9e333128daaebf2cca8182db785d26d7abecbffae78a2c9890633c13948b5e9f6f015dd1737889cd411fe2a8e30a37f925daccd5d19eced0f688e8e2e10c9b3c45c8807900467a9eddf0c8d75becaa5a61dcf40da10282e6584fdabdae375be640d15434acb943435a38c4fe33636bc150ecae2f7e3af2e18d43de06dd50ea4d787ce814d7b72b110d28231aa53f0c155e97a224b24f28c69b5bfb042769cf86afa31e96daf822fb6c31b18cc75d062f9ebb7d523ffb3a12f3c2fe9552354d8329905ab3d930e7ae2fc50693ee7c4652a1e15889b78bb11756f76b2ed3b124990d7b40d48858047ea7a81b2b1c0ccab81733f9ca97f8b830565ba231cf96b9920f829502f99a138ef0cda986e9ae498abe80a6ea2896b7c2fed2048663ad309be57ea432efaa90409cf5e290a12b975a13e125c891a00229c368765d78fb14b7e7b26219ec25c890a5afa09d73996c3770412e6059ed3ebd938ff6a90cdb2c0cad66689ffa6d0b9b9e1a288a575e27a3e4995aa38e6e261524efdbc943f00f64bc5122618d43c1076b9a5200a91e15643090ce1a4297861f683db493b24c417c730f56ab74432d82e1816eafcea30307412048265a08c87c23bd0a57cafa59507e68700ff1d33aa7e2e29857f2637c86a93958d152056f12f7da87b29493f4b93d24f7c26633d1cd299181a3124df7819fb4a2669f24c866e27619838f3089ad82987d408e8c21053428c4a9cd79a037da0907d68e0c458bf263dea162826f96cb37cb5edd45b6e9a2a0922f428c1a7cb11a78ac9127d7bb27657008b498d17cd70f8c544b0cf985e8b361b1b84b7539a88f8bb9933a12d1ff15cf981d531e02af22ecc24b825cea30a93b149910a2620d7337a29a6306d91bae6540d186c4c39a771569c68f36b4f8cda4ffa308fcff524b5aee6735bef8fb5dc71ffb9ad69c9880ddc90f7e9b3d5b3941e85f16fc0fc2be658d8217eeab920e5d7b2dddc03cfe0c67660dbf549e27036b507c168794dfaacaa56815dc7ef90dadd3fbe008dfb4302ed3d125979eb2f7344ccd6ecbdeca5efdce570d7c4a22b99851e61e5232d211c83848115da0c9e6475cffb81ae5dc568d9c50d21ef87d384030c732e0c0d5634d8d396d54bd74c06fd101b8b05807c21017f4899d0f09430958ab0a0c6f9666fe02a525b61368d858ed418df93efa4842aa2e0da2e9fa64eac4829c4d4afe94c79e375277009b0e29ff34185a85fc6e5abfad6467890c1ad430f36f6e043baab90e6b2ceacc46598f372d08e6c4ec1ae7ca3efce7bc2f73eea1380d4b1c5674cb027a036f6650df57a54609a8fecd0bd342e164ff4d684a64c1ef3a673188221ef5e76b1067e311f5419ee341ada3bb2a45c7abebb4180223e1b41a5e052e211217d1ffa934a05af6c1240600ad2bc544ccd245dd819ccae229978709235c5b73a7b9c83b76882cd8be8d67b28a6b10c3b659c9d38c050fe8d9e14aff40eee351a05d34a398e1dd8995ce6064df44e5ec2e523c84665d2a34c40ded216afb38ac4a513d2ae3281936c923e5fd3cbbde3b0674aee0c99473c3b729d39212092573c8a2c5a04d9ad5961ae5dc508b93320ad5dc1daa7bb32cf0cdd45e7a814aba1fc13f5c2e2111357a908c9b736bfd4d78a2d8d899e398d404a25b66afacce2b5ee2eec33f52c7bb756d2adffca9b3545ec4cfbb7f48986e39e1fc08f0f417dc7d3e116715ec0c38b4ff092faeae70710146e680c29ad96acbe3974b76cebb4cb7f221680a38c3bc952f5b9b9a8ab1b81af3965cb20ae618144566231b1b7086db2cd62c4b4267c9c42c3a1fa2e21eab37910b9f0a5bf320e82ad5515bc40f3f9560aae08373773ab4216149a1bc53ab3a2af9354c736ef44d6e0e5e782d4ad6181e31c77e141c8f5245744b7d672505912342352937822339c1f6c33dc2267214c72819cdb442c6b03c676de239c7d20b94742e2e9368cb1acb155fcc01bcb4432931f6f69c9e6d8b5387e4d48a4538c7a684ce75255107cae4b8f1e43d0af470afa54f4ab93d431b1030e2c42fd2731145acc087591babef9f404697ff42290bbcb3149dc584abc0de0e6ed6a947a2a2bef3ee3d1054e2649366793f18348f51cc83502d1d67982704b7b77cc906421c18b68f935d1273cf5e10b3dfae7f0644148135569aaa0f1c946e154febc53369871117b98c27577341222bd897ad2592a38a33e7426f35eefe1499f075f9c65eba55337fe87de7a99f7b6af2a791af790dd7b2c2667ffe572a42a4ce1ae1bb12dcb564a85fde60f5f0037be5a6b6acd7d8e289dd33cf3308f4a2ec17c739e3ee52ca134fe293e158da13453fa1ac2a54c52c9ed7fc99be49839a14ca78999c04dfa97e34014114228471e58ef198c4ea873f81d0eb7b90d3dd8e739f8b2580bbdded69232af851d6ef558d5b7252260712dd7a64b4890f9b79df154eddf45a75435c948a388065eaf526206dcc16b2eb81fa9cc8b41b6d3c2e01a0d952986cc7ec43d3711b2d1ccf31d5d0eb9f1b293f9066427ce281ff718be011ad762f25f53ed508a7dd77f3547f9ff8ab1fc26e972e96b24367dfda405fca70ad9e6555b6add308b591c18a49bc21bc567521822607a94b8915fc4ae2d72aa84c102e30b7cc7c26589437c0e6b8c708e66f22a56772677c3e3cc89e3ec84b8ac5d945f1b6a49a845b34afa250c5cbd9cfe3b321d398278da8cb1cd825f67c89f01e1abb5c23ea77ec7bc131b6d7e47cd090a7af5b5895b689abf85338d7cad91f19b4e85fccab4bb2ae7952805ddffed14b1f34d6ba49eea1fb733051c40100dcca180231c50cc43575c099ca62173b76fe82b0644a500c7899fc7977c4e7dc930d54d44c2e4c7d9ccc92700272c1d48b6be8337012a2c2b6095b5b22cf21d63ed22621c1c2566e0dc6117fce2226425581b2d94faa37ba919d42eda7e86b2b206974752f7a789488d60eec9c125b63498e3125f8e6d38e621fa10fd87cb54a97d40cb4273ac4833e258a433eb4cff25a0defb65ab2e6bb7479c99934e8cba7d07ff46735cfcc200ecde28357ea15edca9c78b5b57724ea631fc4916d0f3fe27ca05e2a5c630857e641c5c631962f8d0380480b6b79ac1ed7eb218de6140a3cb8a0bfb232ca4eeec5b59ac72b6dbfb1dcf62b6a239b38bee4850b55116a34bbccdf3533b7cfded4385a00a7b426596f2d6756c7e61cb6102e678bb5f04f910eb468b011fb4f47a8b068097478ad7a887087e48dee389712327b531745d374d3228a48c5a228a75c4a42853c055cf2e7cd74ab33442253a6f1bb2203d8642d52682c160ac19a4a40ae0f3d7dd99e6982eaddf5d076045b0ffb14213bfca4d9d0540be30bffa8cb0ff458b907a7387cf1f2764b76393879c1a98353d846c2013ec4092148824003c5f230c780a613328fa2aceab977b1967d74431e19b23abd9d131645194387c7ecc92153f68568fccea6e4bd6cc364675270c5d65f497e6038efe701d038bf276d930bd59f3504f8982acc9ac21f2b630ec28c9a8f68cf1837aca5822768eafb90f6b0600c9017c5a669743703aa0e0087c67fee6f65d7abef2d88aa28d8606e4ca9fd5bdc18646bf767d37693f18f8f4e340a40325753412ef4d6e562a75456a019a4605c3c247a60276d6eeeed2e0ebd7c2aad3f8ce00c2f062c8c9537ea87c686e9ac436f3379a795377a30bb3a961462b9d66bb380381f7d4bedaaf10940aaa76ed07470670045318da0a20ee3cb2490e7e331cd9ddc7a04930244e8b70766097b905020a697ea04f3793f3212ec3a48971e71bc86b3edee34ed51933ea91a7935d3e558bffcaf3954fa4cc56144554950e89a6b0cb78c5fe9be7b5a91983046ab8d34b4f2c62f20d6108c965b2db26a83ed5c7fbdc8e63e07c0ff5b21b77fb564684037bb59144ba891fe461787484955aab96b74637ef036b5d823d360b17a0eaedf1f78ce99862013426e9c100bd5f8db2890a4c61c4802a3d864fb3706719fe1a04311853ba9a23bf23e1853a4e01d1eb8aea6b4866824a394b22a0ba34437591e8bf1eb90a66a3cb4d844d5e9eef1c7acd2527c0973f927992a3194cfd87078f1a644aef61116822a02c28d8be3cc43aacd46641bf1c4b946bb1efb22b26134618bcbf138cbc815ff12567e7dc7f9b222a9179cdcf17e757900907c9ba7c97689b4fde6afc672edd29dacc7b633b629877e97591c979de9b55c81c766581750941399c8c51237c37546cabd1d1950762087117490ab728f67bf3b0fef7c1f2efcdcca0eee9b7d990547b1034d6670a6092ee0fb9780d621490f27672ffdddba24eab8f8135b13e6036858</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">输入我在2022-05-18 23:28:12提交记录的id</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","tags":["Knowledge","数学","欧拉函数"]},{"title":"树屋阶梯 题解","url":"/2022/04/12/%E6%A0%91%E5%B1%8B%E9%98%B6%E6%A2%AF-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"树屋阶梯-题解\"><a href=\"#树屋阶梯-题解\" class=\"headerlink\" title=\"树屋阶梯 题解\"></a>树屋阶梯 题解</h1><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>最开始，没有任何思路。</p>\n<p>于是看了两眼样例，猜了一些结论，发现这个有可能是对的。</p>\n<p>结论1：每个长度为$n$的阶梯都至少需要$n$个钢板。</p>\n<p>使用数学归纳法证明：</p>\n<span id=\"more\"></span>\n<p>当$n=1$时，需要一个钢板。</p>\n<p>假设这个结论在$[0,n-1]$都成立，我们需要钢板的数量最少，就需要搭建长度为$n-1$的阶梯的最小钢板数量，即$n-1$个，而新增的$n$的这个钢板最上面的一个方格是不可能被之前的任何一个钢板覆盖的，所以这个地方必须要有一个钢板。其他地方的钢板可以直接让长度为$n-1$的阶梯的钢板延伸过来，于是只用$n$个钢板的方案一定存在。</p>\n<p>结论2：我们从右往左看，每次都能在竖直范围内找到一个新的钢板。且这个钢板必然覆盖嘴上面的一块。</p>\n<p>由结论1易得。</p>\n<p>必然有一块钢板覆盖左下角这个点，而它必然覆盖了一个顶点，我们枚举这个钢板覆盖的位置，发现它正好把这个阶梯分成另外两个部分，于是这就变成了求解子问题。</p>\n<p>$f[i] = \\sum_{j=0}^{i-1}f[j]\\cdot f[i-j-1]$。</p>\n<p>这个东西打个表可以发现，跟卡特兰数一模一样，在oi-wiki上也有这个公式的介绍。</p>\n<p>于是，我们的目标就是求第$n$项卡特兰数。</p>\n<h2 id=\"Code-：\"><a href=\"#Code-：\" class=\"headerlink\" title=\"$Code$：\"></a>$Code$：</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>())</span><br><span class=\"line\"><span class=\"built_in\">sum</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">int</span>(a)+<span class=\"number\">1</span>,<span class=\"built_in\">int</span>(a)*<span class=\"number\">2</span>+<span class=\"number\">1</span>,<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>*i</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span> (<span class=\"number\">1</span>,<span class=\"built_in\">int</span>(a)+<span class=\"number\">1</span>,<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>/i</span><br><span class=\"line\"><span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>/(<span class=\"built_in\">int</span>(a)+<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(<span class=\"built_in\">sum</span>))</span><br></pre></td></tr></table></figure>\n<p>（实在不想写高精啊）</p>\n","tags":["Knowledge","数学","组合数学"]},{"title":"树上启发式合并","url":"/2022/10/03/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","content":"<h1 id=\"树上启发式合并\"><a href=\"#树上启发式合并\" class=\"headerlink\" title=\"树上启发式合并\"></a>树上启发式合并</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>对于一些难以转化的统计类问题，我们可以用启发式合并的思想完成子树信息的合并。</p>\n<p>步骤：</p>\n<ol>\n<li>访问轻儿子，计算它们的答案，并且不保留计算的东西。</li>\n<li>访问重儿子，计算它的答案，保留得到的东西。</li>\n<li>枚举轻儿子的所有节点，计算它们对现在这个子树答案的贡献，上传给父亲。</li>\n</ol>\n<span id=\"more\"></span>\n<p>伪代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> f)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (u in light son) <span class=\"built_in\">dfs</span>(u,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(heavy,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (u in subtree) <span class=\"built_in\">calc</span>(u);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!f) <span class=\"built_in\">clear</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>考虑几个问题：</p>\n<ol>\n<li><p>时间复杂度是 $O(n^2)$ 吗？</p>\n<p>其实是 $O(n\\log n)$。因为根据重儿子的定义，它的大小一定是最大的，所以其他儿子每次合并，所处的子树大小至少变为原来的 $2$ 倍。所以每个节点最多被访问 $\\log n$ 次，于是时间复杂度即为 $O(n\\log n)$。</p>\n</li>\n<li><p>为什么要先遍历轻儿子，交换顺序会怎样？</p>\n<p>先明确一点：这里的统计数组是共用的。</p>\n<p>如果先遍历重儿子，根据之后我们遍历轻儿子就要把数组清空的原则，重儿子的信息会丢失，所以不行。</p>\n</li>\n</ol>\n<p>来看一些例题。</p>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p><a href=\"https://www.luogu.com.cn/problem/CF741D\">CF741D Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths</a></p>\n<p>至于为啥这题的名字这么长，你可以去问出题人，他就是树上启发式合并算法的提出者。</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>给你一棵树，每条边有字符形式（a~v）的边权，求出每个子树内的最长路径，满足边权的字符，每个都出现偶数次。</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>根据上面的思想，我们先做一次树链剖分，求出重儿子。</p>\n<p>之后，考虑我们要统计的信息是什么。</p>\n<p>如果一条路径满足条件，那么出现次数为奇数的字符个数 $\\leq 1$。</p>\n<p>这提示我们只用关注每个字符出现次数的奇偶性，于是可以状压。</p>\n<p>一条路径，就是两个端点到 $lca$。那么确定了两个端点，我们就能 $O(1)$ 求出是否满足了。</p>\n<p>具体来说，设 $f[u]$ 表示 $u$ 到根路径上的边状压成的二进制数，于是这条路径的二进制数可以表示为 $f[lca]\\oplus f[u]\\oplus f[v]$。</p>\n<p>之后用 map 维护一下 $f$ 的值，访问轻子树的 $v$ 节点时，枚举为奇数的位置 $p$，看 $f[lca]\\oplus f[v]\\oplus 2^p$ 是否存在即可。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>一般用树上启发式合并的题，难点在于统计。</p>\n<p>例如此题，需要发现可以使用状压存储答案，且可以用 map 维护是否可行，才能做出来。</p>\n<p>而且，由于统计的东西在上传的过程中不能改变，所以都是全局值，是固定的，这时候就要想维护它到根节点的信息。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p><a href=\"https://www.luogu.com.cn/problem/P4149\">P4149 IOI2011 Race</a></p>\n<h2 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h2><p><a href=\"https://www.luogu.com.cn/problem/CF600E\">CF600E Lomsat gelral</a></p>\n<h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>给你一棵有根树，每个节点都有一个编号。</p>\n<p>一个子树中可能有多个出现次数最多的编号，你要对每棵子树，求出出现次数最多的编号的和。</p>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>容易想到维护每个编号的出现次数，这个可以用一个桶搞一下，于是，我们已经有了要统计的东西。</p>\n<p>先依次遍历轻儿子和重儿子，现在我们知道重儿子里面每个编号出现的次数。</p>\n<p>枚举其他所有节点，加到桶里面去，每次加的时候更新一下最大值就行了。</p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>比较显然的一道题，因为不用在想统计的信息如何存储上面花心思，直接用桶就行了。</p>\n<h3 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p><a href=\"https://www.luogu.com.cn/problem/CF375D\">CF375D Tree and Queries</a></p>\n<h2 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h2><p><a href=\"https://www.luogu.com.cn/problem/CF208E\">CF208E Blood Cousins</a></p>\n<h3 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>$q$ 次询问，每次询问有根树中 $u$ 的 $k$ 级祖先有多少个孙子和 $u$ 的深度相同。</p>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>由于答案和深度有着千丝万缕的练习，故想到以子树内某一深度的点有多少个为统计对象。</p>\n<p>而且，访问到一个点，只能计算它的子树内的贡献，所以考虑将询问放到祖先身上，这个可以直接 ST 表处理出来。</p>\n<p>假设现在已经求出了深度数组，那么如何计算答案呢？</p>\n<p>可以直接遍历在当前节点上的询问，每个询问都形如 $(u,dep)$ 的形式，则 $u$ 这个点的答案就是 $cnt[dep]-1$。</p>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>重点是想什么信息是全局不变的，因为这正是保证时间复杂度的一大要素。</p>\n<h3 id=\"练习-2\"><a href=\"#练习-2\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p><a href=\"https://www.luogu.com.cn/problem/CF246E\">CF246E Blood Cousins Return</a></p>\n","tags":["Knowledge","Notes","树","启发式合并"]},{"title":"树网的核 题解","url":"/2022/07/01/%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"树网的核-题解\"><a href=\"#树网的核-题解\" class=\"headerlink\" title=\"树网的核 题解\"></a>树网的核 题解</h1><p>$\\color{red}Status: Unfinished$.</p>\n<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给你一个无根树，求出直径上的一段长度不超过 $s$ 的路径，使树上的所有点到它的距离的最大值最小。</p>\n<p>其中，一个点到路径的距离为点到路径上的任意一点距离的最小值。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先思考几个性质：</p>\n<ol>\n<li><p>树的所有直径中，不管选择哪一个，最终的结果都是一样的。</p>\n<p>证明：</p>\n<p>咕掉了。</p>\n</li>\n<li><p>在直径上的点，离它最远的点必然是直径的端点之一。</p>\n<p>证明：</p>\n<p>反证法。</p>\n<p>假设有一个不在直径上的点，它到这个点的距离比直径的一个端点到这个点的距离更大，那么把直径的一个端点替换为这个点，长度会更长，与原路径是直径矛盾。</p>\n</li>\n</ol>\n<p>现在，我们已经有了基本的思路：</p>\n<p>根据性质1，我们随便找一个直径求答案。</p>\n<p>根据性质2，答案就在直径的两个端点到路径的两个端点的距离和非两个端点到其他非直径上点的距离。（这里先让你们自己思考一下吧，有时间应该会更具体的过程，还算比较好想）</p>\n<p>然后，每次把 $s$ 距离填满最优，这也是性质2的一个推论。</p>\n<p>于是，维护一个单调队列，把 $\\max$ 求一下就行了。</p>\n<p>但是，根据性质2，我们不剔除左端点前面的非直径点到它的距离，也无伤大雅，因为它们肯定小于左端点到直径的一个端点的距离，这样只用扫一遍就行了。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,s,head[N],tot,dep[N],fa[N],a[N],cnt,d[N],Max,dis[N],vis[N],ans;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to =  y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fat)</span></span>&#123;</span><br><span class=\"line\">\tvis[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tMax = <span class=\"built_in\">max</span>(Max,dep[u]);</span><br><span class=\"line\">\tfa[u] = fat;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tdep[v] = dep[u]+edge[i].w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getdia</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> mpos = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++) <span class=\"keyword\">if</span> (dep[mpos]&lt;dep[i]) mpos = i;</span><br><span class=\"line\">\tdep[mpos] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(mpos,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">if</span> (dep[mpos]&lt;dep[i]) mpos = i;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (mpos)&#123;</span><br><span class=\"line\">\t\td[++cnt] = mpos;</span><br><span class=\"line\">\t\tdis[cnt] = dep[d[cnt]];</span><br><span class=\"line\">\t\tmpos = fa[mpos];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">\tMax = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tans = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++) vis[d[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (dis[l]-dis[i]&gt;s) l++;</span><br><span class=\"line\">\t\tdep[d[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(d[i],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tans = <span class=\"built_in\">min</span>(ans,<span class=\"built_in\">max</span>(dis[<span class=\"number\">1</span>]-dis[l],<span class=\"built_in\">max</span>(dis[i]-dis[cnt],Max)));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,z);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,z);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">getdia</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","树","树的直径"]},{"title":"浅谈Hash","url":"/2022/07/19/%E6%B5%85%E8%B0%88Hash/","content":"<h1 id=\"浅谈Hash\"><a href=\"#浅谈Hash\" class=\"headerlink\" title=\"浅谈Hash\"></a>浅谈Hash</h1><p>$\\color{lightblue}Status: OK$</p>\n<h2 id=\"什么是Hash\"><a href=\"#什么是Hash\" class=\"headerlink\" title=\"什么是Hash\"></a>什么是Hash</h2><p>由于每个字母对应的 ASCII 码都一样，所以可以把一个字符串看成一个 $p$ 进制数，每一位上就是字母对应的 ASCII 码，这样一来，一个字符串生成的数字（也叫Hash值）就是唯一的了。</p>\n<p>但是，在实际应用中，没有办法存储这样大的一个数字，所以要对它进行取模。但是，一旦取模了，就有可能造成两个字符串在取模后，对应的数字相同的情况，为了尽可能避免这种情况，我们一般对一个大质数取模。有时，可能还需要对不同的数取模，计算两个Hash值，以尽量确保答案的正确性（当然，会有性能损失）。</p>\n<span id=\"more\"></span>\n<h2 id=\"例题1\"><a href=\"#例题1\" class=\"headerlink\" title=\"例题1\"></a>例题1</h2><p><a href=\"https://www.luogu.com.cn/problem/CF955D\">CF955D Scissors</a></p>\n<p>思考一下 $t$ 在新合成的串中出现的情况：</p>\n<ol>\n<li>在两个串之间的任意一个中出现</li>\n<li>左半边是其中一个串的后缀，右半边是其中一个串的前缀。</li>\n</ol>\n<p>第一种情况相当于枚举起点，判断两个串是否相等，可以通过Hash $O(1)$ 解决。</p>\n<p>现在考虑第二种情况。</p>\n<p>由于我们只需要找到一组合法的解，根据贪心，要使串能尽可能不重叠，需要让后缀串（左边的）靠前，前缀串（右边的）靠后。所以，只需要找到每个后缀最先出现的位置，和每个前缀最后出现的位置就行了。</p>\n<p>但是，要注意前缀串出现的位置的结尾要 $\\geq k$，后缀串出现的结尾要 $\\leq n-k+1$。</p>\n<p>以前缀为例，暴力维护它：从 $k$ 开始枚举结尾位置，每次暴力判断是否合法，找到第一个合法的位置就退出。</p>\n<p>这样做的时间复杂度最坏是 $O(n^2)$，考虑优化。</p>\n<p>枚举前缀的长度，先判断以 $k$ 结尾的串是否匹配，找到最大的能匹配的长度 $d$。显然，前缀长度在 $d$ 以内的串都不优，因为如果放弃长度为 $d$ 的以 $k$ 结尾的串，使用长度 $\\leq d$ 的以 $\\geq k$ 的位置结尾的串，能匹配上后面一个后缀串，那用长度为 $d$ 的前缀，只用把</p>\n<p>请忽略上面说的话，这题 Hash 我不知道怎么做到线性！</p>\n<p>由于数据较水，各种玄学代码都能通过，这里给一个能卡掉部分代码的样例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">12 4 3</span><br><span class=\"line\">abcddabddcef</span><br><span class=\"line\">abce</span><br></pre></td></tr></table></figure>\n<p>如果您不能分析代码的时间复杂度，那么您写的大概率能被这个卡掉：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">500000 400000 200000</span><br><span class=\"line\">ababab...abccc...ccc (前250000是ab，后250000是c)</span><br><span class=\"line\">ababab...ab</span><br></pre></td></tr></table></figure>\n<p>但如果您实力超群，发现了行之有效的线性 Hash 代码，请 Luogu 私信教教我 qwq。</p>\n<p>练习：<a href=\"https://www.luogu.com.cn/problem/CF1200E\">CF1200E Compress Words</a></p>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><p><a href=\"https://www.luogu.com.cn/problem/UVA11019\">UVA11019 Matrix Matcher</a></p>\n<p>二维 Hash模板题。</p>\n<p>思想其实和一维的差不多，只是 $(i,j)$ 上维护的是 $(1,1)$ 到 $(i,j)$ 的矩阵的 Hash 值，我们可以先对横向都求一遍 Hash，之后对求出来的 Hash 再到纵向上求一遍，两次最好用不同的进制，以避免冲突（反正 Hash 过不了大半都是模数和进制的选择问题，双 Hash 还是最稳的）。</p>\n<h3 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> x1 xx1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> y1 yy1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> x2 xx2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> y2 yy2</span></span><br><span class=\"line\"><span class=\"comment\">//这里define这么多是因为其中有些是C++的内置函数</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e3</span>+<span class=\"number\">10</span>,p1 = <span class=\"number\">131</span>,p2 = <span class=\"number\">233</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,m,x,y;</span><br><span class=\"line\">ll has[N][N][<span class=\"number\">3</span>],pw1[N],pw2[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tpw1[<span class=\"number\">0</span>] = pw2[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">1000</span>;i++)&#123;</span><br><span class=\"line\">\t\tpw1[i] = (pw1[i<span class=\"number\">-1</span>]*p1)%mod;</span><br><span class=\"line\">\t\tpw2[i] = (pw2[i<span class=\"number\">-1</span>]*p2)%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"type\">int</span> x1,<span class=\"type\">int</span> y1,<span class=\"type\">int</span> x2,<span class=\"type\">int</span> y2)</span></span>&#123;</span><br><span class=\"line\">\tx1--,y1--;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ((has[x2][y2][<span class=\"number\">0</span>]+has[x1][y1][<span class=\"number\">0</span>]*pw1[x2-x1]%mod*pw2[y2-y1]%mod-has[x1][y2][<span class=\"number\">0</span>]*pw1[x2-x1]-has[x2][y1][<span class=\"number\">0</span>]*pw2[y2-y1])%mod+mod)%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"built_in\">init</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tll h = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\t\t\tcin&gt;&gt;s;</span><br><span class=\"line\">\t\t\t\th = (h*p2+s)%mod;</span><br><span class=\"line\">\t\t\t\thas[i][j][<span class=\"number\">0</span>] = (has[i<span class=\"number\">-1</span>][j][<span class=\"number\">0</span>]*p1+h)%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=x;i++)&#123;</span><br><span class=\"line\">\t\t\tll h = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=y;j++)&#123;</span><br><span class=\"line\">\t\t\t\tcin&gt;&gt;s;</span><br><span class=\"line\">\t\t\t\th = (h*p2+s)%mod;</span><br><span class=\"line\">\t\t\t\thas[i][j][<span class=\"number\">1</span>] = (has[i<span class=\"number\">-1</span>][j][<span class=\"number\">1</span>]*p1+h)%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=x;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=y;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">chk</span>(i-x+<span class=\"number\">1</span>,j-y+<span class=\"number\">1</span>,i,j) == has[x][y][<span class=\"number\">1</span>]) ans++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","字符串","Hash"]},{"title":"浅谈随机数据生成与对拍","url":"/2021/10/12/%E6%B5%85%E8%B0%88%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E4%B8%8E%E5%AF%B9%E6%8B%8D/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近写了一个对拍器，自认为对于对拍有一定见解，但今天$cjf$说如果用$srand(time(0))$，在卑微的Windows系统下一秒钟实际上只对了一组数据，因为$time(0)$在一秒钟内不会变化，写了个程序<br>试了一下，确实如此<br><span id=\"more\"></span><br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;test.in&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,stdout);</span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">0</span>,las = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (a==las)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">\t\ta = <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!las) las = a;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>cnt统计的是和最先一次rand出来的数相同的数的个数</p>\n<p>cnt大概有1e7-2e7，可见数据生成器生成数据的不随机性（除非你的程序用时太久，不能在1s内跑完生成的数据）</p>\n<p><strong>显然，这会对对拍的效率产生严重影响，那么应该如何生成完全随机的数据呢？</strong>  </p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>先用$srand$生成10个左右的随机数，然后就可以得到10个随机种子，再用它们生成随机数，同时运行程序，就可以得到真正的随机数了。</p>\n<p>但这样有一个问题：生成的随机数都是5位数，所以在对拍几万个数据后，种子就是重复的了，那样就没有意义了，所以考虑生成更大的种子。</p>\n<p>在这里给出一种方法：用两个$for$把种子乘起来当作种子，这样种子大概率就不同了。</p>\n<p>具体传种子的方法读者可以自己实现，在这里给出一种方式：$freopen$<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sed;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;seed.in&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">    cin&gt;&gt;sed;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>((<span class=\"type\">unsigned</span>)sed);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    your code here</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>具体生成随机数的方法：<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> rs[<span class=\"number\">15</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">             rs[i] = <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=<span class=\"number\">10</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\">ofstream <span class=\"title\">output</span><span class=\"params\">(<span class=\"string\">&quot;seed.in&quot;</span>)</span></span>;</span><br><span class=\"line\">\t\t\t\toutput&lt;&lt;rs[i]*rs[j]&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;1.exe&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>其实一般只随机10个数也可以，重复周期较长</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p>貌似不生成数据，单独使用$fc$比较文件很慢？（请读者自行测试100000行以上数据，本机测得$fc$比字符比较慢很多）<br><img src=\"https://z3.ax1x.com/2021/10/12/5nzKv8.md.png\" alt=\"实测结果\"></p>\n","tags":["Knowledge","Misc"]},{"title":"浅谈AC自动机","url":"/2022/08/07/%E6%B5%85%E8%B0%88AC%E8%87%AA%E5%8A%A8%E6%9C%BA/","content":"<h1 id=\"浅谈AC自动机\"><a href=\"#浅谈AC自动机\" class=\"headerlink\" title=\"浅谈AC自动机\"></a>浅谈AC自动机</h1><p>$\\color{lightblue}Status: OK$</p>\n<h2 id=\"前置内容\"><a href=\"#前置内容\" class=\"headerlink\" title=\"前置内容\"></a>前置内容</h2><p>AC自动机是用 Trie 树构建的，所以在学AC自动机之前，你需要先学会 <a href=\"https://bowenone580.github.io/2022/07/22/%E6%B5%85%E8%B0%88Trie%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/\">Trie</a>。</p>\n<h2 id=\"用来做什么\"><a href=\"#用来做什么\" class=\"headerlink\" title=\"用来做什么\"></a>用来做什么</h2><p>在一个串内匹配多个模式串，并对匹配结果进行若干操作。</p>\n<p>利用 fail 数组解决多种问题。</p>\n<p>在 AC自动机上 DP。</p>\n<span id=\"more\"></span>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>先上模板题链接：<a href=\"https://www.luogu.com.cn/problem/P3808\">P3808 AC自动机（简单版）</a>。</p>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>把所有的模式串插入 Trie 中，时间复杂度为 $O(\\sum_{i=1}^n |s_i|)$。</p>\n<h3 id=\"构建-fail-边\"><a href=\"#构建-fail-边\" class=\"headerlink\" title=\"构建 fail 边\"></a>构建 fail 边</h3><p>现在，我们要对 Trie 上的每个节点 $i$，计算出从根节点到它形成的这个字符串，能够在所有模式串的前缀中匹配的最长后缀，用 $fail[i]$ 存储这个后缀处在的节点。</p>\n<p>假设现在有一个节点 $x$，它的父亲是 $p$，且满足 $tr[p][c] = x$，我们已经求出了 $p$ 节点的 fail。</p>\n<p>显然，$fail[x] = tr[fail[p]][c]$，因为 $fail[p]$ 存储的是能和 $p$ 匹配的最长后缀，所以同时加上一个 $c$，必然还是后缀。</p>\n<p>至于为啥最长，如果有比它更长的，那么同时减去一个 $c$，它必然是 $p$ 的更长的后缀，和 fail 的定义冲突，所以最长。</p>\n<p>这时候，你可能会问：如果 $fail[p]$ 所在的节点没有 $c$ 这个儿子，怎么办呢？</p>\n<p>我们强行让它有这个儿子，即 $tr[p][c] = tr[fail[p]][c]$。</p>\n<p>仔细想想，这就相当于一个路径压缩的过程，没有就指向上一次有的，每次都指，不就是一个并查集吗？所以这样指是合法的。</p>\n<p>至此，fail 构建的方法已经出来了，正确性也有了保证。</p>\n<p>再想一想我们构建一个节点 fail 的前提：它的父亲的 fail 已经构建出来。</p>\n<p>这提示我们什么？要用 BFS 完成构建。</p>\n<p>先插入根节点所有存在的儿子（不直接插入根节点是因为，根据上面的规则，它的儿子会把 fail 都设成自己），之后每次取出一个儿子，把所有子节点的 fail 更新或创建子节点，原来已经有的子节点入队，更新它的儿子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++) <span class=\"keyword\">if</span> (tr[<span class=\"number\">0</span>][i]) q.<span class=\"built_in\">push</span>(tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\"><span class=\"type\">int</span> now;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\tnow = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> fai = fail[now];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!tr[now][i]) tr[now][i] = tr[fai][i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tfail[tr[now][i]] = tr[fai][i];</span><br><span class=\"line\">\t\t\tq.<span class=\"built_in\">push</span>(tr[now][i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成这项操作的时间复杂度最大为 $O(26\\sum_{i=1}^n|s_i|)$。</p>\n<p>Bonus：fail 边构成的图为 fail 树，fail 边和 Trie 树组成的图叫 fail图。请你证明一下 fail 边构成的一定是个树。</p>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><p>以这道题中的查询为例，我们需要查询有多少个模式串在匹配串中出现。</p>\n<p>把匹配串放到 AC自动机上面跑（其实就是 Trie+fail 边组成的图），可以对每个前缀跑出来一个匹配的最长后缀，之后不断走 fail 边，即可遍历这个后缀的所有后缀，最后累加一下是串的结尾的后缀即可。注意已经访问过的后缀不用再访问，因为后面走的所有点都走过了，这样可以使每个点都只被访问一次，降低复杂度。</p>\n<h3 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,tr[N][<span class=\"number\">26</span>],tot,fail[N],ans,exi[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!tr[now][c]) tr[now][c] = ++tot;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\texi[now]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++) <span class=\"keyword\">if</span> (tr[<span class=\"number\">0</span>][i]) q.<span class=\"built_in\">push</span>(tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\tnow = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> fai = fail[now];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!tr[now][i]) tr[now][i] = tr[fai][i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tfail[tr[now][i]] = tr[fai][i];</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(tr[now][i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> tmp = now;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (tmp &amp;&amp; exi[tmp]!=<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\tans+=exi[tmp]; </span><br><span class=\"line\">\t\t\texi[tmp] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\ttmp = fail[tmp];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">insert</span>(s); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>();</span><br><span class=\"line\">\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">query</span>(s);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结一下，AC自动机可以完成多模式串匹配，fail 边指向的是和这个串的后缀匹配的模式串的最长前缀，构建一个AC自动机的时间复杂度和空间复杂度均为 $O(26\\sum|s_i|)$。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p><a href=\"https://www.luogu.com.cn/problem/P3796\">P3796 AC自动机（加强版）</a></p>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p>不妨想想，AC自动机能拥有这样好的性能的原因是什么？不难发现，一切的奥秘都在 fail 边之中。正是因为添加了 fail 边，才能 $O(1)$ 找到最长公共后缀，这启发我们：还可以拿 fail 边干点啥别的事吗？</p>\n<h3 id=\"拓扑建图优化计数\"><a href=\"#拓扑建图优化计数\" class=\"headerlink\" title=\"拓扑建图优化计数\"></a>拓扑建图优化计数</h3><p><a href=\"https://www.luogu.com.cn/problem/P5357\">P5357 AC 自动机（二次加强版）</a></p>\n<p>先说一个朴素的做法。</p>\n<p>把AC自动机建出来，再把 $s$ 放上去匹配，每次匹配时，不断跳 fail 边，再把遇到的结束位置的计数器加 $1$。</p>\n<p>这样的时间复杂度是多少呢？每次跳 fail 边最少使长度减 $1$，最多要跳 $\\max(|t_i|)$ 次，总时间复杂度为 $O(|s||t|)$。</p>\n<p>但是，这样会带来大量重复的计算。</p>\n<p>比如，我们从 $a$ 跳到 $b$，再跳到 $c$，把 $b,c$ 的计数器都加 $1$，下一次我们又来到了 $b$，又要跳到 $c$。发现了什么，这个跳的过程是可以合并的。我们第一次从 $a\\rightarrow b$ 之后，不继续跳了，只是跟 $b$ 说你多跳一次，也就是把 $b$ 的计数器加 $1$。</p>\n<p>既然这样，每个节点跳 fail 之前就有一个限制：所有要跳到它的节点都已经被访问过了。</p>\n<p>学术一点说，就是它的入度要为 $0$，这就可以用拓扑排序解决了。</p>\n<h4 id=\"Code-1\"><a href=\"#Code-1\" class=\"headerlink\" title=\"Code\"></a>Code</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,M = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,tr[N][<span class=\"number\">26</span>],fail[N],tot,mp[N],indeg[N],ans[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[M];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> *s,<span class=\"type\">int</span> id)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!tr[now][c]) tr[now][c] = ++tot;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmp[id] = now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++) <span class=\"keyword\">if</span> (tr[<span class=\"number\">0</span>][i]) q.<span class=\"built_in\">push</span>(tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\tnow = q.<span class=\"built_in\">front</span>(),q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> fa = fail[now];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!tr[now][i]) tr[now][i] = tr[fa][i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tfail[tr[now][i]] = tr[fa][i];</span><br><span class=\"line\">\t\t\t\tindeg[tr[fa][i]]++;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(tr[now][i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\tans[now]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">topo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!indeg[i]) q.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\tnow = q.<span class=\"built_in\">front</span>(),q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tans[fail[now]]+=ans[now];</span><br><span class=\"line\">\t\tindeg[fail[now]]--;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!indeg[fail[now]]) q.<span class=\"built_in\">push</span>(fail[now]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">insert</span>(s,i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>();</span><br><span class=\"line\">\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">query</span>(s);</span><br><span class=\"line\">\t<span class=\"built_in\">topo</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cout&lt;&lt;ans[mp[i]]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h4><p><a href=\"https://www.luogu.com.cn/problem/P3041\">P3041 [USACO12JAN]Video Game G</a></p>\n<p>（这题不用拓扑建图也能水过去，但是万一被加强了呢？）</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3065\">P3065 [USACO12DEC]First! G</a></p>\n<p>（这题其实也是诈骗，因为虽然要拓扑排序，但是跟这里的拓扑建图没有任何关系，甚至不用AC自动机）</p>\n<h3 id=\"套上-DP\"><a href=\"#套上-DP\" class=\"headerlink\" title=\"套上 DP\"></a>套上 DP</h3><p><a href=\"https://www.luogu.com.cn/problem/P4052\">P4052 [JSOI2007]文本生成器</a></p>\n<p>先用一个容斥，把问题转化为求不可读文本的数量。</p>\n<p>假设我们匹配一个串，它什么时候不可读？</p>\n<p>显然，把它放在 AC 自动机上匹配，一直匹配不到末尾节点，就不可读。</p>\n<p>看到计数，自然想到 DP，而这个 DP 状态，根据某些大佬的说法，一般都是设 $f[i][j]$ 表示串的长度为 $i$，匹配到 AC自动机上的 $j$ 节点，转移也是非常套路的枚举 $i,j$ 和这次加入的字符。时间复杂度为 $O(26|s||\\sum t_i|)$。</p>\n<p>放个转移方程：</p>\n<p>$f[i+1][tr[j][p]]+=f[i][j]$</p>\n<p>条件是 $tr[j][p]$ 不为终止节点，且 $j$ 也不为终止节点（不要也行，因为前面的条件就限制了 $f[i][j]$ 必定为 $0$）。</p>\n<p>初始化时把 $f[0][0]$ 初始化为 $1$。</p>\n<h4 id=\"Code-2\"><a href=\"#Code-2\" class=\"headerlink\" title=\"Code\"></a>Code</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e4</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e2</span>+<span class=\"number\">10</span>,mod = <span class=\"number\">1e4</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,tr[N][<span class=\"number\">26</span>],ok[N],fail[N],tot,f[M][N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tr[now][c]) tr[now][c] = ++tot;</span><br><span class=\"line\">        now = tr[now][c];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ok[now] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++) <span class=\"keyword\">if</span> (tr[<span class=\"number\">0</span>][i]) q.<span class=\"built_in\">push</span>(tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">    <span class=\"type\">int</span> now;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        now = q.<span class=\"built_in\">front</span>(),q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> fa = fail[now];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!tr[now][i]) tr[now][i] = tr[fa][i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                fail[tr[now][i]] = tr[fa][i];</span><br><span class=\"line\">                ok[tr[now][i]]|=ok[tr[fa][i]];</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(tr[now][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ret = ret*bas%mod;</span><br><span class=\"line\">        bas = bas*bas%mod;</span><br><span class=\"line\">        y&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">insert</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">build</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"built_in\">ksm</span>(<span class=\"number\">26</span>,m);</span><br><span class=\"line\">    f[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;<span class=\"number\">26</span>;p++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ok[tr[j][p]]) f[i+<span class=\"number\">1</span>][tr[j][p]] = (f[i+<span class=\"number\">1</span>][tr[j][p]]+f[i][j])%mod;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=tot;i++) ans = (ans-f[m+<span class=\"number\">1</span>][i])%mod;</span><br><span class=\"line\">    ans = (ans+mod)%mod;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 AC自动机上 DP 的题还有很多，最重要的就是状态转移方程，所以要好好理解 AC自动机的原理和各个细节的含义。</p>\n<h4 id=\"练习-2\"><a href=\"#练习-2\" class=\"headerlink\" title=\"练习\"></a>练习</h4><p><a href=\"https://www.luogu.com.cn/problem/P3311\">P3311 [SDOI2014] 数数</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P2292\">P2292 [HNOI2004] L 语言</a></p>\n<h3 id=\"在-fail-树上-dfs\"><a href=\"#在-fail-树上-dfs\" class=\"headerlink\" title=\"在 fail 树上 dfs\"></a>在 fail 树上 dfs</h3><p><a href=\"https://www.luogu.com.cn/problem/P2444\">P2444 POI2000 病毒</a></p>\n<p>所谓不包含病毒串，就是这个串在 Trie 上匹配时，不会走到病毒串的末尾。</p>\n<p>所谓无限长的串，就是 dfs 整个 Trie 时会形成环。</p>\n<p>一个节点会走到病毒串的末尾，条件是这个串一直跳 fail，会跳到病毒串末尾，于是我们只要知道它的 fail 是否跳到病毒串末尾，就可以知道它是否会跳到了。</p>\n<p>dfs 时对每个走过的点打上标记，如果走到了经过的点，就说明找到环了。</p>\n<p>代码就不放了，相信大家的能力！<del>实际上是我之前写了一个很慢的 dp，懒的再写一个了</del></p>\n<h3 id=\"在-fail-树上求-lca\"><a href=\"#在-fail-树上求-lca\" class=\"headerlink\" title=\"在 fail 树上求 lca\"></a>在 fail 树上求 lca</h3><p><a href=\"https://www.luogu.com.cn/problem/P4600\">P4600 HEOI2012 旅行问题</a></p>\n<p>神仙题。</p>\n<p>为啥这题神仙，因为你如果不想 AC（自动机），不想 fail（树），那就无法可想了。<del>不信你用其他的方法搞1h，能搞出来算我输；您再想1h，不看题解能想到lca上，那您就是神仙了</del></p>\n<p>废话不多说，我们直接分析如何做。（也别管是怎么想到的了）</p>\n<p>显然，AC自动机上的每一个点的 fail 边指向的都是最长后缀，且这个后缀必然是一个字符串的前缀（根据 Trie 的性质）。</p>\n<p>之后，我们求两个点在 fail 树上的 lca，思考其意义。</p>\n<p>显然，从根节点到 lca 的链是两个点对应的串的后缀（毕竟能跳 fail 到那里去），且是最长公共后缀（你想想啥是 lca），而且还是其中一个字符串的子串（它在 Trie 上）。</p>\n<p>这不就是我们要求的东西吗？</p>\n<p>温馨提示：此题卡空间，您如果用倍增求 lca 可能会挂掉 $2$ 个点，在此放上常数巨大无比的转 dfs 序后用线段树求 lca 的代码。<del>不会树剖锕</del></p>\n<h4 id=\"Code-3\"><a href=\"#Code-3\" class=\"headerlink\" title=\"Code\"></a>Code</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e6</span>+<span class=\"number\">5</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,val[N],head[N],tot,cnt,col,ori[N],beg[N],en[N],dfn[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; pre[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">SegT</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> Min[N*<span class=\"number\">8</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\t\tMin[node] = <span class=\"built_in\">min</span>(Min[node&lt;&lt;<span class=\"number\">1</span>],Min[node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\t\tMin[node] = dfn[l];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>,lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">build</span>(lc,l,mid);</span><br><span class=\"line\">\t\t<span class=\"built_in\">build</span>(rc,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(node);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> beg,<span class=\"type\">int</span> en,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (beg&gt;=l &amp;&amp; en&lt;=r) <span class=\"keyword\">return</span> Min[node];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = (beg+en)&gt;&gt;<span class=\"number\">1</span>,ans = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l&lt;=mid) ans = <span class=\"built_in\">min</span>(ans,<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>,beg,mid,l,r));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r&gt;mid) ans = <span class=\"built_in\">min</span>(ans,<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,en,l,r));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ACAM</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tr[N][<span class=\"number\">26</span>],fail[N],tot;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> id)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!tr[now][c])&#123;</span><br><span class=\"line\">\t\t\t\ttr[now][c] = ++tot;</span><br><span class=\"line\">\t\t\t\tval[tot] = (<span class=\"number\">1ll</span>*val[now]*<span class=\"number\">26</span>+c)%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\t\tpre[id].<span class=\"built_in\">push_back</span>(now);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tr[<span class=\"number\">0</span>][i])&#123;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"number\">0</span>,tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t\tnow = q.<span class=\"built_in\">front</span>(),q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> fa = fail[now];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!tr[now][i]) tr[now][i] = tr[fa][i];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tfail[tr[now][i]] = tr[fa][i];</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">add</span>(tr[fa][i],tr[now][i]);</span><br><span class=\"line\">\t\t\t\t\tq.<span class=\"built_in\">push</span>(tr[now][i]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; ac;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\tcol++;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = col;</span><br><span class=\"line\">\tori[tmp] = u;</span><br><span class=\"line\">\tdfn[++cnt] = tmp;</span><br><span class=\"line\">\tbeg[u] = cnt;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t\tdfn[++cnt] = tmp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ten[u] = cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tac.<span class=\"built_in\">insert</span>(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tac.<span class=\"built_in\">build</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tt.<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,cnt);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a,b,c,d,x,y,l,r;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class=\"line\">\t\tx = pre[a][b<span class=\"number\">-1</span>],y = pre[c][d<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\tl = <span class=\"built_in\">min</span>(beg[x],beg[y]),r = <span class=\"built_in\">max</span>(en[x],en[y]);</span><br><span class=\"line\">\t\tcout&lt;&lt;val[ori[t.<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,cnt,l,r)]]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在-fail-树上跑树状数组\"><a href=\"#在-fail-树上跑树状数组\" class=\"headerlink\" title=\"在 fail 树上跑树状数组\"></a>在 fail 树上跑树状数组</h3><p><a href=\"https://www.luogu.com.cn/problem/P2414\">P2414 NOI2011 阿狸的打字机</a></p>\n<p>题目有两个比较特殊的限制：一是每次只能添加或减少 $1$ 个字符，二是只有询问，而且询问是独立的。</p>\n<p>我们先想一想如何回答询问。</p>\n<p>比较暴力的方法是把 $y$ 放到 AC自动机上跑，每次跳 fail，看有多少次跳到了 $x$。</p>\n<p>更具体一点，对每一个 $y$ 的节点，统计在其到根节点的路径上出现了 $x$ 的末尾节点的次数。</p>\n<p>换一种表述，就是求 $x$ 节点的子树内，属于 $y$ 的节点的个数。</p>\n<p>对每一个询问都跑一遍不是很现实，但是询问是独立的，也就是说处理询问的顺序和答案一点关系都没有，不妨离线下来。</p>\n<p>而且，每次切换 $y$ 串的时候，需要修改很多不同的节点，相反，每次加一个字符，或删除一个字符，只需要修改一个节点。</p>\n<p>可以以 $y$ 为第一关键字排序，边处理整个操作串边修改，修改次数为 $O(n)$ 级别。到了有询问的串时，就变成了经典的查询子树和的问题，可以把树拍扁，在 dfs 序上修改，最后区间求和，树状数组显然可以胜任这个工作。</p>\n<p>总时间复杂度为 $O(n+m\\log n)$。</p>\n<h4 id=\"Code-4\"><a href=\"#Code-4\" class=\"headerlink\" title=\"Code\"></a>Code</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> mp make_pair</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,head[N],tot,dfn[N],cnt,l[N],r[N],ans[N],ori[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\">vector&lt;pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; &gt; a[N];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; exi[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">52</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">BIT</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tr[N*<span class=\"number\">4</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (;x&lt;=cnt;x+=(x&amp;(-x))) tr[x]+=v;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (;x;x-=(x&amp;(-x))) ans+=tr[x];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; tr1;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ACAM</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tr[N][<span class=\"number\">26</span>],tot = <span class=\"number\">0</span>,fa[N],fail[N];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;P&#x27;</span>) exi[now].<span class=\"built_in\">pb</span>(++cnt),ori[cnt] = now;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;B&#x27;</span>) now = fa[now];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!tr[now][c])&#123;</span><br><span class=\"line\">\t\t\t\t\ttr[now][c] = ++tot;</span><br><span class=\"line\">\t\t\t\t\tfa[tot] = now;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tr[<span class=\"number\">0</span>][i])&#123;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"number\">0</span>,tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">add</span>(tr[<span class=\"number\">0</span>][i],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t\tnow = q.<span class=\"built_in\">front</span>(),q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> fai = fail[now];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!tr[now][i]) tr[now][i] = tr[fai][i];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tfail[tr[now][i]] = tr[fai][i];</span><br><span class=\"line\">\t\t\t\t\tq.<span class=\"built_in\">push</span>(tr[now][i]);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">add</span>(tr[now][i],fail[tr[now][i]]);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">add</span>(fail[tr[now][i]],tr[now][i]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">query</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;P&#x27;</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> tmp1,tmp2;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> x:exi[now])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> y:a[x])&#123;</span><br><span class=\"line\">\t\t\t\t\t\ttmp1 = ori[y.first];</span><br><span class=\"line\">\t\t\t\t\t\ttmp2 = y.second;</span><br><span class=\"line\">\t\t\t\t\t\tans[tmp2] = tr1.<span class=\"built_in\">query</span>(r[tmp1])-tr1.<span class=\"built_in\">query</span>(l[tmp1]<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;B&#x27;</span>)&#123;</span><br><span class=\"line\">\t\t\t\ttr1.<span class=\"built_in\">update</span>(l[now],<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t\tnow = fa[now];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\t\t\ttr1.<span class=\"built_in\">update</span>(l[now],<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tdfn[++cnt] = u;</span><br><span class=\"line\">\tl[u] = cnt;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdfn[++cnt] = u;</span><br><span class=\"line\">\tr[u] = cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;(s+<span class=\"number\">1</span>)&gt;&gt;m;</span><br><span class=\"line\">\tn = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\ta[y].<span class=\"built_in\">pb</span>(<span class=\"built_in\">mp</span>(x,i));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tt.<span class=\"built_in\">insert</span>();</span><br><span class=\"line\">\tt.<span class=\"built_in\">build</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tt.<span class=\"built_in\">query</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","字符串","AC自动机"]},{"title":"浅谈Trie及其应用","url":"/2022/07/22/%E6%B5%85%E8%B0%88Trie%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/","content":"<h1 id=\"浅谈-Trie-及其应用\"><a href=\"#浅谈-Trie-及其应用\" class=\"headerlink\" title=\"浅谈 Trie 及其应用\"></a>浅谈 Trie 及其应用</h1><p>$\\color{lightblue}Status: OK$</p>\n<h2 id=\"什么是-Trie-树\"><a href=\"#什么是-Trie-树\" class=\"headerlink\" title=\"什么是 Trie 树\"></a>什么是 Trie 树</h2><p>想象一下翻英文字典的过程，是不是从首字母开始，一位一位的找找下去，最后找到你想要的词？Trie 树完成的就是这个工作。</p>\n<span id=\"more\"></span>\n<p><img src=\"https://s2.loli.net/2022/07/22/ojrqhKUJyQpWeXA.png\" alt=\"Trie_1\"></p>\n<p>比如我要插入一个 boy，先定位第一个字母，发现是 b，于是来到 0 的儿子 b，之后定位第二个字母 o，来到b 的儿子 o，最后定位第三个字母 y，发现 o 还没有y 这个儿子，就新建一个 y。Trie 树的每一个节点理论上都有 $|字符集大小|$ 个儿子，这里就是 $26$ 个，如果要查询一个串是否存在，顺着儿子往下走即可。</p>\n<h2 id=\"模板题\"><a href=\"#模板题\" class=\"headerlink\" title=\"模板题\"></a>模板题</h2><p><a href=\"https://www.luogu.com.cn/problem/P2580\">P2580 于是他错误的点名开始了</a></p>\n<p>给你一些串组成的集合，每次询问一个串是否出现在这个集合里和之前是否询问过这个串。</p>\n<p>先把集合插入 Trie 中，询问时顺着 Trie 往下走，直到走不了（没有儿子）或走完为止。</p>\n<p>如何判断询问串究竟是串本身还是串的前缀呢？我们可以对插入的每个串的结尾做一个标记，则在标记处停止的询问串出现在了集合中，是否重复出现在标记处记录是否访问过即可。</p>\n<p>在实现的过程中，需要对 Trie 树的空间格外注意，一般开 $n\\cdot|s|$ 个，其中 $n$ 是字符串个数， $|s|$ 是字符串的最大长度，这是因为每次插入一个串，最多可能多开 $|s|$ 个节点（和之前的任何一个串都没有共同前缀）。这也就意味着一棵 Trie 树耗费的空间可能多达 $n\\cdot |s|\\cdot 26$ 个 int，MLE 的风险很高，要尽量节省一些空间。</p>\n<h3 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,tr[N][<span class=\"number\">26</span>],tot;</span><br><span class=\"line\"><span class=\"type\">bool</span> exi[N],vis[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!tr[now][c]) tr[now][c] = ++tot;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\texi[now] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!tr[now][c])&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"string\">&quot;WRONG&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!exi[now]) cout&lt;&lt;<span class=\"string\">&quot;WRONG&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (vis[now]) cout&lt;&lt;<span class=\"string\">&quot;REPEAT&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tvis[now] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;OK&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">insert</span>(s);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">query</span>(s);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 Trie 上每次插入或查询一个字符串的复杂度都为 $O(|s|)$。</p>\n<p>Trie 树有很多有用的性质，比如一个串的前缀表示，一些串的最长公共前缀等，这使它能处理一些特殊问题。</p>\n<h2 id=\"例题1\"><a href=\"#例题1\" class=\"headerlink\" title=\"例题1\"></a>例题1</h2><p><a href=\"https://www.luogu.com.cn/problem/UVA1401\">UVA1401 Remember the Word</a></p>\n<p>给你一些小字符串和一个大串，求用这些小串拼成大串的方案数。</p>\n<p>一般求方案数的就是 DP，可以设计这样的 DP 状态：</p>\n<p>设 $f[i]$ 表示拼成前缀 $i$ 的方案数，每次枚举 $j$，看 $s[j$~$i]$ 这个串是否是一个小串，如果是，就加上 $f[j-1]$ 。</p>\n<p>但是，这样枚举 $j$ 的复杂度很高（Hash 另说），我们不妨换一种枚举顺序：固定一个 $i$，枚举结尾 $j$，每次判断 $s[i+1$~$j]$ 是否为一个小串，这样巧妙地利用了 Trie 存前缀的性质，每次扩展一个字符的时间复杂度为 $O(1)$，由于小串的长度最大为 $50$，所以时间复杂度为 $O(50n)$。</p>\n<p>每次向右扩展一个字符可以往 Trie 上面想。</p>\n<h3 id=\"Code：-1\"><a href=\"#Code：-1\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">4e5</span>+<span class=\"number\">10</span>,mod = <span class=\"number\">20071027</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,tr[N][<span class=\"number\">27</span>],tot,vis[N][<span class=\"number\">27</span>],tim;</span><br><span class=\"line\">ll f[N];</span><br><span class=\"line\"><span class=\"type\">bool</span> exi[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N],t[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (vis[now][c]!=tim)&#123;</span><br><span class=\"line\">\t\t\tvis[now][c] = tim;</span><br><span class=\"line\">\t\t\ttr[now][c] = ++tot;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\texi[now] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cin&gt;&gt;(s+<span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">\t\ttim++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(exi,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">bool</span>)*(tot+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tn = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(ll)*(n+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\tcin&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;(t+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">insert</span>(t);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tf[n+<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> c = s[j]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (vis[now][c]!=tim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (exi[now]) f[i] = (f[i]+f[j+<span class=\"number\">1</span>])%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Case &quot;</span>&lt;&lt;tim&lt;&lt;<span class=\"string\">&quot;: &quot;</span>&lt;&lt;f[<span class=\"number\">1</span>]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><p><a href=\"https://www.luogu.com.cn/problem/P4551\">P4551 最长异或路径</a></p>\n<p>先转化一下题意：</p>\n<p>算出每个点到根的异或值，则要求的最大异或路径等于两个点到根的异或的最大值，因为根到两点 LCA 的路径异或值抵消了。</p>\n<p>转化为求 $n$ 个数里面两个数异或的最大值。</p>\n<p>把异或值拆成二进制，按位从高到低贪心，有和这一位的值相反的就取（因为后面的所有低位即使都是 $1$，也比这一位小）。</p>\n<p>如何高效的完成这个算法呢？发现所有数的高位组成的数就是它的前缀，而我们就是在前缀上比较，这类问题可以放到 Trie 上做，达到 $O(32n)$ 的复杂度。</p>\n<h3 id=\"Code：-2\"><a href=\"#Code：-2\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,head[N],tot,ans;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Trie</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tr[N*<span class=\"number\">26</span>][<span class=\"number\">3</span>],tot;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">31</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> c = (x&gt;&gt;i)&amp;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!tr[now][c]) tr[now][c] = ++tot;</span><br><span class=\"line\">\t\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">31</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> c = (x&gt;&gt;i)&amp;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tr[now][c^<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t\t\tnow = tr[now][c^<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\tans+=(<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> now = tr[now][c];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa,<span class=\"type\">int</span> sum)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tt.<span class=\"built_in\">update</span>(sum);</span><br><span class=\"line\">\tans = <span class=\"built_in\">max</span>(ans,t.<span class=\"built_in\">query</span>(sum));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u,sum^edge[i].w);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,z);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,z);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种把数拆成二进制之后放到 Trie 上的叫做 01Trie，这道题只是理清了 01Trie 的基本架构，它还有一些非常好的性质和衍生的操作。</p>\n<h2 id=\"01Trie\"><a href=\"#01Trie\" class=\"headerlink\" title=\"01Trie\"></a>01Trie</h2><p>支持的操作：</p>\n<ul>\n<li>插入一个数。</li>\n<li>删除一个数。</li>\n<li>查询所有数的异或和。</li>\n<li>所有数 $+1$。</li>\n</ul>\n<p>我们一步步实现。</p>\n<p>插入和删除都是从低位到高位（其实算习惯吧，为了之后写代码方便）。</p>\n<p>在每一个 Trie 的节点 now 上记录以下几个值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ch[now][0/1] 指向它的儿子</span><br><span class=\"line\">w[now] 表示有多少个数在插入时经过了它</span><br><span class=\"line\">sum[now] 表示 now 这棵子树的异或和（但是是把 now 所在的层当作最低位，并不是真正的子树异或和）</span><br></pre></td></tr></table></figure>\n<p>怎么维护呢？先看代码吧（感觉代码可能比文字更好懂，反正文字也在代码里面）。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> &amp;now,<span class=\"type\">int</span> x,<span class=\"type\">int</span> dep)</span></span>&#123; <span class=\"comment\">//引用方便修改ch[now][0/1]</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!now) now = <span class=\"built_in\">push</span>(); <span class=\"comment\">//新建节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dep&gt;H)&#123; <span class=\"comment\">//H为最大深度，一般要保证答案在2^H以内</span></span><br><span class=\"line\">\t\tw[now]++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">insert</span>(ch[now][x&amp;<span class=\"number\">1</span>],x&gt;&gt;<span class=\"number\">1</span>,dep+<span class=\"number\">1</span>); <span class=\"comment\">//从低位到高位插入</span></span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(now); <span class=\"comment\">//维护 sum 和 w</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看看 pushup 操作。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> now)</span></span>&#123;</span><br><span class=\"line\">\tw[now] = sum[now] = <span class=\"number\">0</span>; <span class=\"comment\">//初始化为0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">0</span>])&#123; <span class=\"comment\">//如果把now-&gt;ch[now][0]看作一条边，那么0就相当于边权，代表第dep+1位为0</span></span><br><span class=\"line\">\t\tw[now]+=w[ch[now][<span class=\"number\">0</span>]]; <span class=\"comment\">//经过儿子的数插入时都会经过父亲</span></span><br><span class=\"line\">\t\tsum[now]^=(sum[ch[now][<span class=\"number\">0</span>]]&lt;&lt;<span class=\"number\">1</span>); <span class=\"comment\">//第dep+1位为0，对这一位的异或和没有影响</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">1</span>])&#123; <span class=\"comment\">//同上</span></span><br><span class=\"line\">\t\tw[now]+=w[ch[now][<span class=\"number\">1</span>]]; <span class=\"comment\">//经过儿子的数插入时都会经过父亲</span></span><br><span class=\"line\">\t\tsum[now]^=((sum[ch[now][<span class=\"number\">1</span>]]&lt;&lt;<span class=\"number\">1</span>)|(w[ch[now][<span class=\"number\">1</span>]]&amp;<span class=\"number\">1</span>)); <span class=\"comment\">//第dep+1位为1，异或和只和1的奇偶性相关</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tw[now]&amp;=<span class=\"number\">1</span>; <span class=\"comment\">//因为只和奇偶性相关，所以不用存具体值（要存也没关系，维护的信息会更具体，取决于题目）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>erase 操作如法炮制。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">erase</span><span class=\"params\">(<span class=\"type\">int</span> now,<span class=\"type\">int</span> x,<span class=\"type\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dep&gt;H)&#123;</span><br><span class=\"line\">\t\tw[now]--; <span class=\"comment\">//如果不要求求具体数量的话，这里改成+1也行，或者直接不要erase，再insert一遍（异或两次等于没异或）</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">erase</span>(ch[now][x&amp;<span class=\"number\">1</span>],x&gt;&gt;<span class=\"number\">1</span>,dep+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更短的 addall（全局 $+1$）操作。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addall</span><span class=\"params\">(<span class=\"type\">int</span> now)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(ch[now][<span class=\"number\">0</span>],ch[now][<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">0</span>]) <span class=\"built_in\">addall</span>(ch[now][<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个操作具体解释一下：</p>\n<p>每个数 $+1$，在二进制下表现为从最低位开始的为 $1$ 的位都变成 $0$，第一个为 $0$ 的位变成 $1$。</p>\n<p>再次思考父亲和儿子之间唯一的联系：边权。这一位是啥，边权就是啥，我们交换左右儿子就相当于交换边权。</p>\n<p>最后，因为要修改的是为 $1$ 的位，交换后变成了为 $0$ 的位，只要还有，就继续往下修改。</p>\n<p>查询所有数的异或和更简单了，直接输出 Trie 树的根的异或和即可。</p>\n<h2 id=\"例题3\"><a href=\"#例题3\" class=\"headerlink\" title=\"例题3\"></a>例题3</h2><p><a href=\"https://www.luogu.com.cn/problem/P6018\">P6018 Ynoi2010 Fusion tree</a></p>\n<p>这种树上的维护，一般分成维护一个点的所有儿子，父亲单独维护。</p>\n<p>操作 $1$ 相当于所有儿子 $+1$，父亲 $+1$。儿子的 $+1$ 直接 addall，父亲的 $+1$ 单独维护，顺便把父亲的父亲的树一起维护掉，保证正确性。</p>\n<p>操作 $2$ 相当于自己 $-v$，先在父亲的 Trie 中把自己删除，再插入更新后的自己即可。</p>\n<p>操作 $3$ 直接输出对应 Trie 树根节点的异或和异或上父亲的值即可。</p>\n<h3 id=\"Code：-3\"><a href=\"#Code：-3\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e5</span>+<span class=\"number\">10</span>,H = <span class=\"number\">21</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,head[N],tot,val[N],rt,fa[N],lazy[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Trie</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> rt[N],w[N*H],ch[N*H][<span class=\"number\">2</span>],sum[N*H],tot;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">push</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\ttot++;</span><br><span class=\"line\">\t\tch[tot][<span class=\"number\">0</span>] = ch[tot][<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tw[tot] = sum[tot] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\t\tw[node] = sum[node] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ch[node][<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">\t\t\tw[node]+=w[ch[node][<span class=\"number\">0</span>]];</span><br><span class=\"line\">\t\t\tsum[node]^=(sum[ch[node][<span class=\"number\">0</span>]]&lt;&lt;<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ch[node][<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t\tw[node]+=w[ch[node][<span class=\"number\">1</span>]];</span><br><span class=\"line\">\t\t\tsum[node]^=((sum[ch[node][<span class=\"number\">1</span>]]&lt;&lt;<span class=\"number\">1</span>)|(w[ch[node][<span class=\"number\">1</span>]]&amp;<span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tw[node]&amp;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> &amp;now,<span class=\"type\">int</span> x,<span class=\"type\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!now) now = <span class=\"built_in\">push</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dep&gt;H)&#123;</span><br><span class=\"line\">\t\t\tw[now]++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">insert</span>(ch[now][x&amp;<span class=\"number\">1</span>],x&gt;&gt;<span class=\"number\">1</span>,dep+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">erase</span><span class=\"params\">(<span class=\"type\">int</span> now,<span class=\"type\">int</span> x,<span class=\"type\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dep&gt;H)&#123;</span><br><span class=\"line\">\t\t\tw[now]--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">erase</span>(ch[now][x&amp;<span class=\"number\">1</span>],x&gt;&gt;<span class=\"number\">1</span>,dep+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addall</span><span class=\"params\">(<span class=\"type\">int</span> now)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(ch[now][<span class=\"number\">0</span>],ch[now][<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">0</span>]) <span class=\"built_in\">addall</span>(ch[now][<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> f)</span></span>&#123;</span><br><span class=\"line\">\tfa[u] = f;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == f) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> val[x]+(fa[x]?lazy[fa[x]]:<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(rt = y,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;val[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fa[i]) t.<span class=\"built_in\">insert</span>(t.rt[fa[i]],val[i],<span class=\"number\">0</span>); <span class=\"comment\">//这里不用担心rt初始为0的问题，因为是引用，如果没有rt会自动创建一个 </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> op;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op&gt;&gt;x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tlazy[x]++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (fa[x])&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (fa[fa[x]]) t.<span class=\"built_in\">erase</span>(t.rt[fa[fa[x]]],<span class=\"built_in\">get</span>(fa[x]),<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t\tval[fa[x]]++;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (fa[fa[x]]) t.<span class=\"built_in\">insert</span>(t.rt[fa[fa[x]]],<span class=\"built_in\">get</span>(fa[x]),<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tt.<span class=\"built_in\">addall</span>(t.rt[x]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (op == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;y;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (fa[x]) t.<span class=\"built_in\">erase</span>(t.rt[fa[x]],<span class=\"built_in\">get</span>(x),<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\tval[x]-=y;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (fa[x]) t.<span class=\"built_in\">insert</span>(t.rt[fa[x]],<span class=\"built_in\">get</span>(x),<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;(t.sum[t.rt[x]]^(fa[x]?<span class=\"built_in\">get</span>(fa[x]):<span class=\"number\">0</span>))&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"01Trie-合并\"><a href=\"#01Trie-合并\" class=\"headerlink\" title=\"01Trie 合并\"></a>01Trie 合并</h2><p>先看代码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>&#123; <span class=\"comment\">//a和b为两个树上位置相同的节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!a) <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!b) <span class=\"keyword\">return</span> a; <span class=\"comment\">//如果其中一个不存在，那它的子树也不存在，所以不用修改子树</span></span><br><span class=\"line\">\tw[a]+=w[b];</span><br><span class=\"line\">\tsum[a]^=sum[b]; <span class=\"comment\">//直接修改</span></span><br><span class=\"line\">\tch[a][<span class=\"number\">0</span>] = <span class=\"built_in\">merge</span>(ch[a][<span class=\"number\">0</span>],ch[b][<span class=\"number\">0</span>]);</span><br><span class=\"line\">\tch[a][<span class=\"number\">1</span>] = <span class=\"built_in\">merge</span>(ch[a][<span class=\"number\">1</span>],ch[b][<span class=\"number\">1</span>]); <span class=\"comment\">//更新两个儿子</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次合并两个 01Trie 时，看成小的 Trie 往大的 Trie 里面合并，那么小的 Trie 中的元素所在集合大小就会翻倍，每次合并至少让一个 Trie 中的元素大小翻倍，最后所有元素的大小都到了 $n$（属于同一个大集合），所以一个元素被合并的次数为 $\\log n$ 次，时间复杂度为 $O(n\\log n)$。</p>\n<h2 id=\"例题4\"><a href=\"#例题4\" class=\"headerlink\" title=\"例题4\"></a>例题4</h2><p><a href=\"https://www.luogu.com.cn/problem/P6623\">P6623 省选联考 2020 A 卷 树</a></p>\n<p>容易想到合并子树的 Trie，之后全局 $+1$，再加上自己，dfs 一遍，加上每个点的异或和就是答案。</p>\n<h3 id=\"Code：-4\"><a href=\"#Code：-4\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e5</span>+<span class=\"number\">10</span>,H = <span class=\"number\">23</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,val[N],head[N],tot;</span><br><span class=\"line\">ll ans;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Trie</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ch[N*H][<span class=\"number\">2</span>],w[N*H],rt[N],tot;</span><br><span class=\"line\">\tll sum[N*H];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">push</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\ttot++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> now)</span></span>&#123;</span><br><span class=\"line\">\t\tw[now] = sum[now] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">\t\t\tw[now]+=w[ch[now][<span class=\"number\">0</span>]];</span><br><span class=\"line\">\t\t\tsum[now]^=(sum[ch[now][<span class=\"number\">0</span>]]&lt;&lt;<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t\tw[now]+=w[ch[now][<span class=\"number\">1</span>]];</span><br><span class=\"line\">\t\t\tsum[now]^=((sum[ch[now][<span class=\"number\">1</span>]]&lt;&lt;<span class=\"number\">1</span>)|(w[ch[now][<span class=\"number\">1</span>]]&amp;<span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tw[now]&amp;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> &amp;now,<span class=\"type\">int</span> x,<span class=\"type\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!now) now = <span class=\"built_in\">push</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dep&gt;H)&#123;</span><br><span class=\"line\">\t\t\tw[now]++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">insert</span>(ch[now][x&amp;<span class=\"number\">1</span>],x&gt;&gt;<span class=\"number\">1</span>,dep+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addall</span><span class=\"params\">(<span class=\"type\">int</span> now)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(ch[now][<span class=\"number\">0</span>],ch[now][<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">0</span>]) <span class=\"built_in\">addall</span>(ch[now][<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!a) <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!b) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t\tw[a]+=w[b];</span><br><span class=\"line\">\t\tsum[a]^=sum[b];</span><br><span class=\"line\">\t\tch[a][<span class=\"number\">0</span>] = <span class=\"built_in\">merge</span>(ch[a][<span class=\"number\">0</span>],ch[b][<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\tch[a][<span class=\"number\">1</span>] = <span class=\"built_in\">merge</span>(ch[a][<span class=\"number\">1</span>],ch[b][<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t\tt.rt[u] = t.<span class=\"built_in\">merge</span>(t.rt[u],t.rt[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tt.<span class=\"built_in\">addall</span>(t.rt[u]);</span><br><span class=\"line\">\tt.<span class=\"built_in\">insert</span>(t.rt[u],val[u],<span class=\"number\">0</span>);</span><br><span class=\"line\">\tans+=t.sum[t.rt[u]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;val[i];</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(i,y);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"可持久化-Trie\"><a href=\"#可持久化-Trie\" class=\"headerlink\" title=\"可持久化 Trie\"></a>可持久化 Trie</h2><p>一般来说，一种数据结构，只要在修改的过程中，之前的结构没有变化，那么它就能可持久化，即可以以原空间规模访问任意一个历史版本。</p>\n<p>于是，有了可持久化 Trie。</p>\n<p>我们要实现的功能如下：能够从一个节点开始，访问到插入第 $i$ 个串前的 Trie 树。由于之前插入的子串是不会动的，我们可以利用之前的信息来完成可持久化。</p>\n<p><img src=\"https://s2.loli.net/2022/07/24/xe2h1yksIvaLcSN.png\" alt=\"Trie_2\"></p>\n<p>以插入串 $cab$ 为例（图 $3$）。</p>\n<p>最开始 $p$ 处于 $1$，$q$ 处于 $8$，我们先把 $1-&gt;2$ 的边连上，因为 $r\\neq s[1]$，所以连了不会影响之后的插入。但是，我们不能把 $9$ 那个点也一起连了，因为这样的话，之后的插入就要在那个点的子树中进行了，破坏了历史版本的信息，所以我们另开一个点 $3$。</p>\n<p>之后，像一般 Trie 的插入一样，$p$ 走到 $3$，$q$ 也走到 $9$，发现 $a = s[2]$，所以不能连到 $10$，而是另开一个点 $5$。</p>\n<p>$p$ 走到 $5$，$q$ 走到 $10$，发现 $t\\neq s[3]$，所以可以连到 $11$ 上。由于 $q$ 没有 $b$ 这个子节点，所以直接新建。</p>\n<p>最后 $p$ 走到 $7$，插入完成。</p>\n<p>插入的过程可以概括为：维护这一个历史版本和上一个历史版本走到的位置，除了插入串的节点要新建之外，剩下的都指向原来的版本，直到串插入完毕。</p>\n<h2 id=\"例题5\"><a href=\"#例题5\" class=\"headerlink\" title=\"例题5\"></a>例题5</h2><p><a href=\"https://www.luogu.com.cn/problem/P4735\">P4735 最大异或和</a></p>\n<p>给你一个序列，有两个操作：</p>\n<ol>\n<li>加入一个数。</li>\n<li>询问左端点在 $[l,r]$ 之间，右端点为序列终点的数异或起来，再异或一个 $x$ 的最大值。</li>\n</ol>\n<p>假设没有 $l,r$ 的限制，可以维护一个异或前缀和 $s$，之后就是求 $s[n]\\oplus s[i-1]\\oplus x$ 的最大值。把 $s[n]\\oplus x$ 看作一个整体，就是在 $n$ 个数里面找两个数异或的最大值，这不就是例题2吗？</p>\n<p>现在，我们加入一个限制 $r$，于是只能在 $1$~$r-1$ 中选一个 $s[i]$，发现这不就是只插入 $1$~$r-1$ 的 Trie 吗？查询 $r-1$ 的历史版本就能解决。</p>\n<p>最后，加入一个限制 $l$，于是只能在 $l-1$~$r-1$ 中选一个 $s[i]$，我们需要对每个节点打上一个标记，代表它的子树中出现时间最晚的数的出现时间，在贪心的基础上只递归出现时间 $\\geq l-1$ 的就行了。</p>\n<h3 id=\"Code：-5\"><a href=\"#Code：-5\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e5</span>+<span class=\"number\">10</span>,H = <span class=\"number\">24</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,s[N],tot;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Trie</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tr[N*<span class=\"number\">22</span>][<span class=\"number\">2</span>],tot,rt[N],lat[N*<span class=\"number\">24</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> now,<span class=\"type\">int</span> las,<span class=\"type\">int</span> i,<span class=\"type\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dep&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tlat[now] = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = (s[i]&gt;&gt;dep)&amp;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (las) tr[now][c^<span class=\"number\">1</span>] = tr[las][c^<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\ttr[now][c] = ++tot;</span><br><span class=\"line\">\t\t<span class=\"built_in\">insert</span>(tr[now][c],tr[las][c],i,dep<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\tlat[now] = <span class=\"built_in\">max</span>(lat[tr[now][<span class=\"number\">0</span>]],lat[tr[now][<span class=\"number\">1</span>]]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> now,<span class=\"type\">int</span> lim,<span class=\"type\">int</span> x,<span class=\"type\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dep&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> s[lat[now]]^x;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = (x&gt;&gt;dep)&amp;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lat[tr[now][c^<span class=\"number\">1</span>]]&gt;=lim) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(tr[now][c^<span class=\"number\">1</span>],lim,x,dep<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(tr[now][c],lim,x,dep<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\tt.lat[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tt.rt[tot] = ++t.tot;</span><br><span class=\"line\">\tt.<span class=\"built_in\">insert</span>(t.rt[tot],<span class=\"number\">0</span>,<span class=\"number\">0</span>,H);</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\ttot++;</span><br><span class=\"line\">\t\ts[tot] = s[tot<span class=\"number\">-1</span>]^x;</span><br><span class=\"line\">\t\tt.rt[i] = ++t.tot;</span><br><span class=\"line\">\t\tt.<span class=\"built_in\">insert</span>(t.rt[i],t.rt[i<span class=\"number\">-1</span>],tot,H);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">char</span> op;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"string\">&#x27;A&#x27;</span>)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\t\ttot++;</span><br><span class=\"line\">\t\t\ts[tot] = s[tot<span class=\"number\">-1</span>]^x;</span><br><span class=\"line\">\t\t\tt.rt[tot] = ++t.tot;</span><br><span class=\"line\">\t\t\tt.<span class=\"built_in\">insert</span>(t.rt[tot],t.rt[tot<span class=\"number\">-1</span>],tot,H);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;l&gt;&gt;r&gt;&gt;x;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;t.<span class=\"built_in\">query</span>(t.rt[r<span class=\"number\">-1</span>],l<span class=\"number\">-1</span>,s[tot]^x,H)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","字符串","Trie"]},{"title":"物质的分类","url":"/2022/02/11/%E7%89%A9%E8%B4%A8%E7%9A%84%E5%88%86%E7%B1%BB/","content":"<h2 id=\"物质的分类（-分散系-氧化物分类）\"><a href=\"#物质的分类（-分散系-氧化物分类）\" class=\"headerlink\" title=\"物质的分类（ 分散系 氧化物分类）\"></a>物质的分类（ 分散系 氧化物分类）</h2><span id=\"more\"></span>\n<h3 id=\"制备-Fe-OH-3-胶体的实验\"><a href=\"#制备-Fe-OH-3-胶体的实验\" class=\"headerlink\" title=\"制备$Fe(OH)_3$胶体的实验\"></a>制备$Fe(OH)_3$胶体的实验</h3><p>  $FeCl_3+3H_2O \\frac{\\Delta}{=} Fe(OH)_3（胶体）+3HCl$<br>  （原谅这丑陋的方程式）</p>\n<h5 id=\"要点：\"><a href=\"#要点：\" class=\"headerlink\" title=\"要点：\"></a>要点：</h5><p>  <strong>反应条件</strong>：加热<br>  要在$Fe(OH)_3$后面<strong>加上胶体 </strong><br>  不要和$NaOH$反应去了，这样会直接生成沉淀<br>  要用<strong>煮沸</strong>的<strong>蒸馏水</strong>，而且是将$FeCl_3$加入蒸馏水中，颜色变成<strong>红褐色</strong>时<strong>立即</strong>停止加热<br>  不能用<strong>玻璃棒搅拌</strong>，要<strong>振荡烧杯</strong><br>  淀粉溶液是<strong>胶体</strong>！  </p>\n<h5 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h5><p>  虽然反应是这样进行的，但是如果再加入适量$HCl$，会发生以下反应：$Fe(OH)_3+3HCl = FeCl_3+3H_2O$<br>  我的理解是因为胶体微粒带电，似乎从某种程度上阻止了反应的进行，但是加入$HCl$到一定程度后，两边的电荷逐渐失衡，反应才开始进行，为了电荷的再次平衡   </p>\n<h4 id=\"胶体的性质\"><a href=\"#胶体的性质\" class=\"headerlink\" title=\"胶体的性质\"></a>胶体的性质</h4><ul>\n<li>粒子大小介于$1nm$~$100nm$之间，不能透过半透膜  </li>\n<li>光学性质：丁达尔效应。实际上就是拿个激光笔照射之后有通路，就一定是胶体  </li>\n<li>运动学性质：布朗运动。解释是做无规则运动，好像也是因为这个性质具有介稳性  </li>\n<li>电学性质：电泳现象。通俗点说就是往哪边跑，极性就与哪边相反，异性相吸嘛  <ul>\n<li>应用：工厂静电除尘（尘是胶体）</li>\n<li>注意：胶体是电中性的，只有胶粒才带电</li>\n</ul>\n</li>\n<li>热力学性质：胶体的聚沉。貌似并不知道原理是什么<ul>\n<li>方法1：加入[[电解质]]（之后会讲）</li>\n<li>方法2：加入与胶粒带相反电荷的胶体（见$\\downarrow$的扩展）</li>\n<li>方法3：加热（实验中可能会考加热过度，现象是有红褐色固体生成）</li>\n<li>应用：三角洲形成，明矾净水，盐卤制豆腐</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"扩展：-1\"><a href=\"#扩展：-1\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h5><ol>\n<li>胶体的正负电荷<br>正电荷：金属氢氧化物（$Fe(OH)_3$），金属氧化物（$Fe_2O_3$）<br>负电荷：非金属氧化物（$As_2O_3$），金属硫化物（好像没看见？），但看见了金属（$Au$）  </li>\n<li>不同物态的胶体<br>气溶胶：烟、雾<br>液溶胶：$Fe(OH)_3$胶体、豆浆、淀粉<strong>溶液</strong><br>固溶胶：有色玻璃，烟水晶（?）</li>\n</ol>\n<h4 id=\"氧化物的分类\"><a href=\"#氧化物的分类\" class=\"headerlink\" title=\"氧化物的分类\"></a>氧化物的分类</h4><p>碱性氧化物：能和酸反应生成盐和水的氧化物，如$CuO$<br>酸性氧化物：能和碱反应生成盐和水的氧化物，如$CO_2, SO_3$<br>两性氧化物：酸碱特性皆具备，称为两性氧化物，如$Al_2O_3$<br>不成盐氧化物：两个特性都不具备的氧化物，如$NO,CO$<br><strong>特殊氧化物</strong>：好像只提到了$Fe_3O_4$和$Na_2O_2$这两个  </p>\n<h5 id=\"大体观点：\"><a href=\"#大体观点：\" class=\"headerlink\" title=\"大体观点：\"></a>大体观点：</h5><p><strong>碱性氧化物</strong> <strong>一定</strong>是 <strong>金属氧化物</strong>    <strong>没有反例！ </strong><br><strong>酸性氧化物</strong> 大部分是 <strong>非金属氧化物</strong>    反例：$Mn_2O_7$<br><strong>金属氧化物</strong> 不一定是 <strong>碱性氧化物</strong>    反例：$Mn_2O_7$（这个好像真的很好用），$Al_2O_3$（两性氧化物）<br><strong>非金属氧化物</strong> 不一定是 <strong>酸性氧化物</strong>    反例：$CO$（不成盐氧化物）<br><strong>酸性氧化物</strong> 大多可以和水反应生成相应的酸    反例：$SiO_2$<br><strong>碱性氧化物</strong> 大多不能和水反应生成相应的碱    反例：$Na_2O$，$CaO$  </p>\n<h4 id=\"补充错题：\"><a href=\"#补充错题：\" class=\"headerlink\" title=\"补充错题：\"></a>补充错题：</h4>","tags":["Knowledge","WHK"]},{"title":"简单的数学题 题解","url":"/2022/05/26/%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"简单的数学题-题解\"><a href=\"#简单的数学题-题解\" class=\"headerlink\" title=\"简单的数学题 题解\"></a>简单的数学题 题解</h1><h2 id=\"60分思路\"><a href=\"#60分思路\" class=\"headerlink\" title=\"60分思路\"></a>60分思路</h2><p>$\\sum_{i=1}^n\\sum_{j=1}^nij\\gcd(i,j)$</p>\n<p>枚举$\\gcd$：</p>\n<p>$\\sum_{d=1}^nd\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{n}{d}}ij[\\gcd(i,j)= 1]\\cdot d^2 \\iff \\sum_{d=1}^nd^3\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{n}{d}}ij[\\gcd(i,j)= 1]$</p>\n<p>把$\\gcd$化成$\\mu$：</p>\n<p>$\\sum_{d=1}^nd^3\\sum_{i=1}^{n/d}\\sum_{j=1}^{n/d}ij\\sum_{k|\\gcd(i,j)}\\mu(k)$<br><span id=\"more\"></span></p>\n<p>枚举$k$：</p>\n<p>$\\sum_{d=1}^nd^3\\sum_{k=1}^{n/d}\\mu(k)\\sum_{i’=1}^{n/kd}\\sum_{j’=1}^{n/kd}i’j’$</p>\n<p>后面的东西可以变化一下：</p>\n<p>$\\sum_{d=1}^nd^3\\sum_{k=1}^{n/d}\\mu(k)\\sum_{i’=1}^{n/kd}i’\\sum_{j’=1}^{n/kd}j’$</p>\n<p>用等差数列求和简化：</p>\n<p>$\\sum_{d=1}^nd^3\\sum_{k=1}^{n/d}\\mu(k)(\\frac{(1+\\frac{n}{kd})\\cdot \\frac{n}{kd}}{2})^2$</p>\n<p>这样就可以$O(\\sqrt n)$求解后面的式子了。</p>\n<p>前面的式子求解是$O(n)$的，总时间复杂度为$O(n\\sqrt n)$。</p>\n<h2 id=\"100分思路\"><a href=\"#100分思路\" class=\"headerlink\" title=\"100分思路\"></a>100分思路</h2><p>需要用到杜教筛，但是现在还没学，所以先放一下吧。</p>\n","tags":["Knowledge","数论","莫比乌斯反演"]},{"title":"糖果传递 题解","url":"/2022/04/12/%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"糖果传递-题解\"><a href=\"#糖果传递-题解\" class=\"headerlink\" title=\"糖果传递 题解\"></a>糖果传递 题解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>一切都是推式子。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>每个人都要补前面人的差值，补自己的差值。</p>\n<p>设$x_i$表示第$i$个人从第$i+1$个人那里拿了多少张牌，为正则是拿，为负则是送。</p>\n<p>于是，设第$i$个人的牌数是$s_i$，则一定满足式子$s_i+x_i-x_{i-1} = avg$。</p>\n<span id=\"more\"></span>\n<p>把所有人的式子都列出来：</p>\n<p>$s_1+x_1-x_n = avg\\\\s_2+x_2-x_1 = avg\\\\\\cdots\\\\s_n+x_n-x_{n-1} = avg$</p>\n<p>我们花费的代价是$|x_1|+|x_2|+\\cdots+|x_n|$，现在要使这个东西最小。</p>\n<p>这个东西直接凑不太好凑，我们考虑把它们都化为$x_1$的形式。</p>\n<p>$x_2 = avg-s_2+x_1\\\\x_3 = avg-s_3+avg-s_2+x_1 = 2avg-s_2-s_3+x_1\\\\x_4 = avg-s_4+2avg-s_2-s_3+x_1 = 3avg-s_2-s_3-s_4+x_1$</p>\n<p>于是，这个式子就变成了$|x_1|+|x_1+avg-s_2|+|x_1+2avg-s_2-s_3|+\\cdots +|x_1+(n-1)avg-(s_2+s_3+\\cdots +s_n)|$。</p>\n<p>显然，每个绝对值后面的数都是定值，这个可以直接预处理出来，我们不妨设每个绝对值后面的数为$f_i$。</p>\n<p>则，式子可以化为$|x_1+f_1|+|x_1+f_2|+\\cdots+|x_1+f_n|$。</p>\n<p>当$n$为偶数时，根据初中学习的绝对值相关知识，画个数轴出来，可以发现，当$x_1$在排序后的$f$数组中的$-f_{n/2}$和$-f_{n/2+1}$之间时，值最小。</p>\n<p>当$n$为奇数时，$x_1$在$-f_{(n+1)/2}$时，值最小。</p>\n<p>于是，我们先把$f_i$的值都算出来，再取$-f_{(n+1)/2}$，就是$x_1$的取值，把结果算一下就行了。</p>\n<h2 id=\"Code-：\"><a href=\"#Code-：\" class=\"headerlink\" title=\"$Code$：\"></a>$Code$：</h2><p>注意long long</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[N],f[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> avg = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tavg+=a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tavg/=n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tsum+=a[i];</span><br><span class=\"line\">\t\tf[i] = avg*(i<span class=\"number\">-1</span>)-sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(f+<span class=\"number\">1</span>,f+<span class=\"number\">1</span>+n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = f[(n+<span class=\"number\">1</span>)/<span class=\"number\">2</span>],ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans+=<span class=\"built_in\">abs</span>(x-f[i]);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","贪心"]},{"title":"约数","url":"/2022/04/02/%E7%BA%A6%E6%95%B0/","content":"<h1 id=\"约数\"><a href=\"#约数\" class=\"headerlink\" title=\"约数\"></a>约数</h1><h2 id=\"算数基本定理的推论\"><a href=\"#算数基本定理的推论\" class=\"headerlink\" title=\"算数基本定理的推论\"></a>算数基本定理的推论</h2><p>一个正整数$n$被唯一分解为$n = p_1^{c_1}p_2^{c_2}\\cdot \\cdot \\cdot p_m^{c_m}$，其中$c_i$都是正整数，$p_i$都是质数，且满足$p_1&lt;p_2&lt;\\cdot \\cdot \\cdot p_m$。</p>\n<p>则$n$的正约数个数为$(c_1+1)(c_2+1)\\cdot\\cdot\\cdot (c_m+1)$，可以看作每个质因子上面的幂都有$c_i+1$种选择。</p>\n<p>$n$的约数和为$(1+p_1+p_1^2+\\cdot\\cdot\\cdot+p_1^{c_1})\\cdot\\cdot\\cdot(1+p_m+p_m^2+\\cdot\\cdot\\cdot+p_m^{c_m})$，这可以看作每一个质因子不同幂次的不同结果相加，再乘起来就涵盖了每一种可能，也就是约数和。</p>\n<span id=\"more\"></span>\n<p>如果学了等比数列的可以快速计算这个式子：</p>\n<p>$1+p_i+p_i^2+\\cdot\\cdot\\cdot+p_i^{c_i} = \\frac{p_i^{c_i+1}-1}{p_i-1}$</p>\n<p>这样只需要$O(\\log n)$的时间就能计算约数和。</p>\n<h2 id=\"求一个数的约数集合\"><a href=\"#求一个数的约数集合\" class=\"headerlink\" title=\"求一个数的约数集合\"></a>求一个数的约数集合</h2><p>我们采用试除法，如前面所说，$n$如果能表示为$n = a*b$，那么$a$和$b$中必然有一个数小于等于$\\sqrt{n}$。</p>\n<p>所以我们只用找到所有小于等于$\\sqrt{n}$的约数，就能得到$n$所有的约数。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> k = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (n%i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (n/i!=i) a.<span class=\"built_in\">push_back</span>(n/i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a.<span class=\"built_in\">begin</span>(),a.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"type\">int</span> sz = a.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;sz;i++) cout&lt;&lt;a[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此算法的时间复杂度为$O(\\sqrt{n})$</p>\n<h2 id=\"求1-n中所有数的约数集合\"><a href=\"#求1-n中所有数的约数集合\" class=\"headerlink\" title=\"求1~n中所有数的约数集合\"></a>求1~n中所有数的约数集合</h2><p>这时，如果使用简单的试除法，就太慢了，时间复杂度为$O(n\\sqrt{n})$。</p>\n<p>我们发现，对于一个数$d$，它的所有倍数都一定有$d$这一个约数，所以我们只要枚举约数，标记这个约数的所有倍数就可以在$O(n\\log n)$的时间内完成。</p>\n<p>推论：1~n中每个数约数的总和为$O(n\\log n)$个，每个数平均有$\\log n$个约数。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; a[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n/i;j++)&#123;</span><br><span class=\"line\">\t\t\ta[i*j].<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(a[i].<span class=\"built_in\">begin</span>(),a[i].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sz = a[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;sz;j++) cout&lt;&lt;a[i][j]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>练习：</p>\n<p><a href=\"https://www.luogu.com.cn/problem/U198025\">U198025</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1463\">P1463</a></p>\n<h2 id=\"最大公约数\"><a href=\"#最大公约数\" class=\"headerlink\" title=\"最大公约数\"></a>最大公约数</h2><p>两个数的约数中，最大的公共的约数叫做最大公约数。</p>\n<p>结论1：$gcd(a,b)\\cdot lcm(a,b) = a\\cdot b$。</p>\n<p>证明：$lcm(a,b)$中，$a,b$不共同拥有的质因数一定存在，$a,b$共同拥有的质因数只要达到最大的一个即可，所以除掉公共的因数，就是$lcm(a,b)$。</p>\n<h3 id=\"求最大公约数\"><a href=\"#求最大公约数\" class=\"headerlink\" title=\"求最大公约数\"></a>求最大公约数</h3><p>$gcd(a,b) = gcd(b,a\\ mod \\ b)$。</p>\n<p>证明：</p>\n<ol>\n<li>$a\\leq b$，$gcd(a,b) = gcd(b,a \\ mod \\ b) = gcd(b,a)$。</li>\n<li>$a&gt;b$，$gcd(a,b) = gcd(b,a \\ mod \\ b) = gcd(b,a-k\\cdot b)$，如果最大公约数$d|a$，$d|b$，那么$d|k\\cdot b$，则$d|a-k\\cdot b$。</li>\n</ol>\n<h2 id=\"互质\"><a href=\"#互质\" class=\"headerlink\" title=\"互质\"></a>互质</h2><p>如果$gcd(a,b) = 1$，那么$a$和$b$就互质。</p>\n<p>对于3个数或更多数的情况，我们把$gcd(a,b,c) = 1$称为$a$、$b$和$c$这3个数互质。</p>\n<h2 id=\"欧拉函数\"><a href=\"#欧拉函数\" class=\"headerlink\" title=\"欧拉函数\"></a>欧拉函数</h2><p>1~n中和n互质的数的个数叫做欧拉函数，记为$\\varphi(n)$</p>\n<p>怎么计算这个东西呢？</p>\n<p>我们考虑哪些数和n互质，所有n的质因子的倍数都和n互质，而且仅有这些数和n互质，所以我们需要把这些数都找出来。</p>\n<p>对于n的一个质因子p，有$n/p$个p的倍数，对于n的另一个质因子q，有$n/q$个q的倍数，把这些都减掉之后，还要加上既是p的倍数，又是q的倍数的数，于是要加上$n/pq$，这样，对于只含有两个质因子p、q的n来说，$\\varphi(n) = n-n/p-n/q+n/pq =(n-n/p)-1/q(n-n/p) = n(1-1/q)(1-1/p)$。</p>\n<p>把这个性质推广到$n = p_1^{c_1}p_2^{c_2}\\cdot \\cdot \\cdot p_m^{c_m}$，可以得到：</p>\n<p>性质1：$\\varphi(n) = n(1-\\frac{1}{p_1})\\cdot\\cdot\\cdot (1-\\frac{1}{p_m})$。</p>\n<p>性质2：当$n&gt;1$时，与n互质的数的和为$n/2\\cdot\\varphi(n)$。</p>\n<p>证明：若c是n的约数，那么n-c也是n的约数，所以与n不互质的数成对出现，和都为n，那么平均值就是$n/2$，所以和n互质的数的平均值也是$n/2$，于是与n互质的数的和就是$n/2\\cdot\\varphi(n)$。</p>\n<p>性质3：若$a,b$互质，那么$\\varphi(ab) = \\varphi(a)\\cdot\\varphi(b)$。</p>\n<p>证明：直接按定义式计算即可。</p>\n<p>虽然这个性质看上去比较显然，但是由此我们可以引出一个重要的东西：积性函数。</p>\n<p>如果当a和b互质时，有$f(ab) = f(a)\\cdot f(b)$，那么称函数$f(x)$为积性函数。</p>\n<p>性质4：对于所有积性函数$f(x)$，$f(n) = \\Pi_{i=1}^mf(p_i^{c_i})$，此处$p_i$和$c_i$是n按照算数基本定理分解出来的质因数和对应的幂。</p>\n<p>证明：因为对于任意两个不相同的$p_i$来说，它们肯定互质，所以可以按照积性函数的性质乘起来，之后就得到了n。</p>\n<p>性质5：若$p|n$且$p^2|n$，则$\\varphi(n) = \\varphi(n/p)\\cdot p$，这个可以由定义得到。</p>\n<p>性质6：若$p|n$且$p^2\\nmid n$，则$\\varphi(n) = \\varphi(n/p)\\cdot p\\cdot \\frac{p-1}{p} = \\varphi(n)\\cdot(p-1)$。</p>\n<p>性质7：$\\sum_{d\\mid n}\\varphi(d) = n$。</p>\n<p>证明：好像还不会证。。。</p>\n","tags":["Knowledge","数学"]},{"title":"约数个数和 题解","url":"/2022/05/29/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"约数个数和-题解\"><a href=\"#约数个数和-题解\" class=\"headerlink\" title=\"约数个数和 题解\"></a>约数个数和 题解</h1><h2 id=\"Rating-For-advancer\"><a href=\"#Rating-For-advancer\" class=\"headerlink\" title=\"Rating: For advancer\"></a>Rating: For advancer</h2><p>这篇题解是首个版本，可能会有部分不严谨的地方，有些方法还没有想过，但是足以指导您做出此题。</p>\n<h2 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h2><p>$\\sum_{i=1}^n\\sum_{j=1}^md(ij)$，其中$d(x)$表示$x$的约数个数。</p>\n<h2 id=\"引理1：\"><a href=\"#引理1：\" class=\"headerlink\" title=\"引理1：\"></a>引理1：</h2><p>$d(ij) = \\sum_{p|i}\\sum_{q|j}[\\gcd(p,q) = 1]$</p>\n<h3 id=\"证明：\"><a href=\"#证明：\" class=\"headerlink\" title=\"证明：\"></a>证明：</h3><p>使用反证法。设有两个约数$i,j$，满足$\\gcd(i,j) = d(d\\neq 1)$。</p>\n<span id=\"more\"></span>\n<p>显然，$\\gcd(\\frac{i}{d},jd) = 1$，且$\\frac{i}{d}\\cdot jd = i\\cdot j$。</p>\n<p>于是，$\\gcd(i,j)\\neq 1$的$i,j$没有贡献。</p>\n<p>这其实算性质吧，但是我感觉没见过不是很好往这个方向推。</p>\n<p>总之，要求的式子转化成了：</p>\n<p>$\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{p|i}\\sum_{q|j}[\\gcd(p,q) = 1]$</p>\n<p>这里的$p,q$不是很好处理，考虑把它们提出来：</p>\n<p>$\\sum_{p=1}^n\\sum_{q=1}^m[\\gcd(p,q) = 1] \\lfloor \\frac{n}{p}\\rfloor \\lfloor \\frac{m}{q}\\rfloor$</p>\n<p>之后用反演结论：</p>\n<p>$\\sum_{p=1}^n\\sum_{q=1}^m\\lfloor \\frac{n}{p}\\rfloor \\lfloor \\frac{m}{q} \\rfloor\\sum_{k|\\gcd(p,q)}\\mu(k)$</p>\n<p>枚举$\\gcd$：</p>\n<p>$\\sum_{k=1}^{\\min(n,m)}\\mu(k)\\sum_{k|p,p\\leq n}\\sum_{k|q,q\\leq m}\\lfloor \\frac{n}{p}\\rfloor \\lfloor \\frac{m}{q}\\rfloor$</p>\n<p>发现中间两个求和等价于</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=k;p&lt;=n;p+=k)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> q=k;q&lt;=m;q+=k)</span><br></pre></td></tr></table></figure>\n<p>于是可以设$p’ = \\frac{p}{k}$，$q’ = \\frac{q}{k}$，将式子进一步化简：</p>\n<p>$\\sum_{k=1}^{min(n,m)}\\mu(k)\\sum_{p’=1}^{\\frac{n}{k}}\\sum_{q’ = 1}^{\\frac{m}{k}}\\lfloor \\frac{n}{p’k}\\rfloor \\lfloor \\frac{m}{q’k}\\rfloor$</p>\n<p>由于$p’$相对固定，所以可以各回各家：</p>\n<p>$\\sum_{k=1}^{min(n,m)}\\mu(k)\\sum_{p’=1}^{\\frac{n}{k}}\\lfloor \\frac{n}{p’k}\\rfloor\\sum_{q’=1}^{\\frac{m}{k}}\\lfloor \\frac{m}{q’k}\\rfloor$</p>\n<p>用三次整除分块！但是数据太多，过不了。</p>\n<p>既然有多组数据，就意味着要预处理出一些值才能快速处理每组数据。</p>\n<p>发现，后面两个求和的形式很相像，把它抽象出来：</p>\n<p>$\\sum_{i=1}^{\\frac{a}{b}}\\lfloor \\frac{a}{b\\cdot c}\\rfloor$</p>\n<h2 id=\"引理2：\"><a href=\"#引理2：\" class=\"headerlink\" title=\"引理2：\"></a>引理2：</h2><p>$\\lfloor \\frac{a}{b\\cdot c}\\rfloor = \\lfloor \\frac{\\lfloor \\frac{a}{c}\\rfloor}{b}\\rfloor$</p>\n<h3 id=\"证明：-1\"><a href=\"#证明：-1\" class=\"headerlink\" title=\"证明：\"></a>证明：</h3><p>设$a = kc+r(r&lt;c)$，则$\\lfloor \\frac{kc+r}{b\\cdot c}\\rfloor \\iff \\lfloor \\frac{k}{b}+\\frac{r}{b\\cdot c}\\rfloor$，$\\lfloor \\frac{\\lfloor \\frac{a}{c}\\rfloor}{b}\\rfloor\\ \\iff \\lfloor \\frac{\\lfloor k+\\frac{r}{c}\\rfloor}{b}\\rfloor \\iff \\lfloor \\frac{k}{b}\\rfloor$。</p>\n<p>在题目中，所有的$b$都是正整数，所以$\\frac{r}{b\\cdot c}&lt; 1$，即左右两边相等。</p>\n<p>于是，我们转化为了下面的式子：</p>\n<p>$\\sum_{i=1}^x\\lfloor \\frac{x}{i}\\rfloor$</p>\n<p>这可以用整除分块$O(n\\sqrt n)$求出。</p>\n<p>这样，每次询问就可以用整除分块求出$\\frac{n}{k}$相等的部分，$O(\\sqrt n)$求解。</p>\n<p>总时间复杂度为$O(n\\sqrt n+T\\sqrt n)$，可以通过本题。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,m,vis[N],pri[N],tot,mu[N],sum[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = <span class=\"number\">5e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) mu[i]+=mu[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=i;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tr = i/(i/l);</span><br><span class=\"line\">\t\t\tsum[i]+=(r-l+<span class=\"number\">1</span>)*(i/l);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> Min = <span class=\"built_in\">min</span>(n,m),r,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=Min;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tr = <span class=\"built_in\">min</span>(n/(n/l),m/(m/l));</span><br><span class=\"line\">\t\t\tans+=(mu[r]-mu[l<span class=\"number\">-1</span>])*sum[n/l]*sum[m/l];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","数学","数论","莫比乌斯反演","整除分块"]},{"title":"能量采集 题解","url":"/2022/05/26/%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"能量采集-题解\"><a href=\"#能量采集-题解\" class=\"headerlink\" title=\"能量采集 题解\"></a>能量采集 题解</h1><p>$\\sum_{i=1}^n\\sum_{j=1}^m\\gcd(i,j)\\cdot 2 -1$</p>\n<h2 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h2><p>枚举$\\gcd$：</p>\n<p>$\\sum_{d=1}^{min(n,m)}d\\cdot 2\\sum_{i=1}^n\\sum_{j=1}^m[gcd(i,j) = d]-nm$</p>\n<p>同时除以$d$：</p>\n<p>$2\\sum_{d=1}^{min(n,m)}d\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{m}{d}}[gcd(i,j) = 1]-nm$</p>\n<span id=\"more\"></span>\n<p>把$\\gcd$变成$\\mu$：</p>\n<p>$2\\sum_{d=1}^{min(n,m)}d\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{m}{d}}\\sum_{k|gcd(i,j)}\\mu(k)-nm$</p>\n<p>枚举$k$：</p>\n<p>$2\\sum_{d=1}^{min(n,m)}d\\sum_{k=1}^{min(\\frac{n}{d},\\frac{m}{d})}\\mu(k)\\lfloor \\frac{n}{dk}\\rfloor \\lfloor \\frac{m}{dk}\\rfloor-nm$</p>\n<p>时间复杂度为$O(n\\sqrt n)$，勉强可以通过。</p>\n<h2 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h2><p>但是，我们要把它往欧拉函数推：</p>\n<p>$2\\sum_{i=1}^{n}\\sum_{j=1}^m\\gcd(i,j)-nm$</p>\n<p>运用$\\sum_{k|n}\\varphi(k) = n$的性质：</p>\n<p>$2\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{k|\\gcd(i,j)}\\varphi(k)-nm$</p>\n<p>把$k$提到前面去：<br>$2\\sum_{k=1}^{min(n,m)}\\varphi(k)\\lfloor \\frac{n}{k}\\rfloor \\lfloor \\frac{m}{k}\\rfloor-nm$</p>\n<p>运用整除分块，可以在$O(\\sqrt n)$的时间内求出这个式子。</p>\n<p>预处理欧拉函数前缀和是$O(n)$的。</p>\n<p>总时间复杂度为$O(n+\\sqrt n)$。</p>\n","tags":["Knowledge","数论","莫比乌斯函数"]},{"title":"网络流初步","url":"/2022/03/07/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E6%AD%A5/","content":"<h2 id=\"求解最大流\"><a href=\"#求解最大流\" class=\"headerlink\" title=\"求解最大流\"></a>求解最大流</h2><h3 id=\"Edmond-Karp算法（EK算法）\"><a href=\"#Edmond-Karp算法（EK算法）\" class=\"headerlink\" title=\"Edmond Karp算法（EK算法）\"></a>Edmond Karp算法（EK算法）</h3><p>这种算法不是很常用，但是比较好理解，没有什么分层图之类的优化技巧，可以直接感性理解求解网络流问题的基本思想。此算法复杂度为$O(nm^2)$，虽说很多时候卡不满，但是和SPFA一样，<strong>有被不经意间（刻意）卡掉的风险</strong>。</p>\n<span id=\"more\"></span>\n<p>首先，我们要知道什么是一个<strong>网络</strong>。其实是给你一张图，其中有一个<strong>源点</strong>$s$，一个<strong>汇点</strong>$t$，源点负责发放流量，汇点负责收集流量，网络中的边都有<strong>流量限制</strong>，也就是说经过这条边的流量不能超过这个限制。我们要的是到达汇点的流量最大。其中源点供应的流量是无限的。</p>\n<p>遍历整个图，每次尝试寻找一条<strong>增广路</strong>（一条从$s$到$t$的路径，其中所有边的剩余流量都大于$0$），在找不到增广路时就找到了<strong>最大流</strong>。每找到一条增广路，我们就把这条路的所有边的剩余容量减少，表示有流从这里经过。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/flow1.png\" alt=\"\"></p>\n<p>我们先走$4 \\rightarrow 2 \\rightarrow3$，这样有20的流量从$2$到达$3$，我们将$4\\rightarrow2\\rightarrow3$这条增广路的剩余流量修改一下，$4\\rightarrow2$变成$10$，$2\\rightarrow3$变成$0$，这样我们就得到了一个<strong>残量网络</strong>（即已经有部分流量被占用了）。再走$4\\rightarrow3$，$4\\rightarrow3$修改为$0$。走$4\\rightarrow2\\rightarrow1\\rightarrow3$，由于最小的边是$4\\rightarrow2$，所以只有$10$的流量流到$3$。</p>\n<p>于是，我们就得到了这个网络的最大流量：$50$。</p>\n<p>但是，随便找一条增广路就是最优的吗，显然不是：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/1.png\" alt=\"\"></p>\n<p>如上图，每条边的容量都是$1$，那么我们随便选一个增广路：$s\\rightarrow1\\rightarrow2\\rightarrow t$，这样我们就得到了$1$的流量，但是$s\\rightarrow2$和$1\\rightarrow t$都流不了任何东西了。</p>\n<p>换一种选法：$s\\rightarrow1\\rightarrow t$和$s\\rightarrow2\\rightarrow t$，这样我们就可以得到$2$的流量，比之前瞎选的优。</p>\n<p>如果不能瞎选，该如何解决这种问题呢？</p>\n<p>由于网络有很多种，我们显然不能针对每种情况都设计一个算法，使得每次选择的路径都是最优的，更好的方法是不断尝试，逐渐把不优的替换掉，而这种替换需要一个反悔的工具：<strong>反向边</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/2.png\" style=\"zoom:67%;\" /></p>\n<p>我们再次从$s$开始寻找增广路，可以从$s\\rightarrow2\\rightarrow1\\rightarrow t$，这样就可以得到最大流量$2$了。</p>\n<p>但这样为什么是对的呢？</p>\n<p>这一次走了从$2\\rightarrow1$的反向边，可以看作$1$原来流到$2$的流回去了（反向边相当于把流送回去），再流向之后走的$1\\rightarrow t$，而原来流向$2\\rightarrow t$的流量由$s\\rightarrow2$提供，这样就可以得到一条增广路了。当没有增广路时，说明我们找到了最大流（虽然我并不会证明这个的正确性）。</p>\n<p>时间复杂度简易证明：</p>\n<p>假设网络上有$n$个点，$m$条边。</p>\n<p>第一个结论：在EK算法中，$t$和$s$间的最短路长度一定是不降的，因为每次增广一个路径，这个路径按照$BFS$是最短的路径，所以每次必然减少一个最短路径，我们考虑最坏的情况，变成一个二分图之类的东西，最短路的长度都为$3$，这时需要增广$m$次，也就是说最短路的长度不变时，最多增广$m$次。</p>\n<p>第二个结论：每次$BFS$的时间复杂度为$O(m)$。</p>\n<p>第三个结论：每次增广中必然出现一个边，其剩余流量被完全占用，这条边要再有流量，需要反向边被增广，也就是说它再有剩余流量时，肯定是$t$和$s$之间的最短距离增加$2$时，才能被再次增广。由于一共只有$n$个点，最短路的长度最大是$n$，改变次数最多为$n/2$次。</p>\n<p>综合一、三结论，可得增广复杂度最多为$O(nm)$，而每次增广的复杂度最多时$O(m)$，所以EK算法的时间复杂度是$O(nm^2)$。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,tim = <span class=\"number\">1</span>,vis[N],inc[N],pre[N],Max;</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\tq.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\tvis[s] = tim;</span><br><span class=\"line\">\tinc[s] = inf;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; vis[y]!=tim)&#123;</span><br><span class=\"line\">\t\t\t\tinc[y] = <span class=\"built_in\">min</span>(inc[x],edge[i].w);</span><br><span class=\"line\">\t\t\t\tpre[y] = i;</span><br><span class=\"line\">\t\t\t\tvis[y] = tim;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = t,incf = inc[t];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (now!=s)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> i = pre[now];</span><br><span class=\"line\">\t\tedge[i].w-=incf;</span><br><span class=\"line\">\t\tedge[i^<span class=\"number\">1</span>].w+=incf;</span><br><span class=\"line\">\t\tnow = edge[i^<span class=\"number\">1</span>].to;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tMax+=incf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,w;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,w);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">\t\ttim++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;Max&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"Dinic算法\"><a href=\"#Dinic算法\" class=\"headerlink\" title=\"Dinic算法\"></a>Dinic算法</h3><p>主要思想：</p>\n<p>先做一次BFS将图按到$s$的最短路长度分层，之后做一次DFS（每次增广时可以多路增广），每次只向最短路长度比它大$1$的点输出流量，这样找下去，直到$t$到$s$没有路径，说明没有增广路了，也就是找到了最大流。</p>\n<p>时间复杂度证明：</p>\n<p>第一个结论：每次增广，必然把所有能够增广的都增广了，也就是说$t$到$s$的最短路的长度至少增加$1$，最多增加$n$次</p>\n<p>第二个结论：每次$BFS$，时间复杂度为$O(m)$，每次$DFS$，我们都要维护一个当前弧，也就是说当前弧最多变化$nm$次，于是单次增广的时间复杂度最大为$O(nm)$</p>\n<p>综合一、二结论，Dinic算法的时间复杂度最大为$O(n^2m)$</p>\n<p>也就是说，它适合处理稠密图，但在$n$是$1e3$级别，$m$是$1e5$级别，Dinic算法可能无法在给定时间内处理所有情况，这时就需要用到HLPP了。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,d[N],now[N];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> ans;</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(d,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(d));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\td[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tnow[s] = head[s];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !d[y])&#123;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t\t\td[y] = d[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tnow[y] = head[y];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> flow)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v,use,res = flow,i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=now[u];i &amp;&amp; res;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\tnow[u] = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; d[v] == d[u]+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tuse = <span class=\"built_in\">dfs</span>(v,<span class=\"built_in\">min</span>(edge[i].w,res));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!use) d[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tedge[i].w-=use;</span><br><span class=\"line\">\t\t\tedge[i^<span class=\"number\">1</span>].w+=use;</span><br><span class=\"line\">\t\t\tres-=use;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> flow-res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,w;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,w);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flow;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tflow = <span class=\"built_in\">dfs</span>(s,inf);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!flow) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tans+=flow;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","网络流"]},{"title":"背包问题浅析","url":"/2022/02/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/","content":"<h2 id=\"最基础的背包——01背包\"><a href=\"#最基础的背包——01背包\" class=\"headerlink\" title=\"最基础的背包——01背包\"></a>最基础的背包——01背包</h2><p>问题：</p>\n<p>给定一个容量为$w$的背包，有$n$件物品，每件物品都有一个价值$v$和一个体积$c$，问背包能装下的物品的最大价值和</p>\n<p>思路：</p>\n<p>每件物品都有选或不选(0或1)两种状态，考虑用此作为$dp$的一个维度，对于特定容量的价值，是从之前的容量的价值递推出来的，故可以用此作为$dp$的第二个维度，于是就有了$dp$数组$f[i][j]$表示考虑了前$i$个物品，容量为$j$时的最大价值</p>\n<p>如何转移呢？</p>\n<span id=\"more\"></span>\n<p>对$f$数组的修改必然涉及到一个变量：价值$v$，所以需要$v$参与$dp$的转移方程，稍加考虑即可推出一个简明的方程：</p>\n<p>$f[i][j] = max(f[i-1][j],f[i-1][j-c[i]]+v[i])$</p>\n<p>$max$的第一项表示不选择这个物品，直接使用$i-1$个物品的最大价值；第二项表示选择这个物品，所获得的价值是不放这个物品的背包的最大价值加上这个物品的价值</p>\n<p>可以发现，这个方程只和第$i$项和第$i-1$项有关，所以可以使用滚动数组做空间优化，即$f[j] = max(f[j],f[j-c[i]]+v[i])$</p>\n<p>但是，需要注意此处可能对$f[j]$进行修改，但是我们需要用的是修改之前的值，所以需要倒序修改$f[j]$，防止$f[j-c[i]]$变成了现在的价值，而不是在放入$i-1$个物品的价值</p>\n<p>时间复杂度：$O(nw)$</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1048\">P1048 采药</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> w,n,v[<span class=\"number\">105</span>],c[<span class=\"number\">105</span>],f[<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;w&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;c[i]&gt;&gt;v[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=w;j&gt;=c[i];j--) f[j] = <span class=\"built_in\">max</span>(f[j],f[j-c[i]]+v[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[w]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"01背包的变形——完全背包\"><a href=\"#01背包的变形——完全背包\" class=\"headerlink\" title=\"01背包的变形——完全背包\"></a>01背包的变形——完全背包</h2><p>问题：</p>\n<p>给定一个容量为$w$的背包，有$n$<strong>种</strong>物品，每<strong>种</strong>物品都有一个价值$v$和一个体积$c$，<strong>且数量无限</strong>，问背包能装下的物品的最大价值和</p>\n<p>思路：</p>\n<p>还是考虑原来的$dp$方程：</p>\n<p>$f[j] = max(f[j],f[j-c[i]]+v[i])$</p>\n<p>把修改顺序变为正序修改，思考一下$f[j]$的意义</p>\n<p>当$j’ = j+c[i]$时，$f[j’] = f[j]+v[i]$，此时的$f[j]$表示的是考虑<strong>前$i$个</strong>物品的最大值，显然当前物品放入的情况也被考虑进去了，所以此时正序递推正好满足题目要求</p>\n<p>时间复杂度：$O(nw)$</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1616\">P1616 疯狂的采药</a></p>\n<p><strong>注意：</strong></p>\n<p>1.数据范围更改了</p>\n<p>2.由于$w$可能到$1e7$，而且每种物品的价值可能到$1e4$，如果一件物品，它的价值是$1e4$，体积是$1$，那么结果可能会到$1e11$，需要开$long\\ long$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> w,n,v[<span class=\"number\">10005</span>],c[<span class=\"number\">10005</span>];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> f[<span class=\"number\">10000005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;w&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;c[i]&gt;&gt;v[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=c[i];j&lt;=w;j++) f[j] = <span class=\"built_in\">max</span>(f[j],f[j-c[i]]+v[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[w]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"优化后的01背包——多重背包\"><a href=\"#优化后的01背包——多重背包\" class=\"headerlink\" title=\"优化后的01背包——多重背包\"></a>优化后的01背包——多重背包</h2><p>问题：</p>\n<p>给定一个容量为$w$的背包，有$n$种物品，每种物品都有一个价值$v$和一个体积$c$，<strong>且数量为$m$个</strong>，问背包能装下的物品的最大价值和</p>\n<p>因为每种物品数量有限，所以无法用完全背包求解（可能会使用多于$m$个物品），考虑将其转化为01背包</p>\n<p>最朴素的想法是把每种物品拆成$m$个单独的物品，把所有的物品都单独拿出来，这样就变成了01背包问题</p>\n<p>但是，这样做的复杂度是$O(nmw)$的，在$n \\geq 1000$时就跑不过了，所以要考虑优化</p>\n<p>由于二进制的很多特殊性质，以及对$log$的谜之追求，出现了一种优化方法：二进制拆分</p>\n<p><del>众所周知，任何一个数都可以被表示为二进制形式</del></p>\n<p>例如：$ 42 = (101010)_2$</p>\n<p>所以，我们把这$m$个物品拆成一堆二进制，例如上面的$42$可以拆成$(1)_2=1$,$(10)_2=2$,$(100)_2=4$,$(1000)_2=8$,$(10000)_2=16$,最后剩下来一个$11$。</p>\n<p>不难看出，前面$5$个二进制可以组成$0 \\sim 31$中的任何一个数，而其中的$32 \\sim 42$中的所有数都可以由$21 \\sim 31$加上$11$得到，所以$0 \\sim 42$中的所有数都可以由这些拆出来的数组合得到</p>\n<p>这样，我们可以把每个背包拆成这些物品，之后当作01背包求解，于是复杂度就降低到了$O(n \\log mw)$</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P6567\">P6567 买表</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">4e2</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,k[N],a[N],t,f[<span class=\"number\">500010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;k[i]&gt;&gt;a[i];</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> bas = k[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">30</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[i]&lt;(<span class=\"number\">1</span>&lt;&lt;j)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">500005</span>;p&gt;=bas;p--) <span class=\"keyword\">if</span> (f[p-bas]) f[p] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tbas&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\ta[i]-=(<span class=\"number\">1</span>&lt;&lt;j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[i])&#123;</span><br><span class=\"line\">\t\t\tbas = a[i]*k[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">500005</span>;j&gt;=bas;j--) <span class=\"keyword\">if</span> (f[j-bas]) f[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;t;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (f[t]) cout&lt;&lt;<span class=\"string\">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"融合的01背包——分组背包\"><a href=\"#融合的01背包——分组背包\" class=\"headerlink\" title=\"融合的01背包——分组背包\"></a>融合的01背包——分组背包</h2><p>问题：</p>\n<p>给你$n$个物品，每个物品属于一个组，同一组中只能选择一个物品，问容量为$m$的背包的最大价值</p>\n<p>思路：</p>\n<p>同一组中的所有物品都只能选一次，我们通过01背包来限制选择的次数</p>\n<p>同一组中的所有物品只能选一个，我们通过同一价值来避免一个组中选择多个物品</p>\n<p>时间复杂度：$O(nm)$</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1757\">P1757 通天之分组背包</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,f[N];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; v[N],w[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\tw[z].<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">\t\tv[z].<span class=\"built_in\">push_back</span>(y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sz = w[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=m;j&gt;=<span class=\"number\">0</span>;j--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;sz;p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (j&gt;=w[i][p])&#123;</span><br><span class=\"line\">\t\t\t\t\tf[j] = <span class=\"built_in\">max</span>(f[j],f[j-w[i][p]]+v[i][p]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","DP"]},{"title":"自建题目目录与解答","url":"/2022/01/15/%E8%87%AA%E5%BB%BA%E9%A2%98%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%8E%E8%A7%A3%E7%AD%94/","content":"<h2 id=\"Tri\"><a href=\"#Tri\" class=\"headerlink\" title=\"Tri\"></a><a href=\"https://www.luogu.com.cn/problem/U198025\">Tri</a></h2><p>首先考虑最暴力的做法，只用把所有的三角形数都枚举一遍，再看看因数数量即可，但是，假设判断了$q$个三角形数，其中每个数为$m$，如果$\\sqrt m$判断因数是否符合条件，会让总复杂度达到$q \\sqrt m$级别的，这显然是无法接受的</p>\n<p>于是想到一个定理：</p>\n<p>如果一个数$p$能够被表示为$p = {a_1}^{k1}+{a_2}^{k2}+…+{a_n}^{k_n}$，那么$p$的因数个数即为$(k_1+1)<em>(k_2+1)</em>…*(k_n+1)$，这代表我们只需要知道一个数的所有质因数，就可以知道它的约数个数，于是总时间复杂度就被降低到了$O(q\\log m)$级别的，有了很可观的改善</p>\n<span id=\"more\"></span>\n<p>$Sample \\ Code:$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e6</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">1e6</span>,k,vis[N*<span class=\"number\">2</span>],pri[N],tot;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sum;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&gt;N || vis[i]&lt;pri[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">1</span>,coun;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot &amp;&amp; x;i++)&#123;</span><br><span class=\"line\">\t\tcoun = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%pri[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcoun++;</span><br><span class=\"line\">\t\t\tx/=pri[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt*=coun;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cnt&gt;k) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tsum+=i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">chk</span>(sum)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;sum&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但是对于$n\\geq 1200$，这种算法也无法在$1.5s$的时限内跑完，所以还需要优化</p>\n<p>如何优化呢？</p>\n<p>因为三角形数是形为$p*(p+1)/2$的数，所以这个$p$必然是根号级别的，可以从这里下手</p>\n<p>而且易证$p$和$p+1$是互质的，其中包含的质因数必然完全不同，所以三角形数的因数可以由$p$的因数和$p+1$的因数相乘得到</p>\n<p>可以先把一定范围内的数的因数预处理出来，之后判断时直接调用即可</p>\n<p>这里采用了与上一份代码类似的因数个数计算方法</p>\n<p>$Sample \\ Code:$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1.5e5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">1e5</span>,k,vis[N*<span class=\"number\">2</span>],pri[N],tot,v[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&gt;N || vis[i]&lt;pri[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">1</span>,coun;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\tcoun = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%pri[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcoun++;</span><br><span class=\"line\">\t\t\tx/=pri[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt*=coun;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++) v[i] = <span class=\"built_in\">get</span>(i);</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i%<span class=\"number\">2</span>) ans = v[i]*v[(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = v[i/<span class=\"number\">2</span>]*v[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans&gt;k)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">1ll</span>*i*(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;Set n to a bigger value&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但是，对于更大的$n$，这种算法却出奇的慢，原因就在于$get$函数中大量使用取模和除法操作，而且判断了很多不能整除的质数，最后可能还没有最简单的加法来得快</p>\n<p>而且一个一个累加，虽然看上去很慢，但是每一个因数都累加到了，绝无重复操作和无用操作，极大的提高了算法的效率</p>\n<p>这里采用尝试法，把所有因数都试出来，虽然看上去接近于$O(n^2)$，但是由于每个数的平均质因数在$log$级别，所以其实是接近$O(n*\\log n)$再带一个大常数的（前$1e7$个数的因数计算花费$2s$）</p>\n<p>$Sample \\ Code:$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2.8e6</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">2.5e6</span>,k,v[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i;j&lt;=N;j+=i) v[j]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&amp;<span class=\"number\">1</span>) ans = v[i]*v[(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = v[i/<span class=\"number\">2</span>]*v[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans&gt;k)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">1ll</span>*i*(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;Set n to a bigger value&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>于是，这个简短的代码就是这道题目前的最优解了，题解愉快的结束了！</p>\n<p>为了防止不必要的卡常，已把本题时限开到$2s$，默认开启$O2$优化，即使你的$N$设置的不是那么微妙，也是可以轻松通过的</p>\n","tags":["Knowledge","Misc"]},{"title":"质数","url":"/2022/04/01/%E8%B4%A8%E6%95%B0/","content":"<h1 id=\"质数\"><a href=\"#质数\" class=\"headerlink\" title=\"质数\"></a>质数</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>每个所有因数只有自己和1的数叫做<strong>质数</strong>，而其他不符合这个条件的数叫做<strong>合数</strong>。</p>\n<h2 id=\"筛出质数\"><a href=\"#筛出质数\" class=\"headerlink\" title=\"筛出质数\"></a>筛出质数</h2><ul>\n<li>暴力筛法<ul>\n<li>每次取出所有小于它的不是1的数，判断是否为它的因数，如果全都不是，那么这个数就是质数。</li>\n<li>时间复杂度$O(n)$。</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n<ul>\n<li>优化过的暴力筛法<ul>\n<li>每次取出所有小于等于根号它的数，判断是否为它的因数，如果全都不是，那么这个数就是质数。</li>\n<li>正确性：每个合数必然有一个小于等于根号它的因数，可以用反证法证明。</li>\n<li>时间复杂度$O(\\sqrt{n})$</li>\n</ul>\n</li>\n<li>埃氏筛<ul>\n<li>每一个是质数的数都标记它的倍数为合数，所有没有被标记的就是质数。</li>\n<li>正确性：每个合数必然有至少一个质因子，而每个质数的质因子只有它本身。</li>\n<li>时间复杂度$O(n\\log \\log n)$。（反正接近线性，应该也没人会特意卡这个）</li>\n</ul>\n</li>\n<li>欧式筛<ul>\n<li>我们模拟一下，可以发现埃氏筛中，有些数会被筛很多次，如12即被2筛过，也被3筛过，这样会浪费大量时间，如果我们规定每个数只能被它的最小质因子筛，那就不会重复筛一个数了。</li>\n<li>正确性：一个数的质因子之间有大小关系，我们只要让这个数被最小的质因子筛，顺序就是唯一的。</li>\n<li>时间复杂度$O(n)$。比较推荐使用这种筛法，因为它还可以筛一些积性函数。</li>\n</ul>\n</li>\n</ul>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P3383\">P3383</a></p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e8</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,vis[N],pri[N],tot,lim;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123; <span class=\"comment\">//是质数 </span></span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (pri[j]&gt;vis[i] || <span class=\"number\">1ll</span>*pri[j]*i&gt;lim) <span class=\"keyword\">break</span>; <span class=\"comment\">//只能由最小的因数筛掉 </span></span><br><span class=\"line\">\t\t\tvis[pri[j]*i] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;lim&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\tcout&lt;&lt;pri[x]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"质因数分解\"><a href=\"#质因数分解\" class=\"headerlink\" title=\"质因数分解\"></a>质因数分解</h2><p>从2~$\\sqrt{n}$里面枚举因数，一直除，直到这个数不含有此因数为止。</p>\n<p>有没有可能除了一个合数呢？不可能。</p>\n<p>因为每个合数必然由比它小的质数组成，而我们把所有组成它的质数都除掉了，所以不可能出现合数。</p>\n<p>时间复杂度为$O(\\sqrt{n})$，你大可无视里面不断除的过程，这个过程在long long范围内也不会超过64次。</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P2043\">P2043</a></p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,cnt[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">work</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> k = <span class=\"built_in\">sqrt</span>(x);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tx/=i;</span><br><span class=\"line\">\t\t\tcnt[i]++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&gt;<span class=\"number\">1</span>) cnt[x]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++) <span class=\"built_in\">work</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">if</span> (cnt[i]) cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当$n$更大时，可以配合埃氏筛，先把所有质数筛出来，1~$n$中是质数和质数的任意次方的倍数的数都对质因子有贡献。时间复杂度为$O(n\\log n)$。（虽然埃氏筛要带两$\\log$，但是这里就忽略不计了，你也可以用线性筛实现）</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,cnt[N],vis[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> las = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n/i;j++)&#123;</span><br><span class=\"line\">\t\t\t\tvis[i*j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (j/las == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tcnt[i]+=<span class=\"number\">1ll</span>*n/j/i;</span><br><span class=\"line\">\t\t\t\t\tlas*=i;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">if</span> (cnt[i]) cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Fun-Facts\"><a href=\"#Fun-Facts\" class=\"headerlink\" title=\"Fun Facts\"></a>Fun Facts</h2><p>1~1000中有168个质数</p>\n<p>1~10000中有1229个质数</p>\n<p>1~100000中有9592个质数</p>\n<p>1~1000000中有78498个质数</p>\n<p>1~$2^{32}$中有203280221个质数</p>\n<p>在$10^{18}$内的最大质数间隙不超过1500</p>\n","tags":["Knowledge","数学"]},{"title":"莫队算法初步","url":"/2022/02/09/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/","content":"<h2 id=\"莫队的基本思想\"><a href=\"#莫队的基本思想\" class=\"headerlink\" title=\"莫队的基本思想\"></a>莫队的基本思想</h2><p>简单的莫队是针对这样一种题目：给定很多离线的询问，没有修改，而且数据范围根号算法能过。</p>\n<p>一般的算法都是对单次查询过程进行优化，但莫队对询问进行了优化：</p>\n<span id=\"more\"></span>\n<p>把询问可能出现的区间分成$\\sqrt n$个块，再将询问排序，具体规则是先对左端点所在的块排序，如果左端点在同一块中，就对右端点升序排序。</p>\n<p>这样，我们把排序好的询问一个个计算，定义$L$为当前左端点，$R$为当前右端点，处理每个询问时把左端点和右端点都移动到当前询问的左、右端点处，移动时用$O(1)$或接近的时间复杂度维护$L$和$R$之间的答案，移动好时，这个询问对应的答案就成了$L$和$R$之间的答案。</p>\n<p>但是莫队为什么快呢？因为对于每个块中的询问，左端点都是在这个块中活动$q$次询问可能会卡成$q \\times \\sqrt n$，假设每个询问都倍卡，左端点移动的复杂度最大就是$O(q \\times \\sqrt n)$。再看右端点，如果每个块中右端点都从这个块的起点移动到了最后一个块的终点，右端点移动的复杂度最大就是$O(n \\times \\sqrt n)$。如果$L$和$R$移动的代价为$w$，总共的复杂度最大就是$O(w \\times (n+q) \\times \\sqrt n)$。</p>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><p><a href=\"https://www.luogu.com.cn/problem/P2709\">P2709 小B的询问</a></p>\n<p><a href=\"http://zhengruioi.com/contest/966/problem/1992\">ZROI 奇数</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/SP3267\">SP3267 DQUERY</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF86D\">CF86D Powerful array</a></p>\n<p>To be added.</p>\n<h2 id=\"带修莫队\"><a href=\"#带修莫队\" class=\"headerlink\" title=\"带修莫队\"></a>带修莫队</h2>","tags":["Knowledge","分块"]},{"title":"超能粒子炮 题解","url":"/2022/04/12/%E8%B6%85%E8%83%BD%E7%B2%92%E5%AD%90%E7%82%AE-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"超能粒子炮-题解\"><a href=\"#超能粒子炮-题解\" class=\"headerlink\" title=\"超能粒子炮 题解\"></a>超能粒子炮 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>让你求$(\\sum_{i=0}^kC_n^i \\mod 2333) \\mod 2333$。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>题目中没有明确说明$k$和$n$的关系，如果$k\\geq n$，那么答案就是$2^n\\mod 2333$。</p>\n<p>现在，我们只用考虑$k&lt;n$的情况了。</p>\n<p>$k$最大可以到$1e18$，显然无法直接计算。</p>\n<span id=\"more\"></span>\n<p>但是这个模数较小，于是我们想到了Lucas定理，这样我们所有计算的东西都在2333以内了。</p>\n<p>手动模拟一下，当$i\\geq2333$时，我们使用Lucas定理将式子变成$C_{n\\mod 2333}^{i\\mod 2333}\\cdot C_{n/2333}^{i/2333}$。</p>\n<p>当$2333\\leq i&lt; 4666$时，后面的东西没有变化，前面的就是$2^{n\\mod 2333}-1$。这启示我们这个式子中存在很多一样的东西，我们可以把它们捆绑在一起来降低复杂度。</p>\n<p>前面的东西就是一直循环的，我们现在需要计算后面的东西，而后面的东西也可以用Lucas定理化简：</p>\n<p>$C_{n/2333}^{i/2333} = C_{n/2333\\mod 2333}^{i/2333\\mod 2333}\\cdot C_{n/{2333^2}}^{i/{2333^2}}$。</p>\n<p>前面的东西每2333个数变化一次，后面的又可以重复计算，这不就可以用递归解决吗？</p>\n<p>设$f(x,n)$表示计算$\\sum_{i=0}^x C_{n}^i$。这个式子可以简化成$\\sum_{i=0}^{x/p-1}C_{n/2333}^i\\cdot (\\sum_{j=0}^{2332}C_{n\\mod 2333}^j)+C_{n/2333}^{x/2333}\\cdot \\sum_{i=0}^{x\\mod 2333}C_{n\\mod 2333}^i$。</p>\n<p>前面的一坨显然可以化为$f(k/p-1,n/2333)$，这样就可以递归解决这个问题了。</p>\n<p>先花$2333^2$的时间预处理出组合数和前缀和，之后用$T\\log^2 p$的时间解决问题（有一个$\\log$花在求$C_{n/2333}^{k/2333}$上）。</p>\n<h2 id=\"Code-：\"><a href=\"#Code-：\" class=\"headerlink\" title=\"$Code$：\"></a>$Code$：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">3e3</span>+<span class=\"number\">10</span>,p = <span class=\"number\">2333</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,k,c[N][N],sum[N][N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tc[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;p;j++) sum[<span class=\"number\">0</span>][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;p;i++)&#123;</span><br><span class=\"line\">\t\tc[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=i;j++) c[i][j] = (c[i<span class=\"number\">-1</span>][j]+c[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>])%p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;p;j++) sum[i][j] = sum[i][j<span class=\"number\">-1</span>]+c[i][j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lucas</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!x) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c[y%p][x%p]*<span class=\"built_in\">lucas</span>(x/p,y/p)%p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"built_in\">f</span>(x/p<span class=\"number\">-1</span>,n/p)*sum[n%<span class=\"number\">2333</span>][p<span class=\"number\">-1</span>]%p+<span class=\"built_in\">lucas</span>(x/p,n/p)*sum[n%<span class=\"number\">2333</span>][x%<span class=\"number\">2333</span>]%p)%p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"built_in\">f</span>(k,n)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","数学","组合数学"]},{"title":"近期博客Latex渲染失败的说明","url":"/2022/06/05/%E8%BF%91%E6%9C%9F%E5%8D%9A%E5%AE%A2Latex%E6%B8%B2%E6%9F%93%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%AF%B4%E6%98%8E/","content":"<h1 id=\"近期博客Latex渲染失败的说明\"><a href=\"#近期博客Latex渲染失败的说明\" class=\"headerlink\" title=\"近期博客Latex渲染失败的说明\"></a>近期博客Latex渲染失败的说明</h1><h2 id=\"问题所在\"><a href=\"#问题所在\" class=\"headerlink\" title=\"问题所在\"></a>问题所在</h2><p>由于某些众所周知的原因，负责cdn加速的jsdelivr被-Wall了，造成了在国内无法获取一个叫mathjax.min.js的东西，进而导致博客渲染失败。这也是本博客内一些托管于github的图片访问失败的原因。</p>\n<h2 id=\"如何解决\"><a href=\"#如何解决\" class=\"headerlink\" title=\"如何解决\"></a>如何解决</h2><p>找了一些博客，发现cdn服务提供商远不止jsdelivr一个，我们可以使用其他的诸如cdnjs的cdn提供商，而我对cdn所知甚少，就选择了在config.yml文档中预留的katex的cdnjs服务，没想到这让$\\LaTeX$的渲染成功了。</p>\n<h2 id=\"启示\"><a href=\"#启示\" class=\"headerlink\" title=\"启示\"></a>启示</h2><p>在渲染失败的问题出现的最初几天，我百思不得其解，换了至少$4$个渲染引擎，把能够在设置文档里面调的设置都调了，却无果而终。</p>\n<p>之后的几个月里，我从图床加载不了的问题中，隐隐约约感觉到是jsdelivr的问题，但是没有深究。</p>\n<p>在最近的几天，我忘记了回国，在国外访问了我的博客，却意外的发现$\\LaTeX$全都安然无恙，也就是说，jsdelivr被<del>[强调]</del>了。</p>\n<p>今天，在闲暇之余搜了jsdelivr，果不其然的发现有一堆人讨论这个问题，最终从config.yml中找到了解决方案。</p>\n<p>问题的解决往往不是一瞬间的，又常常是一刹那的。</p>\n<p>无论身处何处，面对何事，都要保持一颗对问题乐于探索、敢于质疑、勇于突破的心。</p>\n<p>May humans win.</p>\n","tags":["Life"]},{"title":"选数 题解","url":"/2022/07/15/%E9%80%89%E6%95%B0-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"选数-题解\"><a href=\"#选数-题解\" class=\"headerlink\" title=\"选数 题解\"></a>选数 题解</h1><p>$\\color{lightgreen}Status: OK$</p>\n<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>在 $[l,r]$ 内选择 $n$ 个数，使其 $\\gcd = k$，问选数的方案数有多少。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>由于 $\\gcd = k$，所以每个数必定是 $k$ 的倍数，转换为在 $[\\frac{l}{k},\\frac{r}{k}]$ 中选 $\\gcd = 1$ 的 $n$ 个数的组合。</p>\n<span id=\"more\"></span>\n<p>用式子表示是这样的：</p>\n<p>$\\sum_{a_1=\\frac{l}{k}}^\\frac{r}{k}\\cdots \\sum_{a_n=\\frac{l}{k}}^\\frac{r}{k}[\\gcd(a_1,a_2\\cdots a_n) = 1]$</p>\n<p>反演掉：</p>\n<p>$\\sum_{a_1=\\frac{l}{k}}^\\frac{r}{k}\\cdots \\sum_{a_n=\\frac{l}{k}}^\\frac{r}{k}\\sum_{d|\\gcd(a_1,a_2\\cdots a_n)}\\mu(d)$</p>\n<p>枚举 $d$：</p>\n<p>$\\sum_{d=1}^{\\frac{r}{k}}\\mu(d)(\\frac{r}{kd}-\\frac{l-1}{kd})^n$</p>\n<p>后面的东西是个整除分块加上一个快速幂，时间复杂度为 $O(\\sqrt n\\cdot \\log n)$。</p>\n<p>但是，我们无法在给定的时间内预处理出 $\\mu(d)$ 的前缀和，怎么办？亚线性在线回答！</p>\n<p>直接上杜教筛，时间复杂度降为 $O(n^{\\frac{2}{3}})$。</p>\n<p>虽然后面还要带个 $\\sqrt n$，但是由于前面求的都不是满的，所以复杂度应该不会很高。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e6</span>+<span class=\"number\">10</span>,lim = <span class=\"number\">1e6</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,a,b,vis[N],pri[N],tot,mu[N];</span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) mu[i]+=mu[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tll ret = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ret = ret*bas%mod;</span><br><span class=\"line\">\t\tbas = bas*bas%mod;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">getmu</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;=lim) <span class=\"keyword\">return</span> mu[x];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mp.<span class=\"built_in\">count</span>(x)) <span class=\"keyword\">return</span> mp[x];</span><br><span class=\"line\">\tll ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (ll l=<span class=\"number\">2</span>,r;l&lt;=x;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tr = x/(x/l);</span><br><span class=\"line\">\t\tans = (ans-(r-l+<span class=\"number\">1</span>)*<span class=\"built_in\">getmu</span>(x/l))%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mp[x] = ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = b/k;</span><br><span class=\"line\">\ta--;</span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>,r;l&lt;=lim;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a/l) r = <span class=\"built_in\">min</span>(a/(a/l),b/(b/l));</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = b/(b/l);</span><br><span class=\"line\">\t\tans = (ans+(<span class=\"built_in\">getmu</span>(r)-<span class=\"built_in\">getmu</span>(l<span class=\"number\">-1</span>))*<span class=\"built_in\">ksm</span>(b/(<span class=\"number\">1ll</span>*k*l)-a/(<span class=\"number\">1ll</span>*k*l),n))%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;(ans%mod+mod)%mod&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["数学","Editorial","莫比乌斯反演","杜教筛"]},{"title":"题解 UVA323 Jury Compromise","url":"/2022/03/19/%E9%A2%98%E8%A7%A3-UVA323-Jury-Compromise/","content":"<h1 id=\"题解-UVA323-Jury-Compromise\"><a href=\"#题解-UVA323-Jury-Compromise\" class=\"headerlink\" title=\"题解 UVA323 Jury Compromise\"></a>题解 UVA323 Jury Compromise</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>有 $n$ 个人，从中选出$m$个人，每个人有两个得分值$a$和$b$，我们要使$|\\sum^{m}_{i=1}a[i]-\\sum^{m}_{i=1}b[i]|$最小，如果有多种情况满足，选择其中$\\sum^{m}_{i=1}a[i]+\\sum^{m}_{i=1}b[i]$最大的一个。输出最大分值和选择的方案。</p>\n<p>$n\\leq200$</p>\n<p>$m\\leq20$</p>\n<p>$0\\leq a,b\\leq20$</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"O-2-n-算法\"><a href=\"#O-2-n-算法\" class=\"headerlink\" title=\"$O(2^n)$算法\"></a>$O(2^n)$算法</h3><p>第一眼看上去，好像没有任何思路，贪心也不太可行。</p>\n<p>于是考虑暴力。。。</p>\n<p>最暴力的想法是枚举选的人，求出最值。注意到，题目中的分值范围很小，所有人分差最大也只是$400$，所以这$2^{200}$种选择里面，必然有很多种选择，它们的分差是一样的，这就导致了很多重复计算，我们不如枚举分差。</p>\n<p>枚举分差，显然不能直接搜索，而DP可以很好地解决这个问题。</p>\n<h3 id=\"O-nm-2-错误算法\"><a href=\"#O-nm-2-错误算法\" class=\"headerlink\" title=\"$O(nm^2)$错误算法\"></a>$O(nm^2)$错误算法</h3><p>我们初步的想法是设$f[i]$表示分差为$i$时，能够取到的最大分值，每次加入一个人时，我们枚举分差，更新数组即可。</p>\n<p>第$j$个人加入后得到$i$的分差的转移方程：$f[i] = max(f[i],f[i-a[j]+b[j]]+a[j]+b[j])$</p>\n<p>但是，这样做会有后效性，在$j$不变时，我们可能先改动了$f[i-a[j]+b[j]]$的值，导致这里的$f[i-a[j]+b[j]]$不是上一次的值，导致使用多次第$j$个人。</p>\n<p>如果判断$a[j]-b[j]$的正负来确定枚举顺序的确可以解决这个问题，但是这样不好处理之后的输出方案问题，于是我们索性多开一个维度。</p>\n<h3 id=\"O-nm-2-正确算法\"><a href=\"#O-nm-2-正确算法\" class=\"headerlink\" title=\"$O(nm^2)$正确算法\"></a>$O(nm^2)$正确算法</h3><p>设$f[i][j]$表示选择了$i$个人，分差为$j$的方案数。</p>\n<p>第$p$个人加入后得到$j$的分差的转移方程：$f[i][j] = max(f[i][j],f[i-1][j-a[p]+b[p]]+a[p]+b[p])$</p>\n<p>由于下标不能出现负数，我们把所有的分差都加上$400$，这样就没有负数了。</p>\n<p>初始化时，将所有数都设为负无穷，$f[0][400] = 0$，这样可以保证不会从不合法的状态转移。</p>\n<p>输出时我们找到一个和$400$最近的，值最大且大于$0$的就行了。</p>\n<h3 id=\"剩下的输出\"><a href=\"#剩下的输出\" class=\"headerlink\" title=\"剩下的输出\"></a>剩下的输出</h3><p>我们不仅要输出最大值，还要输出选择的方案，我们考虑用一个数组记录转移的情况。</p>\n<p>设$d[i][j][p]$表示前$i$个人中，选择了$j$个人，得到$p$的分差，最后选择的是哪个人。</p>\n<p>转移时先把上一次的照搬过来，对应不选第$i$个人的情况，之后如果这一次能够让$f[j][p]$更大，就更新$d[i][j][p]$。</p>\n<p>输出方案时，我们从$d[n][m][Min]$开始输出，每次$Min-=a[d[n[m][Min]]]-b[d[n][m][Min]]$，$m-=1$，$n$转移到$d[n][m][Min]-1$，一直到$m=0$时结束。</p>\n<p>之后倒序输出就行了</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>前面的DP应该不是很难想到，但是各种细节需要注意：</p>\n<ol>\n<li>数组下标不能为负数，要加一个基准值</li>\n<li>转移时记录转移情况，方便输出方案</li>\n<li>数组要初始化为负无穷，避免从不合法的情况转移</li>\n<li>多测要清空</li>\n</ol>\n<p>本题实际上是将每个人视为一个物品，做了一次01背包。考察了背包和输出方案。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e3</span>+<span class=\"number\">10</span>,M = <span class=\"number\">25</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,f[M][N],p[N],q[N],d[<span class=\"number\">205</span>][M][N],totp,totq,per[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = m,nnow = n;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (now)&#123;</span><br><span class=\"line\">\t\tnnow = d[nnow][now][x];</span><br><span class=\"line\">\t\tper[now] = nnow;</span><br><span class=\"line\">\t\ttotp+=p[nnow];</span><br><span class=\"line\">\t\ttotq+=q[nnow];</span><br><span class=\"line\">\t\tx = x-p[nnow]+q[nnow];</span><br><span class=\"line\">\t\tnnow--;</span><br><span class=\"line\">\t\tnow--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!n &amp;&amp; !m) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\tnow++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">-0x3f</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\t\ttotp = totq = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;p[i]&gt;&gt;q[i];</span><br><span class=\"line\">\t\tf[<span class=\"number\">0</span>][<span class=\"number\">400</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p1=<span class=\"number\">1</span>;p1&lt;=n;p1++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">800</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\td[p1][i][j] = d[p1<span class=\"number\">-1</span>][i][j];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=m;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">800</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ((j-p[p1]+q[p1])&lt;<span class=\"number\">0</span> || (j-p[p1]+q[p1])&gt;<span class=\"number\">800</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (f[i][j]&lt;f[i<span class=\"number\">-1</span>][j-(p[p1]-q[p1])]+p[p1]+q[p1])&#123;</span><br><span class=\"line\">\t\t\t\t\t\tf[i][j] = f[i<span class=\"number\">-1</span>][j-(p[p1]-q[p1])]+p[p1]+q[p1];</span><br><span class=\"line\">\t\t\t\t\t\td[p1][i][j] = p1;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> Min = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">800</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (f[m][i]&gt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(Min<span class=\"number\">-400</span>) == <span class=\"built_in\">abs</span>(i<span class=\"number\">-400</span>))&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (f[m][i]&gt;=f[m][Min]) Min = i;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(Min<span class=\"number\">-400</span>)&gt;<span class=\"built_in\">abs</span>(i<span class=\"number\">-400</span>)) Min = i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">get</span>(Min);</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Jury #&quot;</span>&lt;&lt;now&lt;&lt;endl;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Best jury has value &quot;</span>&lt;&lt;totp&lt;&lt;<span class=\"string\">&quot; for prosecution and value &quot;</span>&lt;&lt;totq&lt;&lt;<span class=\"string\">&quot; for defence:&quot;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(per+<span class=\"number\">1</span>,per+<span class=\"number\">1</span>+m);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cout&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;per[i];</span><br><span class=\"line\">\t\tcout&lt;&lt;endl&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","DP"]}]